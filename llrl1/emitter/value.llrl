(import "~/emitter/ir" S _.S CapturedUse _.CapturedUse)
(export Value _.Value value:_)
(export DynamicCall DynamicCall._ dynamic-call DynamicArg DynamicArg._ DynamicRet DynamicRet._)

; NOTE: Unlike llrl0 implementation, the values handled by the backend are not abstracted and
; we cannot delay values interconversion. it is difficult to implement in the same way because
; there is no associated types or fundeps in the llrl type class system.
(derive (Eq Ord DebugDisplay Hash) value-data Value
  (value:bool Bool)
  (value:sexp (S CapturedUse))
  (value:result-sexp-string (Result (S CapturedUse) String))
  value:other)

(instance Display.Value (Display Value)
  (function (display! w a)
    (match a
      [(value:bool (let value)) (display! w value)]
      [(value:sexp (let sexp)) (display! w sexp)]
      [(value:result-sexp-string (ok (let sexp))) (display-all! w "(ok " sexp ")")]
      [(value:result-sexp-string (err (let error))) (display-all! w "(err " (debug error) ")")]
      [value:other (display! w "<other>")])))

(class (DynamicCall A)
  (function (dynamic-call f args) {(-> A (Array Value) (Result Value String))}))

(class (DynamicArg A)
  (function (dynamic-arg v) {(-> Value (Result A String))}))

(class (DynamicRet A)
  (function (dynamic-ret v) {(-> A Value)}))

($$ begin
  ($for-each
    [$arity $name $params]
    ([0 Nullary ()]
     [1 Unary (A)]
     [2 Binary (A B)]
     [3 Ternary (A B C)])
    (instance
      ($symbol-concat DynamicCall. $name)
      (forall ($for-each $param $params $param) R)
      (DynamicCall (-> ($for-each $param $params $param) R))
      (where ($for-each $param $params (DynamicArg $param)) (DynamicRet R))
      (function (dynamic-call f args)
        (when (ne? (array/length args) $arity)
          (err (string "Expected " $arity " arguments but got " (array/length args) " arguments"))!)

        (let* (($for-each $param $params
                 [($symbol-concat arg- $param) (dynamic-arg (get args[0]))!]
                 [args (array/skip 1 args)])
               [ret (f ($for-each $param $params ($symbol-concat arg- $param)))])
          (ok (dynamic-ret ret)))))))

(instance DynamicArg.Sexp (DynamicArg (S CapturedUse))
  (function (dynamic-arg v)
    (match v
      [(value:sexp (let s)) (ok s)]
      [_ (err (string "Cannot treat " v " as Sexp"))])))

(instance DynamicRet.Bool (DynamicRet Bool)
  (function (dynamic-ret v)
    (value:bool v)))

(instance DynamicRet.ResultSexpString (DynamicRet (Result (S CapturedUse) String))
  (function (dynamic-ret v)
    (value:result-sexp-string v)))
