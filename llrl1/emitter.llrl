(import "std/ord-map" _)
(import "std/ord-set" _)
(import "~/util" _)
(import "~/report" Report _.Report report/_ phase:_)
(import "~/sexp" S _.S)
(import "~/ast" [ast/_ _])
(import "~/module" [m/_ _])
(import "~/emitter/ir" _)
(import "~/emitter/simplifier" [simplifier/_ _])
(export Value _.Value value:_ Backend backend/_ Emitter _.Emitter emitter/_)

; NOTE: Unlike llrl0 implementation, the values handled by the backend are not abstract values and
; cannot delay interconversion. it is difficult to implement in the same way because there is no
; associated types or fundeps in the llrl type class system.
(derive (Eq Ord DebugDisplay Hash) value-data Value
  (value:bool Bool)
  (value:sexp (S ast/Construct))
  (value:result-sexp-string (Result (S ast/Construct) String))
  value:other)

(instance Display.Value (Display Value)
  (function (display! w a)
    (match a
      [(value:bool (let value)) (display! w value)]
      [(value:sexp (let sexp)) (display! w sexp)]
      [(value:result-sexp-string (ok (let sexp))) (display-all! w "(ok " sexp ")")]
      [(value:result-sexp-string (err (let error))) (display-all! w "(err " (debug error) ")")]
      [value:other (display! w "<other>")])))

(class (Backend B)
  (function (backend/put-def! id def b) {(-> CtId CtDef B unit)})
  (function (backend/put-main! init b) {(-> Init B unit)})
  (function (backend/execute-main! b) {(-> B (Result Value String))})
  (function (backend/execute-function! id args b) {(-> CtId (Array Value) B (Result Value String))})
  (function (backend/complete! report b) {(-> Report B unit)}))

(data (Emitter B)
  (emitter:
    B
    Report
    (OrdMap m/ModuleId m/Module)
    (OrdSet m/ModuleId)
    CtIdGen
    RtIdGen
    (OrdMap CtKey CtId)
    (OrdMap RtKey RtId)
    (OrdMap CtId ProcessingCtDef)
    ; TODO: (OrdMap CtId data-expander/DataExpansion)
    (Ref Generation)))

(instance m/Backend.Emitter (forall B) (m/Backend (Emitter B)) (where (Backend B))
  (function (backend/add-module! module entry-point? e)
    (emitter/register-module! module e)
    (when entry-point? (emitter/entry-module! (m/module/id module) e)))

  (function (backend/execute-macro! macro-id s e)
    (let ([macro-fun (ct/force-id (emitter/populate! macro-id e))]
          [args (array (value:sexp s))])
      (match (backend/execute-function! macro-fun args (emitter/backend e))!
        [(value:result-sexp-string (let result))
          result]
        [(let value)
          (err (string "Cannot treat " (debug value) " as (Result Sexp String)"))]))))

(instance m/ModuleSet.Emitter (forall B) (m/ModuleSet (Emitter B))
  (function (module-set/get? mid e) (m/module-set/get? mid (modules e))))

(instance simplifier/Env.Emitter (forall B) (simplifier/Env (Emitter B))
  (function (alloc-ct! e)
    (ct-id-gen/next! (ct-id-gen e)))

  (function (issue-ct! c e)
    (let1 construct (conv c)
      (bind-ct! (ct-key:construct construct) [^0 (simplifier/simplify-def! e construct)] e)))

  (function (alloc-rt! e)
    (rt-id-gen/next! (rt-id-gen e)))

  (function (issue-rt! c e)
    (bind-rt! (rt-key:construct (conv c)) e)))

(getter emitter:
  emitter/backend
  emitter/report
  modules
  initialized-modules
  ct-id-gen
  rt-id-gen
  ct-mapping
  rt-mapping
  ct-defs
  ; TODO: data-expansions
  next-generation)

(function (emitter/new backend) {(forall B) (-> B (Emitter B)) (where (Backend B))}
  (emitter:
    backend
    (report/new)
    ord-map/empty
    ord-set/empty
    (ct-id-gen/new)
    (rt-id-gen/new)
    ord-map/empty
    ord-map/empty
    ord-map/empty
    ; TODO: data-expansions
    (ref (generation: 0))))

(function (emitter/def? id e) {(forall B) (-> CtId (Emitter B) (Option CtDef))}
  (let1 d (|> e ct-defs (ord-map/get? id))?
    (when? (processing-ct-def/populated? d) (conv d))))

(function (emitter/defs e) {(forall B) (-> (Emitter B) (Iterator (: CtId CtDef)))}
  (|> e
      ct-defs
      ord-map/elems
      (it/filter (case1 (: _ (let d)) (processing-ct-def/populated? d)))
      (it/map (case1 (: (let id) (let d)) (: id (conv d))))))

(function (emitter/register-module! module e) {(forall B) (-> m/Module (Emitter B) unit)}
  (ignore (ord-map/insert! (m/module/id module) module (modules e))))

(function (emitter/entry-module! mid e) {(forall B) (-> m/ModuleId (Emitter B) unit) (where (Backend B))}
  (when (not (ord-set/insert! mid (initialized-modules e))) (return))
  (for (let expr) (|> e modules (ord-map/get? mid) option/force m/module/ast-root ast/root/init-expressions)
    (match expr
      [(ast/init-expr:ensure-initialized (let mid))
        (emitter/entry-module! mid e)]
      [(ast/init-expr:eval (let expr))
        (backend/put-main! (emitter/populate! expr e) (emitter/backend e))])))

(function (emitter/populate! src e) {(forall B S D) (-> S (Emitter B) D) (where (Backend B) (simplifier/Simplify S D))}
  (with1 (: (let dest) (let defs)) (report/on (emitter/report e) phase:emit (populate! src e))
    (for (: (let id) (let def)) defs (backend/put-def! id def (emitter/backend e)))
    dest))

(function (emitter/complete! report e) {(forall B) (-> Report (Emitter B) unit)}
  (report/merge! (emitter/report e) report))

(function (populate! src e)
  {(forall B S D) (-> S (Emitter B) (: D (Iterator (: CtId CtDef)))) (where (Backend B) (simplifier/Simplify S D))}
  (: (simplifier/simplify! e src)
     iterator/empty)) ; TODO

(function (bind-ct! key build e) {(forall B) (-> CtKey (-> (Option CtDef)) (Emitter B) CtId)}
  (if-match1 (some (let id)) (ord-map/get? key (ct-mapping e))
    id
    (let1 id (ct-id-gen/next! (ct-id-gen e))
      (ord-map/insert! key id (ct-mapping e))
      (when-match1 (some (let def)) (build)
        (ord-map/insert!
          id
          (processing-ct-def: (if-match1 (ct-def:generic _ _) def phase:generalized phase:instantiated) none def)
          (ct-defs e)))
      id)))

(function (bind-rt! key e) {(forall B) (-> RtKey (Emitter B) RtId)}
  (if-match1 (some (let id)) (ord-map/get? key (rt-mapping e))
    id
    (let1 id (rt-id-gen/next! (rt-id-gen e))
      (ord-map/insert! key id (rt-mapping e))
      id)))

(derive (Eq Ord DebugDisplay Hash) value-data CtKey
  (ct-key:construct ast/Construct)
  (ct-key:inst CtId (Array Ct)))

(derive (Eq Ord DebugDisplay Hash) value-data RtKey
  (rt-key:construct ast/Construct))

(derive (DebugDisplay) value-data ProcessingCtDef
  (processing-ct-def: Phase (Option Generation) CtDef))

(getter processing-ct-def: processing-ct-def/phase processing-ct-def/generation processing-ct-def/def)

(instance Conv.From.ProcessingCtDef.To.CtDef (Conv ProcessingCtDef CtDef)
  (function (conv a) (processing-ct-def/def a)))

(function (processing-ct-def/populated? d) {(-> ProcessingCtDef Bool)}
  (with1 (processing-ct-def: (let phase) (let gen) (let def)) d
    (and (eq? phase phase:normalized)
         (is? (some _) gen)
         (not (is? (ct-def:data _) def)))))

(derive (Eq Ord DebugDisplay Hash) value-data Phase
  phase:generalized
  phase:instantiated
  phase:normalizing
  phase:normalized)

(derive (Eq Ord DebugDisplay Hash) value-data Generation
  (generation: U64))

(function (generation/next gen) {(-> Generation Generation)}
  (with1 (generation: (let n)) gen
    (generation: (+ n 1))))
