; This file is generated by xtencg. !!!DO NOT EDIT THIS FILE!!!

(import "~/asm/encoding" _)
(import "~/asm/operand" _)
(export WriteInst WriteInst._ write-inst!)

(export adcb! Adcb adcb:)
(export adcl! Adcl adcl:)
(export adcq! Adcq adcq:)
(export adcw! Adcw adcw:)
(export addb! Addb addb:)
(export addl! Addl addl:)
(export addpd! Addpd addpd:)
(export addps! Addps addps:)
(export addq! Addq addq:)
(export addsd! Addsd addsd:)
(export addss! Addss addss:)
(export addw! Addw addw:)
(export andb! Andb andb:)
(export andl! Andl andl:)
(export andnpd! Andnpd andnpd:)
(export andnps! Andnps andnps:)
(export andpd! Andpd andpd:)
(export andps! Andps andps:)
(export andq! Andq andq:)
(export andw! Andw andw:)
(export blendpd! Blendpd blendpd:)
(export blendps! Blendps blendps:)
(export blendvpd! Blendvpd blendvpd:)
(export blendvps! Blendvps blendvps:)
(export bsfl! Bsfl bsfl:)
(export bsfq! Bsfq bsfq:)
(export bsfw! Bsfw bsfw:)
(export bsrl! Bsrl bsrl:)
(export bsrq! Bsrq bsrq:)
(export bsrw! Bsrw bsrw:)
(export bswap! Bswap bswap:)
(export btcl! Btcl btcl:)
(export btcq! Btcq btcq:)
(export btcw! Btcw btcw:)
(export btl! Btl btl:)
(export btq! Btq btq:)
(export btrl! Btrl btrl:)
(export btrq! Btrq btrq:)
(export btrw! Btrw btrw:)
(export btsl! Btsl btsl:)
(export btsq! Btsq btsq:)
(export btsw! Btsw btsw:)
(export btw! Btw btw:)
(export callq! Callq callq:)
(export cbtw! Cbtw cbtw:)
(export clc! Clc clc:)
(export cld! Cld cld:)
(export cli! Cli cli:)
(export cltd! Cltd cltd:)
(export cltq! Cltq cltq:)
(export clts! Clts clts:)
(export cmc! Cmc cmc:)
(export cmpb! Cmpb cmpb:)
(export cmpl! Cmpl cmpl:)
(export cmppd! Cmppd cmppd:)
(export cmpps! Cmpps cmpps:)
(export cmpq! Cmpq cmpq:)
(export cmpsd! Cmpsd cmpsd:)
(export cmpsl! Cmpsl cmpsl:)
(export cmpss! Cmpss cmpss:)
(export cmpw! Cmpw cmpw:)
(export cmpxchgb! Cmpxchgb cmpxchgb:)
(export cmpxchgl! Cmpxchgl cmpxchgl:)
(export cmpxchgq! Cmpxchgq cmpxchgq:)
(export cmpxchgw! Cmpxchgw cmpxchgw:)
(export comisd! Comisd comisd:)
(export comiss! Comiss comiss:)
(export cpuid! Cpuid cpuid:)
(export cqto! Cqto cqto:)
(export crc32b! Crc32b crc32b:)
(export crc32l! Crc32l crc32l:)
(export crc32q! Crc32q crc32q:)
(export crc32w! Crc32w crc32w:)
(export cvtdq2pd! Cvtdq2pd cvtdq2pd:)
(export cvtdq2ps! Cvtdq2ps cvtdq2ps:)
(export cvtpd2dq! Cvtpd2dq cvtpd2dq:)
(export cvtpd2ps! Cvtpd2ps cvtpd2ps:)
(export cvtps2dq! Cvtps2dq cvtps2dq:)
(export cvtps2pd! Cvtps2pd cvtps2pd:)
(export cvtsd2si! Cvtsd2si cvtsd2si:)
(export cvtsd2ss! Cvtsd2ss cvtsd2ss:)
(export cvtsi2sdl! Cvtsi2sdl cvtsi2sdl:)
(export cvtsi2sdq! Cvtsi2sdq cvtsi2sdq:)
(export cvtsi2ssl! Cvtsi2ssl cvtsi2ssl:)
(export cvtsi2ssq! Cvtsi2ssq cvtsi2ssq:)
(export cvtss2sd! Cvtss2sd cvtss2sd:)
(export cvtss2si! Cvtss2si cvtss2si:)
(export cvttpd2dq! Cvttpd2dq cvttpd2dq:)
(export cvttps2dq! Cvttps2dq cvttps2dq:)
(export cvttsd2si! Cvttsd2si cvttsd2si:)
(export cvttss2si! Cvttss2si cvttss2si:)
(export cwtd! Cwtd cwtd:)
(export cwtl! Cwtl cwtl:)
(export decb! Decb decb:)
(export decl! Decl decl:)
(export decq! Decq decq:)
(export decw! Decw decw:)
(export divb! Divb divb:)
(export divl! Divl divl:)
(export divpd! Divpd divpd:)
(export divps! Divps divps:)
(export divq! Divq divq:)
(export divsd! Divsd divsd:)
(export divss! Divss divss:)
(export divw! Divw divw:)
(export dppd! Dppd dppd:)
(export dpps! Dpps dpps:)
(export emms! Emms emms:)
(export extractps! Extractps extractps:)
(export hlt! Hlt hlt:)
(export idivb! Idivb idivb:)
(export idivl! Idivl idivl:)
(export idivq! Idivq idivq:)
(export idivw! Idivw idivw:)
(export imulb! Imulb imulb:)
(export imull! Imull imull:)
(export imull1! Imull1 imull1:)
(export imull2! Imull2 imull2:)
(export imulq! Imulq imulq:)
(export imulq1! Imulq1 imulq1:)
(export imulq2! Imulq2 imulq2:)
(export imulw! Imulw imulw:)
(export imulw1! Imulw1 imulw1:)
(export imulw2! Imulw2 imulw2:)
(export inb! Inb inb:)
(export incb! Incb incb:)
(export incl! Incl incl:)
(export incq! Incq incq:)
(export incw! Incw incw:)
(export inl! Inl inl:)
(export insertps! Insertps insertps:)
(export int! Int int:)
(export invd! Invd invd:)
(export invlpg! Invlpg invlpg:)
(export inw! Inw inw:)
(export iretl! Iretl iretl:)
(export iretq! Iretq iretq:)
(export iretw! Iretw iretw:)
(export ja! Ja ja:)
(export jae! Jae jae:)
(export jb! Jb jb:)
(export jbe! Jbe jbe:)
(export jc! Jc jc:)
(export je! Je je:)
(export jecxz! Jecxz jecxz:)
(export jg! Jg jg:)
(export jge! Jge jge:)
(export jl! Jl jl:)
(export jle! Jle jle:)
(export jmpq! Jmpq jmpq:)
(export jna! Jna jna:)
(export jnae! Jnae jnae:)
(export jnb! Jnb jnb:)
(export jnbe! Jnbe jnbe:)
(export jnc! Jnc jnc:)
(export jne! Jne jne:)
(export jng! Jng jng:)
(export jnge! Jnge jnge:)
(export jnl! Jnl jnl:)
(export jnle! Jnle jnle:)
(export jno! Jno jno:)
(export jnp! Jnp jnp:)
(export jns! Jns jns:)
(export jnz! Jnz jnz:)
(export jo! Jo jo:)
(export jp! Jp jp:)
(export jpe! Jpe jpe:)
(export jpo! Jpo jpo:)
(export jrcxz! Jrcxz jrcxz:)
(export js! Js js:)
(export jz! Jz jz:)
(export ldmxcsr! Ldmxcsr ldmxcsr:)
(export leal! Leal leal:)
(export leaq! Leaq leaq:)
(export leaveq! Leaveq leaveq:)
(export leavew! Leavew leavew:)
(export leaw! Leaw leaw:)
(export lfence! Lfence lfence:)
(export lmsw! Lmsw lmsw:)
(export lock! Lock lock:)
(export maskmovdqu! Maskmovdqu maskmovdqu:)
(export maxpd! Maxpd maxpd:)
(export maxps! Maxps maxps:)
(export maxsd! Maxsd maxsd:)
(export maxss! Maxss maxss:)
(export mfence! Mfence mfence:)
(export minpd! Minpd minpd:)
(export minps! Minps minps:)
(export minsd! Minsd minsd:)
(export minss! Minss minss:)
(export movapd! Movapd movapd:)
(export movaps! Movaps movaps:)
(export movb! Movb movb:)
(export movd! Movd movd:)
(export movdqa! Movdqa movdqa:)
(export movdqu! Movdqu movdqu:)
(export movhlps! Movhlps movhlps:)
(export movhpd! Movhpd movhpd:)
(export movhps! Movhps movhps:)
(export movl! Movl movl:)
(export movlhps! Movlhps movlhps:)
(export movlpd! Movlpd movlpd:)
(export movlps! Movlps movlps:)
(export movmskpd! Movmskpd movmskpd:)
(export movmskps! Movmskps movmskps:)
(export movntdq! Movntdq movntdq:)
(export movntdqa! Movntdqa movntdqa:)
(export movnti! Movnti movnti:)
(export movntpd! Movntpd movntpd:)
(export movntps! Movntps movntps:)
(export movq! Movq movq:)
(export movsbl! Movsbl movsbl:)
(export movsbq! Movsbq movsbq:)
(export movsbw! Movsbw movsbw:)
(export movsd! Movsd movsd:)
(export movsl! Movsl movsl:)
(export movslq! Movslq movslq:)
(export movss! Movss movss:)
(export movswl! Movswl movswl:)
(export movswq! Movswq movswq:)
(export movupd! Movupd movupd:)
(export movups! Movups movups:)
(export movw! Movw movw:)
(export movzbl! Movzbl movzbl:)
(export movzbq! Movzbq movzbq:)
(export movzbw! Movzbw movzbw:)
(export movzwl! Movzwl movzwl:)
(export movzwq! Movzwq movzwq:)
(export mpsadbw! Mpsadbw mpsadbw:)
(export mulb! Mulb mulb:)
(export mull! Mull mull:)
(export mulpd! Mulpd mulpd:)
(export mulps! Mulps mulps:)
(export mulq! Mulq mulq:)
(export mulsd! Mulsd mulsd:)
(export mulss! Mulss mulss:)
(export mulw! Mulw mulw:)
(export negb! Negb negb:)
(export negl! Negl negl:)
(export negq! Negq negq:)
(export negw! Negw negw:)
(export nop! Nop nop:)
(export notb! Notb notb:)
(export notl! Notl notl:)
(export notq! Notq notq:)
(export notw! Notw notw:)
(export orb! Orb orb:)
(export orl! Orl orl:)
(export orpd! Orpd orpd:)
(export orps! Orps orps:)
(export orq! Orq orq:)
(export orw! Orw orw:)
(export outb! Outb outb:)
(export outl! Outl outl:)
(export outw! Outw outw:)
(export packssdw! Packssdw packssdw:)
(export packsswb! Packsswb packsswb:)
(export packusdw! Packusdw packusdw:)
(export packuswb! Packuswb packuswb:)
(export paddb! Paddb paddb:)
(export paddd! Paddd paddd:)
(export paddq! Paddq paddq:)
(export paddsb! Paddsb paddsb:)
(export paddsw! Paddsw paddsw:)
(export paddusb! Paddusb paddusb:)
(export paddusw! Paddusw paddusw:)
(export paddw! Paddw paddw:)
(export pand! Pand pand:)
(export pandn! Pandn pandn:)
(export pause! Pause pause:)
(export pavgb! Pavgb pavgb:)
(export pavgw! Pavgw pavgw:)
(export pblendvb! Pblendvb pblendvb:)
(export pblendw! Pblendw pblendw:)
(export pcmpeqb! Pcmpeqb pcmpeqb:)
(export pcmpeqd! Pcmpeqd pcmpeqd:)
(export pcmpeqq! Pcmpeqq pcmpeqq:)
(export pcmpeqw! Pcmpeqw pcmpeqw:)
(export pcmpestri! Pcmpestri pcmpestri:)
(export pcmpestrm! Pcmpestrm pcmpestrm:)
(export pcmpgtb! Pcmpgtb pcmpgtb:)
(export pcmpgtd! Pcmpgtd pcmpgtd:)
(export pcmpgtq! Pcmpgtq pcmpgtq:)
(export pcmpgtw! Pcmpgtw pcmpgtw:)
(export pcmpistri! Pcmpistri pcmpistri:)
(export pcmpistrm! Pcmpistrm pcmpistrm:)
(export pextrb! Pextrb pextrb:)
(export pextrd! Pextrd pextrd:)
(export pextrq! Pextrq pextrq:)
(export pextrw! Pextrw pextrw:)
(export phminposuw! Phminposuw phminposuw:)
(export pinsrb! Pinsrb pinsrb:)
(export pinsrd! Pinsrd pinsrd:)
(export pinsrw! Pinsrw pinsrw:)
(export pmaddwd! Pmaddwd pmaddwd:)
(export pmaxsb! Pmaxsb pmaxsb:)
(export pmaxsd! Pmaxsd pmaxsd:)
(export pmaxsw! Pmaxsw pmaxsw:)
(export pmaxub! Pmaxub pmaxub:)
(export pmaxud! Pmaxud pmaxud:)
(export pmaxuw! Pmaxuw pmaxuw:)
(export pminsb! Pminsb pminsb:)
(export pminsd! Pminsd pminsd:)
(export pminsw! Pminsw pminsw:)
(export pminub! Pminub pminub:)
(export pminud! Pminud pminud:)
(export pminuw! Pminuw pminuw:)
(export pmovmskb! Pmovmskb pmovmskb:)
(export pmovsxbd! Pmovsxbd pmovsxbd:)
(export pmovsxbq! Pmovsxbq pmovsxbq:)
(export pmovsxbw! Pmovsxbw pmovsxbw:)
(export pmovsxdq! Pmovsxdq pmovsxdq:)
(export pmovsxwd! Pmovsxwd pmovsxwd:)
(export pmovsxwq! Pmovsxwq pmovsxwq:)
(export pmovzxbd! Pmovzxbd pmovzxbd:)
(export pmovzxbq! Pmovzxbq pmovzxbq:)
(export pmovzxbw! Pmovzxbw pmovzxbw:)
(export pmovzxdq! Pmovzxdq pmovzxdq:)
(export pmovzxwd! Pmovzxwd pmovzxwd:)
(export pmovzxwq! Pmovzxwq pmovzxwq:)
(export pmuldq! Pmuldq pmuldq:)
(export pmulhuw! Pmulhuw pmulhuw:)
(export pmulhw! Pmulhw pmulhw:)
(export pmulld! Pmulld pmulld:)
(export pmullw! Pmullw pmullw:)
(export pmuludq! Pmuludq pmuludq:)
(export popcntl! Popcntl popcntl:)
(export popcntq! Popcntq popcntq:)
(export popcntw! Popcntw popcntw:)
(export popfq! Popfq popfq:)
(export popfw! Popfw popfw:)
(export popq! Popq popq:)
(export popw! Popw popw:)
(export por! Por por:)
(export psadbw! Psadbw psadbw:)
(export pshufd! Pshufd pshufd:)
(export pshufhw! Pshufhw pshufhw:)
(export pshuflw! Pshuflw pshuflw:)
(export pslld! Pslld pslld:)
(export pslldq! Pslldq pslldq:)
(export psllq! Psllq psllq:)
(export psllw! Psllw psllw:)
(export psrad! Psrad psrad:)
(export psraw! Psraw psraw:)
(export psrld! Psrld psrld:)
(export psrldq! Psrldq psrldq:)
(export psrlq! Psrlq psrlq:)
(export psrlw! Psrlw psrlw:)
(export psubb! Psubb psubb:)
(export psubd! Psubd psubd:)
(export psubq! Psubq psubq:)
(export psubsb! Psubsb psubsb:)
(export psubsw! Psubsw psubsw:)
(export psubusb! Psubusb psubusb:)
(export psubusw! Psubusw psubusw:)
(export psubw! Psubw psubw:)
(export ptest! Ptest ptest:)
(export punpckhbw! Punpckhbw punpckhbw:)
(export punpckhdq! Punpckhdq punpckhdq:)
(export punpckhqdq! Punpckhqdq punpckhqdq:)
(export punpckhwd! Punpckhwd punpckhwd:)
(export punpcklbw! Punpcklbw punpcklbw:)
(export punpckldq! Punpckldq punpckldq:)
(export punpcklqdq! Punpcklqdq punpcklqdq:)
(export punpcklwd! Punpcklwd punpcklwd:)
(export pushfq! Pushfq pushfq:)
(export pushfw! Pushfw pushfw:)
(export pushq! Pushq pushq:)
(export pushw! Pushw pushw:)
(export pxor! Pxor pxor:)
(export rclb! Rclb rclb:)
(export rcll! Rcll rcll:)
(export rclq! Rclq rclq:)
(export rclw! Rclw rclw:)
(export rcpps! Rcpps rcpps:)
(export rcpss! Rcpss rcpss:)
(export rcrb! Rcrb rcrb:)
(export rcrl! Rcrl rcrl:)
(export rcrq! Rcrq rcrq:)
(export rcrw! Rcrw rcrw:)
(export retq! Retq retq:)
(export retq1! Retq1 retq1:)
(export rolb! Rolb rolb:)
(export roll! Roll roll:)
(export rolq! Rolq rolq:)
(export rolw! Rolw rolw:)
(export rorb! Rorb rorb:)
(export rorl! Rorl rorl:)
(export rorq! Rorq rorq:)
(export rorw! Rorw rorw:)
(export roundpd! Roundpd roundpd:)
(export roundps! Roundps roundps:)
(export roundsd! Roundsd roundsd:)
(export roundss! Roundss roundss:)
(export rsqrtps! Rsqrtps rsqrtps:)
(export rsqrtss! Rsqrtss rsqrtss:)
(export salb! Salb salb:)
(export sall! Sall sall:)
(export salq! Salq salq:)
(export salw! Salw salw:)
(export sarb! Sarb sarb:)
(export sarl! Sarl sarl:)
(export sarq! Sarq sarq:)
(export sarw! Sarw sarw:)
(export sbbb! Sbbb sbbb:)
(export sbbl! Sbbl sbbl:)
(export sbbq! Sbbq sbbq:)
(export sbbw! Sbbw sbbw:)
(export seta! Seta seta:)
(export setae! Setae setae:)
(export setb! Setb setb:)
(export setbe! Setbe setbe:)
(export setc! Setc setc:)
(export sete! Sete sete:)
(export setg! Setg setg:)
(export setge! Setge setge:)
(export setl! Setl setl:)
(export setle! Setle setle:)
(export setna! Setna setna:)
(export setnae! Setnae setnae:)
(export setnb! Setnb setnb:)
(export setnbe! Setnbe setnbe:)
(export setnc! Setnc setnc:)
(export setne! Setne setne:)
(export setng! Setng setng:)
(export setnge! Setnge setnge:)
(export setnl! Setnl setnl:)
(export setnle! Setnle setnle:)
(export setno! Setno setno:)
(export setnp! Setnp setnp:)
(export setns! Setns setns:)
(export setnz! Setnz setnz:)
(export seto! Seto seto:)
(export setp! Setp setp:)
(export setpe! Setpe setpe:)
(export setpo! Setpo setpo:)
(export sets! Sets sets:)
(export setz! Setz setz:)
(export sfence! Sfence sfence:)
(export sgdt! Sgdt sgdt:)
(export shlb! Shlb shlb:)
(export shldl! Shldl shldl:)
(export shldq! Shldq shldq:)
(export shldw! Shldw shldw:)
(export shll! Shll shll:)
(export shlq! Shlq shlq:)
(export shlw! Shlw shlw:)
(export shrb! Shrb shrb:)
(export shrdl! Shrdl shrdl:)
(export shrdq! Shrdq shrdq:)
(export shrdw! Shrdw shrdw:)
(export shrl! Shrl shrl:)
(export shrq! Shrq shrq:)
(export shrw! Shrw shrw:)
(export shufpd! Shufpd shufpd:)
(export shufps! Shufps shufps:)
(export sidt! Sidt sidt:)
(export sqrtpd! Sqrtpd sqrtpd:)
(export sqrtps! Sqrtps sqrtps:)
(export sqrtsd! Sqrtsd sqrtsd:)
(export sqrtss! Sqrtss sqrtss:)
(export stc! Stc stc:)
(export std! Std std:)
(export sti! Sti sti:)
(export stmxcsr! Stmxcsr stmxcsr:)
(export str! Str str:)
(export subb! Subb subb:)
(export subl! Subl subl:)
(export subpd! Subpd subpd:)
(export subps! Subps subps:)
(export subq! Subq subq:)
(export subsd! Subsd subsd:)
(export subss! Subss subss:)
(export subw! Subw subw:)
(export swapgs! Swapgs swapgs:)
(export testb! Testb testb:)
(export testl! Testl testl:)
(export testq! Testq testq:)
(export testw! Testw testw:)
(export ucomisd! Ucomisd ucomisd:)
(export ucomiss! Ucomiss ucomiss:)
(export ud2! Ud2 ud2:)
(export unpckhpd! Unpckhpd unpckhpd:)
(export unpckhps! Unpckhps unpckhps:)
(export unpcklpd! Unpcklpd unpcklpd:)
(export unpcklps! Unpcklps unpcklps:)
(export verr! Verr verr:)
(export verw! Verw verw:)
(export wbinvd! Wbinvd wbinvd:)
(export wrmsr! Wrmsr wrmsr:)
(export xaddb! Xaddb xaddb:)
(export xaddl! Xaddl xaddl:)
(export xaddq! Xaddq xaddq:)
(export xaddw! Xaddw xaddw:)
(export xchgb! Xchgb xchgb:)
(export xchgl! Xchgl xchgl:)
(export xchgq! Xchgq xchgq:)
(export xchgw! Xchgw xchgw:)
(export xorb! Xorb xorb:)
(export xorl! Xorl xorl:)
(export xorpd! Xorpd xorpd:)
(export xorps! Xorps xorps:)
(export xorq! Xorq xorq:)
(export xorw! Xorw xorw:)
(export xsetbv! Xsetbv xsetbv:)


(function (adcb! w op0 op1) (write-inst! w (adcb: op0 op1)))
(function (adcl! w op0 op1) (write-inst! w (adcl: op0 op1)))
(function (adcq! w op0 op1) (write-inst! w (adcq: op0 op1)))
(function (adcw! w op0 op1) (write-inst! w (adcw: op0 op1)))
(function (addb! w op0 op1) (write-inst! w (addb: op0 op1)))
(function (addl! w op0 op1) (write-inst! w (addl: op0 op1)))
(function (addpd! w op0 op1) (write-inst! w (addpd: op0 op1)))
(function (addps! w op0 op1) (write-inst! w (addps: op0 op1)))
(function (addq! w op0 op1) (write-inst! w (addq: op0 op1)))
(function (addsd! w op0 op1) (write-inst! w (addsd: op0 op1)))
(function (addss! w op0 op1) (write-inst! w (addss: op0 op1)))
(function (addw! w op0 op1) (write-inst! w (addw: op0 op1)))
(function (andb! w op0 op1) (write-inst! w (andb: op0 op1)))
(function (andl! w op0 op1) (write-inst! w (andl: op0 op1)))
(function (andnpd! w op0 op1) (write-inst! w (andnpd: op0 op1)))
(function (andnps! w op0 op1) (write-inst! w (andnps: op0 op1)))
(function (andpd! w op0 op1) (write-inst! w (andpd: op0 op1)))
(function (andps! w op0 op1) (write-inst! w (andps: op0 op1)))
(function (andq! w op0 op1) (write-inst! w (andq: op0 op1)))
(function (andw! w op0 op1) (write-inst! w (andw: op0 op1)))
(function (blendpd! w op0 op1 op2) (write-inst! w (blendpd: op0 op1 op2)))
(function (blendps! w op0 op1 op2) (write-inst! w (blendps: op0 op1 op2)))
(function (blendvpd! w op0 op1 op2) (write-inst! w (blendvpd: op0 op1 op2)))
(function (blendvps! w op0 op1 op2) (write-inst! w (blendvps: op0 op1 op2)))
(function (bsfl! w op0 op1) (write-inst! w (bsfl: op0 op1)))
(function (bsfq! w op0 op1) (write-inst! w (bsfq: op0 op1)))
(function (bsfw! w op0 op1) (write-inst! w (bsfw: op0 op1)))
(function (bsrl! w op0 op1) (write-inst! w (bsrl: op0 op1)))
(function (bsrq! w op0 op1) (write-inst! w (bsrq: op0 op1)))
(function (bsrw! w op0 op1) (write-inst! w (bsrw: op0 op1)))
(function (bswap! w op0) (write-inst! w (bswap: op0)))
(function (btcl! w op0 op1) (write-inst! w (btcl: op0 op1)))
(function (btcq! w op0 op1) (write-inst! w (btcq: op0 op1)))
(function (btcw! w op0 op1) (write-inst! w (btcw: op0 op1)))
(function (btl! w op0 op1) (write-inst! w (btl: op0 op1)))
(function (btq! w op0 op1) (write-inst! w (btq: op0 op1)))
(function (btrl! w op0 op1) (write-inst! w (btrl: op0 op1)))
(function (btrq! w op0 op1) (write-inst! w (btrq: op0 op1)))
(function (btrw! w op0 op1) (write-inst! w (btrw: op0 op1)))
(function (btsl! w op0 op1) (write-inst! w (btsl: op0 op1)))
(function (btsq! w op0 op1) (write-inst! w (btsq: op0 op1)))
(function (btsw! w op0 op1) (write-inst! w (btsw: op0 op1)))
(function (btw! w op0 op1) (write-inst! w (btw: op0 op1)))
(function (callq! w op0) (write-inst! w (callq: op0)))
(function (cbtw! w) (write-inst! w cbtw:))
(function (clc! w) (write-inst! w clc:))
(function (cld! w) (write-inst! w cld:))
(function (cli! w) (write-inst! w cli:))
(function (cltd! w) (write-inst! w cltd:))
(function (cltq! w) (write-inst! w cltq:))
(function (clts! w) (write-inst! w clts:))
(function (cmc! w) (write-inst! w cmc:))
(function (cmpb! w op0 op1) (write-inst! w (cmpb: op0 op1)))
(function (cmpl! w op0 op1) (write-inst! w (cmpl: op0 op1)))
(function (cmppd! w op0 op1 op2) (write-inst! w (cmppd: op0 op1 op2)))
(function (cmpps! w op0 op1 op2) (write-inst! w (cmpps: op0 op1 op2)))
(function (cmpq! w op0 op1) (write-inst! w (cmpq: op0 op1)))
(function (cmpsd! w op0 op1 op2) (write-inst! w (cmpsd: op0 op1 op2)))
(function (cmpsl! w) (write-inst! w cmpsl:))
(function (cmpss! w op0 op1 op2) (write-inst! w (cmpss: op0 op1 op2)))
(function (cmpw! w op0 op1) (write-inst! w (cmpw: op0 op1)))
(function (cmpxchgb! w op0 op1) (write-inst! w (cmpxchgb: op0 op1)))
(function (cmpxchgl! w op0 op1) (write-inst! w (cmpxchgl: op0 op1)))
(function (cmpxchgq! w op0 op1) (write-inst! w (cmpxchgq: op0 op1)))
(function (cmpxchgw! w op0 op1) (write-inst! w (cmpxchgw: op0 op1)))
(function (comisd! w op0 op1) (write-inst! w (comisd: op0 op1)))
(function (comiss! w op0 op1) (write-inst! w (comiss: op0 op1)))
(function (cpuid! w) (write-inst! w cpuid:))
(function (cqto! w) (write-inst! w cqto:))
(function (crc32b! w op0 op1) (write-inst! w (crc32b: op0 op1)))
(function (crc32l! w op0 op1) (write-inst! w (crc32l: op0 op1)))
(function (crc32q! w op0 op1) (write-inst! w (crc32q: op0 op1)))
(function (crc32w! w op0 op1) (write-inst! w (crc32w: op0 op1)))
(function (cvtdq2pd! w op0 op1) (write-inst! w (cvtdq2pd: op0 op1)))
(function (cvtdq2ps! w op0 op1) (write-inst! w (cvtdq2ps: op0 op1)))
(function (cvtpd2dq! w op0 op1) (write-inst! w (cvtpd2dq: op0 op1)))
(function (cvtpd2ps! w op0 op1) (write-inst! w (cvtpd2ps: op0 op1)))
(function (cvtps2dq! w op0 op1) (write-inst! w (cvtps2dq: op0 op1)))
(function (cvtps2pd! w op0 op1) (write-inst! w (cvtps2pd: op0 op1)))
(function (cvtsd2si! w op0 op1) (write-inst! w (cvtsd2si: op0 op1)))
(function (cvtsd2ss! w op0 op1) (write-inst! w (cvtsd2ss: op0 op1)))
(function (cvtsi2sdl! w op0 op1) (write-inst! w (cvtsi2sdl: op0 op1)))
(function (cvtsi2sdq! w op0 op1) (write-inst! w (cvtsi2sdq: op0 op1)))
(function (cvtsi2ssl! w op0 op1) (write-inst! w (cvtsi2ssl: op0 op1)))
(function (cvtsi2ssq! w op0 op1) (write-inst! w (cvtsi2ssq: op0 op1)))
(function (cvtss2sd! w op0 op1) (write-inst! w (cvtss2sd: op0 op1)))
(function (cvtss2si! w op0 op1) (write-inst! w (cvtss2si: op0 op1)))
(function (cvttpd2dq! w op0 op1) (write-inst! w (cvttpd2dq: op0 op1)))
(function (cvttps2dq! w op0 op1) (write-inst! w (cvttps2dq: op0 op1)))
(function (cvttsd2si! w op0 op1) (write-inst! w (cvttsd2si: op0 op1)))
(function (cvttss2si! w op0 op1) (write-inst! w (cvttss2si: op0 op1)))
(function (cwtd! w) (write-inst! w cwtd:))
(function (cwtl! w) (write-inst! w cwtl:))
(function (decb! w op0) (write-inst! w (decb: op0)))
(function (decl! w op0) (write-inst! w (decl: op0)))
(function (decq! w op0) (write-inst! w (decq: op0)))
(function (decw! w op0) (write-inst! w (decw: op0)))
(function (divb! w op0) (write-inst! w (divb: op0)))
(function (divl! w op0) (write-inst! w (divl: op0)))
(function (divpd! w op0 op1) (write-inst! w (divpd: op0 op1)))
(function (divps! w op0 op1) (write-inst! w (divps: op0 op1)))
(function (divq! w op0) (write-inst! w (divq: op0)))
(function (divsd! w op0 op1) (write-inst! w (divsd: op0 op1)))
(function (divss! w op0 op1) (write-inst! w (divss: op0 op1)))
(function (divw! w op0) (write-inst! w (divw: op0)))
(function (dppd! w op0 op1 op2) (write-inst! w (dppd: op0 op1 op2)))
(function (dpps! w op0 op1 op2) (write-inst! w (dpps: op0 op1 op2)))
(function (emms! w) (write-inst! w emms:))
(function (extractps! w op0 op1 op2) (write-inst! w (extractps: op0 op1 op2)))
(function (hlt! w) (write-inst! w hlt:))
(function (idivb! w op0) (write-inst! w (idivb: op0)))
(function (idivl! w op0) (write-inst! w (idivl: op0)))
(function (idivq! w op0) (write-inst! w (idivq: op0)))
(function (idivw! w op0) (write-inst! w (idivw: op0)))
(function (imulb! w op0) (write-inst! w (imulb: op0)))
(function (imull! w op0 op1 op2) (write-inst! w (imull: op0 op1 op2)))
(function (imull1! w op0) (write-inst! w (imull1: op0)))
(function (imull2! w op0 op1) (write-inst! w (imull2: op0 op1)))
(function (imulq! w op0 op1 op2) (write-inst! w (imulq: op0 op1 op2)))
(function (imulq1! w op0) (write-inst! w (imulq1: op0)))
(function (imulq2! w op0 op1) (write-inst! w (imulq2: op0 op1)))
(function (imulw! w op0 op1 op2) (write-inst! w (imulw: op0 op1 op2)))
(function (imulw1! w op0) (write-inst! w (imulw1: op0)))
(function (imulw2! w op0 op1) (write-inst! w (imulw2: op0 op1)))
(function (inb! w op0 op1) (write-inst! w (inb: op0 op1)))
(function (incb! w op0) (write-inst! w (incb: op0)))
(function (incl! w op0) (write-inst! w (incl: op0)))
(function (incq! w op0) (write-inst! w (incq: op0)))
(function (incw! w op0) (write-inst! w (incw: op0)))
(function (inl! w op0 op1) (write-inst! w (inl: op0 op1)))
(function (insertps! w op0 op1 op2) (write-inst! w (insertps: op0 op1 op2)))
(function (int! w op0) (write-inst! w (int: op0)))
(function (invd! w) (write-inst! w invd:))
(function (invlpg! w op0) (write-inst! w (invlpg: op0)))
(function (inw! w op0 op1) (write-inst! w (inw: op0 op1)))
(function (iretl! w) (write-inst! w iretl:))
(function (iretq! w) (write-inst! w iretq:))
(function (iretw! w) (write-inst! w iretw:))
(function (ja! w op0) (write-inst! w (ja: op0)))
(function (jae! w op0) (write-inst! w (jae: op0)))
(function (jb! w op0) (write-inst! w (jb: op0)))
(function (jbe! w op0) (write-inst! w (jbe: op0)))
(function (jc! w op0) (write-inst! w (jc: op0)))
(function (je! w op0) (write-inst! w (je: op0)))
(function (jecxz! w op0) (write-inst! w (jecxz: op0)))
(function (jg! w op0) (write-inst! w (jg: op0)))
(function (jge! w op0) (write-inst! w (jge: op0)))
(function (jl! w op0) (write-inst! w (jl: op0)))
(function (jle! w op0) (write-inst! w (jle: op0)))
(function (jmpq! w op0) (write-inst! w (jmpq: op0)))
(function (jna! w op0) (write-inst! w (jna: op0)))
(function (jnae! w op0) (write-inst! w (jnae: op0)))
(function (jnb! w op0) (write-inst! w (jnb: op0)))
(function (jnbe! w op0) (write-inst! w (jnbe: op0)))
(function (jnc! w op0) (write-inst! w (jnc: op0)))
(function (jne! w op0) (write-inst! w (jne: op0)))
(function (jng! w op0) (write-inst! w (jng: op0)))
(function (jnge! w op0) (write-inst! w (jnge: op0)))
(function (jnl! w op0) (write-inst! w (jnl: op0)))
(function (jnle! w op0) (write-inst! w (jnle: op0)))
(function (jno! w op0) (write-inst! w (jno: op0)))
(function (jnp! w op0) (write-inst! w (jnp: op0)))
(function (jns! w op0) (write-inst! w (jns: op0)))
(function (jnz! w op0) (write-inst! w (jnz: op0)))
(function (jo! w op0) (write-inst! w (jo: op0)))
(function (jp! w op0) (write-inst! w (jp: op0)))
(function (jpe! w op0) (write-inst! w (jpe: op0)))
(function (jpo! w op0) (write-inst! w (jpo: op0)))
(function (jrcxz! w op0) (write-inst! w (jrcxz: op0)))
(function (js! w op0) (write-inst! w (js: op0)))
(function (jz! w op0) (write-inst! w (jz: op0)))
(function (ldmxcsr! w op0) (write-inst! w (ldmxcsr: op0)))
(function (leal! w op0 op1) (write-inst! w (leal: op0 op1)))
(function (leaq! w op0 op1) (write-inst! w (leaq: op0 op1)))
(function (leaveq! w) (write-inst! w leaveq:))
(function (leavew! w) (write-inst! w leavew:))
(function (leaw! w op0 op1) (write-inst! w (leaw: op0 op1)))
(function (lfence! w) (write-inst! w lfence:))
(function (lmsw! w op0) (write-inst! w (lmsw: op0)))
(function (lock! w) (write-inst! w lock:))
(function (maskmovdqu! w op0 op1) (write-inst! w (maskmovdqu: op0 op1)))
(function (maxpd! w op0 op1) (write-inst! w (maxpd: op0 op1)))
(function (maxps! w op0 op1) (write-inst! w (maxps: op0 op1)))
(function (maxsd! w op0 op1) (write-inst! w (maxsd: op0 op1)))
(function (maxss! w op0 op1) (write-inst! w (maxss: op0 op1)))
(function (mfence! w) (write-inst! w mfence:))
(function (minpd! w op0 op1) (write-inst! w (minpd: op0 op1)))
(function (minps! w op0 op1) (write-inst! w (minps: op0 op1)))
(function (minsd! w op0 op1) (write-inst! w (minsd: op0 op1)))
(function (minss! w op0 op1) (write-inst! w (minss: op0 op1)))
(function (movapd! w op0 op1) (write-inst! w (movapd: op0 op1)))
(function (movaps! w op0 op1) (write-inst! w (movaps: op0 op1)))
(function (movb! w op0 op1) (write-inst! w (movb: op0 op1)))
(function (movd! w op0 op1) (write-inst! w (movd: op0 op1)))
(function (movdqa! w op0 op1) (write-inst! w (movdqa: op0 op1)))
(function (movdqu! w op0 op1) (write-inst! w (movdqu: op0 op1)))
(function (movhlps! w op0 op1) (write-inst! w (movhlps: op0 op1)))
(function (movhpd! w op0 op1) (write-inst! w (movhpd: op0 op1)))
(function (movhps! w op0 op1) (write-inst! w (movhps: op0 op1)))
(function (movl! w op0 op1) (write-inst! w (movl: op0 op1)))
(function (movlhps! w op0 op1) (write-inst! w (movlhps: op0 op1)))
(function (movlpd! w op0 op1) (write-inst! w (movlpd: op0 op1)))
(function (movlps! w op0 op1) (write-inst! w (movlps: op0 op1)))
(function (movmskpd! w op0 op1) (write-inst! w (movmskpd: op0 op1)))
(function (movmskps! w op0 op1) (write-inst! w (movmskps: op0 op1)))
(function (movntdq! w op0 op1) (write-inst! w (movntdq: op0 op1)))
(function (movntdqa! w op0 op1) (write-inst! w (movntdqa: op0 op1)))
(function (movnti! w op0 op1) (write-inst! w (movnti: op0 op1)))
(function (movntpd! w op0 op1) (write-inst! w (movntpd: op0 op1)))
(function (movntps! w op0 op1) (write-inst! w (movntps: op0 op1)))
(function (movq! w op0 op1) (write-inst! w (movq: op0 op1)))
(function (movsbl! w op0 op1) (write-inst! w (movsbl: op0 op1)))
(function (movsbq! w op0 op1) (write-inst! w (movsbq: op0 op1)))
(function (movsbw! w op0 op1) (write-inst! w (movsbw: op0 op1)))
(function (movsd! w op0 op1) (write-inst! w (movsd: op0 op1)))
(function (movsl! w) (write-inst! w movsl:))
(function (movslq! w op0 op1) (write-inst! w (movslq: op0 op1)))
(function (movss! w op0 op1) (write-inst! w (movss: op0 op1)))
(function (movswl! w op0 op1) (write-inst! w (movswl: op0 op1)))
(function (movswq! w op0 op1) (write-inst! w (movswq: op0 op1)))
(function (movupd! w op0 op1) (write-inst! w (movupd: op0 op1)))
(function (movups! w op0 op1) (write-inst! w (movups: op0 op1)))
(function (movw! w op0 op1) (write-inst! w (movw: op0 op1)))
(function (movzbl! w op0 op1) (write-inst! w (movzbl: op0 op1)))
(function (movzbq! w op0 op1) (write-inst! w (movzbq: op0 op1)))
(function (movzbw! w op0 op1) (write-inst! w (movzbw: op0 op1)))
(function (movzwl! w op0 op1) (write-inst! w (movzwl: op0 op1)))
(function (movzwq! w op0 op1) (write-inst! w (movzwq: op0 op1)))
(function (mpsadbw! w op0 op1 op2) (write-inst! w (mpsadbw: op0 op1 op2)))
(function (mulb! w op0) (write-inst! w (mulb: op0)))
(function (mull! w op0) (write-inst! w (mull: op0)))
(function (mulpd! w op0 op1) (write-inst! w (mulpd: op0 op1)))
(function (mulps! w op0 op1) (write-inst! w (mulps: op0 op1)))
(function (mulq! w op0) (write-inst! w (mulq: op0)))
(function (mulsd! w op0 op1) (write-inst! w (mulsd: op0 op1)))
(function (mulss! w op0 op1) (write-inst! w (mulss: op0 op1)))
(function (mulw! w op0) (write-inst! w (mulw: op0)))
(function (negb! w op0) (write-inst! w (negb: op0)))
(function (negl! w op0) (write-inst! w (negl: op0)))
(function (negq! w op0) (write-inst! w (negq: op0)))
(function (negw! w op0) (write-inst! w (negw: op0)))
(function (nop! w) (write-inst! w nop:))
(function (notb! w op0) (write-inst! w (notb: op0)))
(function (notl! w op0) (write-inst! w (notl: op0)))
(function (notq! w op0) (write-inst! w (notq: op0)))
(function (notw! w op0) (write-inst! w (notw: op0)))
(function (orb! w op0 op1) (write-inst! w (orb: op0 op1)))
(function (orl! w op0 op1) (write-inst! w (orl: op0 op1)))
(function (orpd! w op0 op1) (write-inst! w (orpd: op0 op1)))
(function (orps! w op0 op1) (write-inst! w (orps: op0 op1)))
(function (orq! w op0 op1) (write-inst! w (orq: op0 op1)))
(function (orw! w op0 op1) (write-inst! w (orw: op0 op1)))
(function (outb! w op0 op1) (write-inst! w (outb: op0 op1)))
(function (outl! w op0 op1) (write-inst! w (outl: op0 op1)))
(function (outw! w op0 op1) (write-inst! w (outw: op0 op1)))
(function (packssdw! w op0 op1) (write-inst! w (packssdw: op0 op1)))
(function (packsswb! w op0 op1) (write-inst! w (packsswb: op0 op1)))
(function (packusdw! w op0 op1) (write-inst! w (packusdw: op0 op1)))
(function (packuswb! w op0 op1) (write-inst! w (packuswb: op0 op1)))
(function (paddb! w op0 op1) (write-inst! w (paddb: op0 op1)))
(function (paddd! w op0 op1) (write-inst! w (paddd: op0 op1)))
(function (paddq! w op0 op1) (write-inst! w (paddq: op0 op1)))
(function (paddsb! w op0 op1) (write-inst! w (paddsb: op0 op1)))
(function (paddsw! w op0 op1) (write-inst! w (paddsw: op0 op1)))
(function (paddusb! w op0 op1) (write-inst! w (paddusb: op0 op1)))
(function (paddusw! w op0 op1) (write-inst! w (paddusw: op0 op1)))
(function (paddw! w op0 op1) (write-inst! w (paddw: op0 op1)))
(function (pand! w op0 op1) (write-inst! w (pand: op0 op1)))
(function (pandn! w op0 op1) (write-inst! w (pandn: op0 op1)))
(function (pause! w) (write-inst! w pause:))
(function (pavgb! w op0 op1) (write-inst! w (pavgb: op0 op1)))
(function (pavgw! w op0 op1) (write-inst! w (pavgw: op0 op1)))
(function (pblendvb! w op0 op1 op2) (write-inst! w (pblendvb: op0 op1 op2)))
(function (pblendw! w op0 op1 op2) (write-inst! w (pblendw: op0 op1 op2)))
(function (pcmpeqb! w op0 op1) (write-inst! w (pcmpeqb: op0 op1)))
(function (pcmpeqd! w op0 op1) (write-inst! w (pcmpeqd: op0 op1)))
(function (pcmpeqq! w op0 op1) (write-inst! w (pcmpeqq: op0 op1)))
(function (pcmpeqw! w op0 op1) (write-inst! w (pcmpeqw: op0 op1)))
(function (pcmpestri! w op0 op1 op2) (write-inst! w (pcmpestri: op0 op1 op2)))
(function (pcmpestrm! w op0 op1 op2) (write-inst! w (pcmpestrm: op0 op1 op2)))
(function (pcmpgtb! w op0 op1) (write-inst! w (pcmpgtb: op0 op1)))
(function (pcmpgtd! w op0 op1) (write-inst! w (pcmpgtd: op0 op1)))
(function (pcmpgtq! w op0 op1) (write-inst! w (pcmpgtq: op0 op1)))
(function (pcmpgtw! w op0 op1) (write-inst! w (pcmpgtw: op0 op1)))
(function (pcmpistri! w op0 op1 op2) (write-inst! w (pcmpistri: op0 op1 op2)))
(function (pcmpistrm! w op0 op1 op2) (write-inst! w (pcmpistrm: op0 op1 op2)))
(function (pextrb! w op0 op1 op2) (write-inst! w (pextrb: op0 op1 op2)))
(function (pextrd! w op0 op1 op2) (write-inst! w (pextrd: op0 op1 op2)))
(function (pextrq! w op0 op1 op2) (write-inst! w (pextrq: op0 op1 op2)))
(function (pextrw! w op0 op1 op2) (write-inst! w (pextrw: op0 op1 op2)))
(function (phminposuw! w op0 op1) (write-inst! w (phminposuw: op0 op1)))
(function (pinsrb! w op0 op1 op2) (write-inst! w (pinsrb: op0 op1 op2)))
(function (pinsrd! w op0 op1 op2) (write-inst! w (pinsrd: op0 op1 op2)))
(function (pinsrw! w op0 op1 op2) (write-inst! w (pinsrw: op0 op1 op2)))
(function (pmaddwd! w op0 op1) (write-inst! w (pmaddwd: op0 op1)))
(function (pmaxsb! w op0 op1) (write-inst! w (pmaxsb: op0 op1)))
(function (pmaxsd! w op0 op1) (write-inst! w (pmaxsd: op0 op1)))
(function (pmaxsw! w op0 op1) (write-inst! w (pmaxsw: op0 op1)))
(function (pmaxub! w op0 op1) (write-inst! w (pmaxub: op0 op1)))
(function (pmaxud! w op0 op1) (write-inst! w (pmaxud: op0 op1)))
(function (pmaxuw! w op0 op1) (write-inst! w (pmaxuw: op0 op1)))
(function (pminsb! w op0 op1) (write-inst! w (pminsb: op0 op1)))
(function (pminsd! w op0 op1) (write-inst! w (pminsd: op0 op1)))
(function (pminsw! w op0 op1) (write-inst! w (pminsw: op0 op1)))
(function (pminub! w op0 op1) (write-inst! w (pminub: op0 op1)))
(function (pminud! w op0 op1) (write-inst! w (pminud: op0 op1)))
(function (pminuw! w op0 op1) (write-inst! w (pminuw: op0 op1)))
(function (pmovmskb! w op0 op1) (write-inst! w (pmovmskb: op0 op1)))
(function (pmovsxbd! w op0 op1) (write-inst! w (pmovsxbd: op0 op1)))
(function (pmovsxbq! w op0 op1) (write-inst! w (pmovsxbq: op0 op1)))
(function (pmovsxbw! w op0 op1) (write-inst! w (pmovsxbw: op0 op1)))
(function (pmovsxdq! w op0 op1) (write-inst! w (pmovsxdq: op0 op1)))
(function (pmovsxwd! w op0 op1) (write-inst! w (pmovsxwd: op0 op1)))
(function (pmovsxwq! w op0 op1) (write-inst! w (pmovsxwq: op0 op1)))
(function (pmovzxbd! w op0 op1) (write-inst! w (pmovzxbd: op0 op1)))
(function (pmovzxbq! w op0 op1) (write-inst! w (pmovzxbq: op0 op1)))
(function (pmovzxbw! w op0 op1) (write-inst! w (pmovzxbw: op0 op1)))
(function (pmovzxdq! w op0 op1) (write-inst! w (pmovzxdq: op0 op1)))
(function (pmovzxwd! w op0 op1) (write-inst! w (pmovzxwd: op0 op1)))
(function (pmovzxwq! w op0 op1) (write-inst! w (pmovzxwq: op0 op1)))
(function (pmuldq! w op0 op1) (write-inst! w (pmuldq: op0 op1)))
(function (pmulhuw! w op0 op1) (write-inst! w (pmulhuw: op0 op1)))
(function (pmulhw! w op0 op1) (write-inst! w (pmulhw: op0 op1)))
(function (pmulld! w op0 op1) (write-inst! w (pmulld: op0 op1)))
(function (pmullw! w op0 op1) (write-inst! w (pmullw: op0 op1)))
(function (pmuludq! w op0 op1) (write-inst! w (pmuludq: op0 op1)))
(function (popcntl! w op0 op1) (write-inst! w (popcntl: op0 op1)))
(function (popcntq! w op0 op1) (write-inst! w (popcntq: op0 op1)))
(function (popcntw! w op0 op1) (write-inst! w (popcntw: op0 op1)))
(function (popfq! w) (write-inst! w popfq:))
(function (popfw! w) (write-inst! w popfw:))
(function (popq! w op0) (write-inst! w (popq: op0)))
(function (popw! w op0) (write-inst! w (popw: op0)))
(function (por! w op0 op1) (write-inst! w (por: op0 op1)))
(function (psadbw! w op0 op1) (write-inst! w (psadbw: op0 op1)))
(function (pshufd! w op0 op1 op2) (write-inst! w (pshufd: op0 op1 op2)))
(function (pshufhw! w op0 op1 op2) (write-inst! w (pshufhw: op0 op1 op2)))
(function (pshuflw! w op0 op1 op2) (write-inst! w (pshuflw: op0 op1 op2)))
(function (pslld! w op0 op1) (write-inst! w (pslld: op0 op1)))
(function (pslldq! w op0 op1) (write-inst! w (pslldq: op0 op1)))
(function (psllq! w op0 op1) (write-inst! w (psllq: op0 op1)))
(function (psllw! w op0 op1) (write-inst! w (psllw: op0 op1)))
(function (psrad! w op0 op1) (write-inst! w (psrad: op0 op1)))
(function (psraw! w op0 op1) (write-inst! w (psraw: op0 op1)))
(function (psrld! w op0 op1) (write-inst! w (psrld: op0 op1)))
(function (psrldq! w op0 op1) (write-inst! w (psrldq: op0 op1)))
(function (psrlq! w op0 op1) (write-inst! w (psrlq: op0 op1)))
(function (psrlw! w op0 op1) (write-inst! w (psrlw: op0 op1)))
(function (psubb! w op0 op1) (write-inst! w (psubb: op0 op1)))
(function (psubd! w op0 op1) (write-inst! w (psubd: op0 op1)))
(function (psubq! w op0 op1) (write-inst! w (psubq: op0 op1)))
(function (psubsb! w op0 op1) (write-inst! w (psubsb: op0 op1)))
(function (psubsw! w op0 op1) (write-inst! w (psubsw: op0 op1)))
(function (psubusb! w op0 op1) (write-inst! w (psubusb: op0 op1)))
(function (psubusw! w op0 op1) (write-inst! w (psubusw: op0 op1)))
(function (psubw! w op0 op1) (write-inst! w (psubw: op0 op1)))
(function (ptest! w op0 op1) (write-inst! w (ptest: op0 op1)))
(function (punpckhbw! w op0 op1) (write-inst! w (punpckhbw: op0 op1)))
(function (punpckhdq! w op0 op1) (write-inst! w (punpckhdq: op0 op1)))
(function (punpckhqdq! w op0 op1) (write-inst! w (punpckhqdq: op0 op1)))
(function (punpckhwd! w op0 op1) (write-inst! w (punpckhwd: op0 op1)))
(function (punpcklbw! w op0 op1) (write-inst! w (punpcklbw: op0 op1)))
(function (punpckldq! w op0 op1) (write-inst! w (punpckldq: op0 op1)))
(function (punpcklqdq! w op0 op1) (write-inst! w (punpcklqdq: op0 op1)))
(function (punpcklwd! w op0 op1) (write-inst! w (punpcklwd: op0 op1)))
(function (pushfq! w) (write-inst! w pushfq:))
(function (pushfw! w) (write-inst! w pushfw:))
(function (pushq! w op0) (write-inst! w (pushq: op0)))
(function (pushw! w op0) (write-inst! w (pushw: op0)))
(function (pxor! w op0 op1) (write-inst! w (pxor: op0 op1)))
(function (rclb! w op0 op1) (write-inst! w (rclb: op0 op1)))
(function (rcll! w op0 op1) (write-inst! w (rcll: op0 op1)))
(function (rclq! w op0 op1) (write-inst! w (rclq: op0 op1)))
(function (rclw! w op0 op1) (write-inst! w (rclw: op0 op1)))
(function (rcpps! w op0 op1) (write-inst! w (rcpps: op0 op1)))
(function (rcpss! w op0 op1) (write-inst! w (rcpss: op0 op1)))
(function (rcrb! w op0 op1) (write-inst! w (rcrb: op0 op1)))
(function (rcrl! w op0 op1) (write-inst! w (rcrl: op0 op1)))
(function (rcrq! w op0 op1) (write-inst! w (rcrq: op0 op1)))
(function (rcrw! w op0 op1) (write-inst! w (rcrw: op0 op1)))
(function (retq! w) (write-inst! w retq:))
(function (retq1! w op0) (write-inst! w (retq1: op0)))
(function (rolb! w op0 op1) (write-inst! w (rolb: op0 op1)))
(function (roll! w op0 op1) (write-inst! w (roll: op0 op1)))
(function (rolq! w op0 op1) (write-inst! w (rolq: op0 op1)))
(function (rolw! w op0 op1) (write-inst! w (rolw: op0 op1)))
(function (rorb! w op0 op1) (write-inst! w (rorb: op0 op1)))
(function (rorl! w op0 op1) (write-inst! w (rorl: op0 op1)))
(function (rorq! w op0 op1) (write-inst! w (rorq: op0 op1)))
(function (rorw! w op0 op1) (write-inst! w (rorw: op0 op1)))
(function (roundpd! w op0 op1 op2) (write-inst! w (roundpd: op0 op1 op2)))
(function (roundps! w op0 op1 op2) (write-inst! w (roundps: op0 op1 op2)))
(function (roundsd! w op0 op1 op2) (write-inst! w (roundsd: op0 op1 op2)))
(function (roundss! w op0 op1 op2) (write-inst! w (roundss: op0 op1 op2)))
(function (rsqrtps! w op0 op1) (write-inst! w (rsqrtps: op0 op1)))
(function (rsqrtss! w op0 op1) (write-inst! w (rsqrtss: op0 op1)))
(function (salb! w op0 op1) (write-inst! w (salb: op0 op1)))
(function (sall! w op0 op1) (write-inst! w (sall: op0 op1)))
(function (salq! w op0 op1) (write-inst! w (salq: op0 op1)))
(function (salw! w op0 op1) (write-inst! w (salw: op0 op1)))
(function (sarb! w op0 op1) (write-inst! w (sarb: op0 op1)))
(function (sarl! w op0 op1) (write-inst! w (sarl: op0 op1)))
(function (sarq! w op0 op1) (write-inst! w (sarq: op0 op1)))
(function (sarw! w op0 op1) (write-inst! w (sarw: op0 op1)))
(function (sbbb! w op0 op1) (write-inst! w (sbbb: op0 op1)))
(function (sbbl! w op0 op1) (write-inst! w (sbbl: op0 op1)))
(function (sbbq! w op0 op1) (write-inst! w (sbbq: op0 op1)))
(function (sbbw! w op0 op1) (write-inst! w (sbbw: op0 op1)))
(function (seta! w op0) (write-inst! w (seta: op0)))
(function (setae! w op0) (write-inst! w (setae: op0)))
(function (setb! w op0) (write-inst! w (setb: op0)))
(function (setbe! w op0) (write-inst! w (setbe: op0)))
(function (setc! w op0) (write-inst! w (setc: op0)))
(function (sete! w op0) (write-inst! w (sete: op0)))
(function (setg! w op0) (write-inst! w (setg: op0)))
(function (setge! w op0) (write-inst! w (setge: op0)))
(function (setl! w op0) (write-inst! w (setl: op0)))
(function (setle! w op0) (write-inst! w (setle: op0)))
(function (setna! w op0) (write-inst! w (setna: op0)))
(function (setnae! w op0) (write-inst! w (setnae: op0)))
(function (setnb! w op0) (write-inst! w (setnb: op0)))
(function (setnbe! w op0) (write-inst! w (setnbe: op0)))
(function (setnc! w op0) (write-inst! w (setnc: op0)))
(function (setne! w op0) (write-inst! w (setne: op0)))
(function (setng! w op0) (write-inst! w (setng: op0)))
(function (setnge! w op0) (write-inst! w (setnge: op0)))
(function (setnl! w op0) (write-inst! w (setnl: op0)))
(function (setnle! w op0) (write-inst! w (setnle: op0)))
(function (setno! w op0) (write-inst! w (setno: op0)))
(function (setnp! w op0) (write-inst! w (setnp: op0)))
(function (setns! w op0) (write-inst! w (setns: op0)))
(function (setnz! w op0) (write-inst! w (setnz: op0)))
(function (seto! w op0) (write-inst! w (seto: op0)))
(function (setp! w op0) (write-inst! w (setp: op0)))
(function (setpe! w op0) (write-inst! w (setpe: op0)))
(function (setpo! w op0) (write-inst! w (setpo: op0)))
(function (sets! w op0) (write-inst! w (sets: op0)))
(function (setz! w op0) (write-inst! w (setz: op0)))
(function (sfence! w) (write-inst! w sfence:))
(function (sgdt! w op0) (write-inst! w (sgdt: op0)))
(function (shlb! w op0 op1) (write-inst! w (shlb: op0 op1)))
(function (shldl! w op0 op1 op2) (write-inst! w (shldl: op0 op1 op2)))
(function (shldq! w op0 op1 op2) (write-inst! w (shldq: op0 op1 op2)))
(function (shldw! w op0 op1 op2) (write-inst! w (shldw: op0 op1 op2)))
(function (shll! w op0 op1) (write-inst! w (shll: op0 op1)))
(function (shlq! w op0 op1) (write-inst! w (shlq: op0 op1)))
(function (shlw! w op0 op1) (write-inst! w (shlw: op0 op1)))
(function (shrb! w op0 op1) (write-inst! w (shrb: op0 op1)))
(function (shrdl! w op0 op1 op2) (write-inst! w (shrdl: op0 op1 op2)))
(function (shrdq! w op0 op1 op2) (write-inst! w (shrdq: op0 op1 op2)))
(function (shrdw! w op0 op1 op2) (write-inst! w (shrdw: op0 op1 op2)))
(function (shrl! w op0 op1) (write-inst! w (shrl: op0 op1)))
(function (shrq! w op0 op1) (write-inst! w (shrq: op0 op1)))
(function (shrw! w op0 op1) (write-inst! w (shrw: op0 op1)))
(function (shufpd! w op0 op1 op2) (write-inst! w (shufpd: op0 op1 op2)))
(function (shufps! w op0 op1 op2) (write-inst! w (shufps: op0 op1 op2)))
(function (sidt! w op0) (write-inst! w (sidt: op0)))
(function (sqrtpd! w op0 op1) (write-inst! w (sqrtpd: op0 op1)))
(function (sqrtps! w op0 op1) (write-inst! w (sqrtps: op0 op1)))
(function (sqrtsd! w op0 op1) (write-inst! w (sqrtsd: op0 op1)))
(function (sqrtss! w op0 op1) (write-inst! w (sqrtss: op0 op1)))
(function (stc! w) (write-inst! w stc:))
(function (std! w) (write-inst! w std:))
(function (sti! w) (write-inst! w sti:))
(function (stmxcsr! w op0) (write-inst! w (stmxcsr: op0)))
(function (str! w op0) (write-inst! w (str: op0)))
(function (subb! w op0 op1) (write-inst! w (subb: op0 op1)))
(function (subl! w op0 op1) (write-inst! w (subl: op0 op1)))
(function (subpd! w op0 op1) (write-inst! w (subpd: op0 op1)))
(function (subps! w op0 op1) (write-inst! w (subps: op0 op1)))
(function (subq! w op0 op1) (write-inst! w (subq: op0 op1)))
(function (subsd! w op0 op1) (write-inst! w (subsd: op0 op1)))
(function (subss! w op0 op1) (write-inst! w (subss: op0 op1)))
(function (subw! w op0 op1) (write-inst! w (subw: op0 op1)))
(function (swapgs! w) (write-inst! w swapgs:))
(function (testb! w op0 op1) (write-inst! w (testb: op0 op1)))
(function (testl! w op0 op1) (write-inst! w (testl: op0 op1)))
(function (testq! w op0 op1) (write-inst! w (testq: op0 op1)))
(function (testw! w op0 op1) (write-inst! w (testw: op0 op1)))
(function (ucomisd! w op0 op1) (write-inst! w (ucomisd: op0 op1)))
(function (ucomiss! w op0 op1) (write-inst! w (ucomiss: op0 op1)))
(function (ud2! w) (write-inst! w ud2:))
(function (unpckhpd! w op0 op1) (write-inst! w (unpckhpd: op0 op1)))
(function (unpckhps! w op0 op1) (write-inst! w (unpckhps: op0 op1)))
(function (unpcklpd! w op0 op1) (write-inst! w (unpcklpd: op0 op1)))
(function (unpcklps! w op0 op1) (write-inst! w (unpcklps: op0 op1)))
(function (verr! w op0) (write-inst! w (verr: op0)))
(function (verw! w op0) (write-inst! w (verw: op0)))
(function (wbinvd! w) (write-inst! w wbinvd:))
(function (wrmsr! w) (write-inst! w wrmsr:))
(function (xaddb! w op0 op1) (write-inst! w (xaddb: op0 op1)))
(function (xaddl! w op0 op1) (write-inst! w (xaddl: op0 op1)))
(function (xaddq! w op0 op1) (write-inst! w (xaddq: op0 op1)))
(function (xaddw! w op0 op1) (write-inst! w (xaddw: op0 op1)))
(function (xchgb! w op0 op1) (write-inst! w (xchgb: op0 op1)))
(function (xchgl! w op0 op1) (write-inst! w (xchgl: op0 op1)))
(function (xchgq! w op0 op1) (write-inst! w (xchgq: op0 op1)))
(function (xchgw! w op0 op1) (write-inst! w (xchgw: op0 op1)))
(function (xorb! w op0 op1) (write-inst! w (xorb: op0 op1)))
(function (xorl! w op0 op1) (write-inst! w (xorl: op0 op1)))
(function (xorpd! w op0 op1) (write-inst! w (xorpd: op0 op1)))
(function (xorps! w op0 op1) (write-inst! w (xorps: op0 op1)))
(function (xorq! w op0 op1) (write-inst! w (xorq: op0 op1)))
(function (xorw! w op0 op1) (write-inst! w (xorw: op0 op1)))
(function (xsetbv! w) (write-inst! w xsetbv:))


(class (WriteInst W Error Inst)
  (function (write-inst! w inst) {(-> W Inst (Result unit Error))}))

(value-data (Adcb Op0 Op1) (adcb: Op0 Op1))

; adcb r8 r8: Add with carry r/m8 to byte register.
(instance WriteInst.Adcb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Adcb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 12 /r
    (with1 (adcb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 18 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcb r8 m8: Add with carry r/m8 to byte register.
(instance WriteInst.Adcb.Gpr8.Memory (forall W Error) (WriteInst W Error (Adcb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 12 /r
    (with1 (adcb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 18 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcb m8 r8: Add with carry byte register to r/m8.
(instance WriteInst.Adcb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Adcb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 10 /r
    (with1 (adcb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcb r8 imm8: Add with carry imm8 to r/m8.
(instance WriteInst.Adcb.Gpr8.I8 (forall W Error) (WriteInst W Error (Adcb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /2 ib
    (with1 (adcb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcb m8 imm8: Add with carry imm8 to r/m8.
(instance WriteInst.Adcb.Memory.I8 (forall W Error) (WriteInst W Error (Adcb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /2 ib
    (with1 (adcb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcb _Al imm8: Add with carry imm8 to AL
(instance WriteInst.Adcb.|Al.I8 (forall W Error) (WriteInst W Error (Adcb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 14 ib
    (with1 (adcb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 20 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Adcl Op0 Op1) (adcl: Op0 Op1))

; adcl r32 r32: Add with CF r/m32 to r32.
(instance WriteInst.Adcl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Adcl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 13 /r
    (with1 (adcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 19 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcl r32 m32: Add with CF r/m32 to r32.
(instance WriteInst.Adcl.Gpr32.Memory (forall W Error) (WriteInst W Error (Adcl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 13 /r
    (with1 (adcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 19 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcl m32 r32: Add with CF r32 to r/m32.
(instance WriteInst.Adcl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Adcl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 11 /r
    (with1 (adcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 17 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcl r32 imm8: Add with CF sign-extended imm8 into r/m32.
(instance WriteInst.Adcl.Gpr32.I8 (forall W Error) (WriteInst W Error (Adcl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /2 ib
    (with1 (adcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcl m32 imm8: Add with CF sign-extended imm8 into r/m32.
(instance WriteInst.Adcl.Memory.I8 (forall W Error) (WriteInst W Error (Adcl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /2 ib
    (with1 (adcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcl r32 imm32: Add with CF imm32 to r/m32.
(instance WriteInst.Adcl.Gpr32.I32 (forall W Error) (WriteInst W Error (Adcl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /2 id
    (with1 (adcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcl m32 imm32: Add with CF imm32 to r/m32.
(instance WriteInst.Adcl.Memory.I32 (forall W Error) (WriteInst W Error (Adcl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /2 id
    (with1 (adcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcl _Eax imm32: Add with carry imm32 to EAX.
(instance WriteInst.Adcl.|Eax.I32 (forall W Error) (WriteInst W Error (Adcl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 15 id
    (with1 (adcl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 21 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Adcq Op0 Op1) (adcq: Op0 Op1))

; adcq r64 r64: Add with CF r/m64 to r64.
(instance WriteInst.Adcq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Adcq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 13 /r
    (with1 (adcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 19 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcq r64 m64: Add with CF r/m64 to r64.
(instance WriteInst.Adcq.Gpr64.Memory (forall W Error) (WriteInst W Error (Adcq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 13 /r
    (with1 (adcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 19 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcq m64 r64: Add with CF r64 to r/m64.
(instance WriteInst.Adcq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Adcq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 11 /r
    (with1 (adcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 17 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcq r64 imm8: Add with CF sign-extended imm8 into r/m64.
(instance WriteInst.Adcq.Gpr64.I8 (forall W Error) (WriteInst W Error (Adcq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /2 ib
    (with1 (adcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcq m64 imm8: Add with CF sign-extended imm8 into r/m64.
(instance WriteInst.Adcq.Memory.I8 (forall W Error) (WriteInst W Error (Adcq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /2 ib
    (with1 (adcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcq r64 imm32: Add with CF imm32 sign extended to 64-bits to r/m64.
(instance WriteInst.Adcq.Gpr64.I32 (forall W Error) (WriteInst W Error (Adcq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /2 id
    (with1 (adcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcq m64 imm32: Add with CF imm32 sign extended to 64-bits to r/m64.
(instance WriteInst.Adcq.Memory.I32 (forall W Error) (WriteInst W Error (Adcq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /2 id
    (with1 (adcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcq _Rax imm32: Add with carry imm32 sign extended to 64- bits to RAX.
(instance WriteInst.Adcq.|Rax.I32 (forall W Error) (WriteInst W Error (Adcq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 15 id
    (with1 (adcq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 21 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Adcw Op0 Op1) (adcw: Op0 Op1))

; adcw r16 r16: Add with carry r/m16 to r16.
(instance WriteInst.Adcw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Adcw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 13 /r
    (with1 (adcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 19 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcw r16 m16: Add with carry r/m16 to r16.
(instance WriteInst.Adcw.Gpr16.Memory (forall W Error) (WriteInst W Error (Adcw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 13 /r
    (with1 (adcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 19 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcw m16 r16: Add with carry r16 to r/m16.
(instance WriteInst.Adcw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Adcw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 11 /r
    (with1 (adcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 17 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; adcw r16 imm8: Add with CF sign-extended imm8 to r/m16.
(instance WriteInst.Adcw.Gpr16.I8 (forall W Error) (WriteInst W Error (Adcw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /2 ib
    (with1 (adcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcw m16 imm8: Add with CF sign-extended imm8 to r/m16.
(instance WriteInst.Adcw.Memory.I8 (forall W Error) (WriteInst W Error (Adcw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /2 ib
    (with1 (adcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcw r16 imm16: Add with carry imm16 to r/m16.
(instance WriteInst.Adcw.Gpr16.I16 (forall W Error) (WriteInst W Error (Adcw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /2 iw
    (with1 (adcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcw m16 imm16: Add with carry imm16 to r/m16.
(instance WriteInst.Adcw.Memory.I16 (forall W Error) (WriteInst W Error (Adcw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /2 iw
    (with1 (adcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; adcw _Ax imm16: Add with carry imm16 to AX.
(instance WriteInst.Adcw.|Ax.I16 (forall W Error) (WriteInst W Error (Adcw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 15 iw
    (with1 (adcw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 21 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Addb Op0 Op1) (addb: Op0 Op1))

; addb r8 r8: Add r/m8 to r8.
(instance WriteInst.Addb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Addb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 02 /r
    (with1 (addb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 2 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addb r8 m8: Add r/m8 to r8.
(instance WriteInst.Addb.Gpr8.Memory (forall W Error) (WriteInst W Error (Addb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 02 /r
    (with1 (addb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 2 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addb m8 r8: Add r8 to r/m8.
(instance WriteInst.Addb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Addb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 00 /r
    (with1 (addb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 0 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addb r8 imm8: Add imm8 to r/m8.
(instance WriteInst.Addb.Gpr8.I8 (forall W Error) (WriteInst W Error (Addb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /0 ib
    (with1 (addb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addb m8 imm8: Add imm8 to r/m8.
(instance WriteInst.Addb.Memory.I8 (forall W Error) (WriteInst W Error (Addb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /0 ib
    (with1 (addb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addb _Al imm8: Add imm8 to AL.
(instance WriteInst.Addb.|Al.I8 (forall W Error) (WriteInst W Error (Addb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 04 ib
    (with1 (addb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 4 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Addl Op0 Op1) (addl: Op0 Op1))

; addl r32 r32: Add r/m32 to r32.
(instance WriteInst.Addl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Addl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 03 /r
    (with1 (addl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 3 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addl r32 m32: Add r/m32 to r32.
(instance WriteInst.Addl.Gpr32.Memory (forall W Error) (WriteInst W Error (Addl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 03 /r
    (with1 (addl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 3 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addl m32 r32: Add r32 to r/m32.
(instance WriteInst.Addl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Addl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 01 /r
    (with1 (addl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 1 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addl r32 imm8: Add sign-extended imm8 to r/m32.
(instance WriteInst.Addl.Gpr32.I8 (forall W Error) (WriteInst W Error (Addl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /0 ib
    (with1 (addl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addl m32 imm8: Add sign-extended imm8 to r/m32.
(instance WriteInst.Addl.Memory.I8 (forall W Error) (WriteInst W Error (Addl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /0 ib
    (with1 (addl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addl r32 imm32: Add imm32 to r/m32.
(instance WriteInst.Addl.Gpr32.I32 (forall W Error) (WriteInst W Error (Addl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /0 id
    (with1 (addl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addl m32 imm32: Add imm32 to r/m32.
(instance WriteInst.Addl.Memory.I32 (forall W Error) (WriteInst W Error (Addl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /0 id
    (with1 (addl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addl _Eax imm32: Add imm32 to EAX.
(instance WriteInst.Addl.|Eax.I32 (forall W Error) (WriteInst W Error (Addl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 05 id
    (with1 (addl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 5 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Addpd Op0 Op1) (addpd: Op0 Op1))

; addpd xmm xmm: Add packed double-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Addpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Addpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 58 /r
    (with1 (addpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 88 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addpd xmm m128: Add packed double-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Addpd.Xmm.Memory (forall W Error) (WriteInst W Error (Addpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 58 /r
    (with1 (addpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 88 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Addps Op0 Op1) (addps: Op0 Op1))

; addps xmm xmm: Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.
(instance WriteInst.Addps.Xmm.Xmm (forall W Error) (WriteInst W Error (Addps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 58 /r
    (with1 (addps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 88 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addps xmm m128: Add packed single-precision floating-point values from xmm2/m128 to xmm1 and stores result in xmm1.
(instance WriteInst.Addps.Xmm.Memory (forall W Error) (WriteInst W Error (Addps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 58 /r
    (with1 (addps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 88 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Addq Op0 Op1) (addq: Op0 Op1))

; addq r64 r64: Add r/m64 to r64.
(instance WriteInst.Addq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Addq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 03 /r
    (with1 (addq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 3 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addq r64 m64: Add r/m64 to r64.
(instance WriteInst.Addq.Gpr64.Memory (forall W Error) (WriteInst W Error (Addq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 03 /r
    (with1 (addq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 3 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addq m64 r64: Add r64 to r/m64.
(instance WriteInst.Addq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Addq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 01 /r
    (with1 (addq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 1 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addq r64 imm8: Add sign-extended imm8 to r/m64.
(instance WriteInst.Addq.Gpr64.I8 (forall W Error) (WriteInst W Error (Addq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /0 ib
    (with1 (addq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addq m64 imm8: Add sign-extended imm8 to r/m64.
(instance WriteInst.Addq.Memory.I8 (forall W Error) (WriteInst W Error (Addq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /0 ib
    (with1 (addq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addq r64 imm32: Add imm32 sign-extended to 64-bits to r/m64.
(instance WriteInst.Addq.Gpr64.I32 (forall W Error) (WriteInst W Error (Addq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /0 id
    (with1 (addq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addq m64 imm32: Add imm32 sign-extended to 64-bits to r/m64.
(instance WriteInst.Addq.Memory.I32 (forall W Error) (WriteInst W Error (Addq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /0 id
    (with1 (addq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addq _Rax imm32: Add imm32 sign-extended to 64-bits to RAX.
(instance WriteInst.Addq.|Rax.I32 (forall W Error) (WriteInst W Error (Addq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 05 id
    (with1 (addq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 5 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Addsd Op0 Op1) (addsd: Op0 Op1))

; addsd xmm xmm: Add the low double-precision floating-point value from xmm2/m64 to xmm1.
(instance WriteInst.Addsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Addsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 58 /r
    (with1 (addsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 88 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addsd xmm m64: Add the low double-precision floating-point value from xmm2/m64 to xmm1.
(instance WriteInst.Addsd.Xmm.Memory (forall W Error) (WriteInst W Error (Addsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 58 /r
    (with1 (addsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 88 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Addss Op0 Op1) (addss: Op0 Op1))

; addss xmm xmm: Add the low single-precision floating-point value from xmm2/m32 to xmm1.
(instance WriteInst.Addss.Xmm.Xmm (forall W Error) (WriteInst W Error (Addss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 58 /r
    (with1 (addss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 88 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addss xmm m32: Add the low single-precision floating-point value from xmm2/m32 to xmm1.
(instance WriteInst.Addss.Xmm.Memory (forall W Error) (WriteInst W Error (Addss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 58 /r
    (with1 (addss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 88 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Addw Op0 Op1) (addw: Op0 Op1))

; addw r16 r16: Add r/m16 to r16.
(instance WriteInst.Addw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Addw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 03 /r
    (with1 (addw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 3 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addw r16 m16: Add r/m16 to r16.
(instance WriteInst.Addw.Gpr16.Memory (forall W Error) (WriteInst W Error (Addw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 03 /r
    (with1 (addw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 3 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addw m16 r16: Add r16 to r/m16.
(instance WriteInst.Addw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Addw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 01 /r
    (with1 (addw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 1 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; addw r16 imm8: Add sign-extended imm8 to r/m16.
(instance WriteInst.Addw.Gpr16.I8 (forall W Error) (WriteInst W Error (Addw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /0 ib
    (with1 (addw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addw m16 imm8: Add sign-extended imm8 to r/m16.
(instance WriteInst.Addw.Memory.I8 (forall W Error) (WriteInst W Error (Addw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /0 ib
    (with1 (addw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addw r16 imm16: Add imm16 to r/m16.
(instance WriteInst.Addw.Gpr16.I16 (forall W Error) (WriteInst W Error (Addw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /0 iw
    (with1 (addw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addw m16 imm16: Add imm16 to r/m16.
(instance WriteInst.Addw.Memory.I16 (forall W Error) (WriteInst W Error (Addw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /0 iw
    (with1 (addw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; addw _Ax imm16: Add imm16 to AX.
(instance WriteInst.Addw.|Ax.I16 (forall W Error) (WriteInst W Error (Addw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 05 iw
    (with1 (addw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 5 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Andb Op0 Op1) (andb: Op0 Op1))

; andb r8 r8: r8 AND r/m8.
(instance WriteInst.Andb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Andb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 22 /r
    (with1 (andb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 34 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andb r8 m8: r8 AND r/m8.
(instance WriteInst.Andb.Gpr8.Memory (forall W Error) (WriteInst W Error (Andb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 22 /r
    (with1 (andb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 34 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andb m8 r8: r/m8 AND r8.
(instance WriteInst.Andb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Andb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 20 /r
    (with1 (andb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 32 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andb r8 imm8: r/m8 AND imm8.
(instance WriteInst.Andb.Gpr8.I8 (forall W Error) (WriteInst W Error (Andb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /4 ib
    (with1 (andb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andb m8 imm8: r/m8 AND imm8.
(instance WriteInst.Andb.Memory.I8 (forall W Error) (WriteInst W Error (Andb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /4 ib
    (with1 (andb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andb _Al imm8: AL AND imm8.
(instance WriteInst.Andb.|Al.I8 (forall W Error) (WriteInst W Error (Andb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 24 ib
    (with1 (andb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 36 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Andl Op0 Op1) (andl: Op0 Op1))

; andl r32 r32: r32 AND r/m32.
(instance WriteInst.Andl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Andl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 23 /r
    (with1 (andl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 35 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andl r32 m32: r32 AND r/m32.
(instance WriteInst.Andl.Gpr32.Memory (forall W Error) (WriteInst W Error (Andl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 23 /r
    (with1 (andl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 35 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andl m32 r32: r/m32 AND r32.
(instance WriteInst.Andl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Andl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 21 /r
    (with1 (andl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 33 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andl r32 imm8: r/m32 AND imm8 (sign-extended).
(instance WriteInst.Andl.Gpr32.I8 (forall W Error) (WriteInst W Error (Andl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /4 ib
    (with1 (andl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andl m32 imm8: r/m32 AND imm8 (sign-extended).
(instance WriteInst.Andl.Memory.I8 (forall W Error) (WriteInst W Error (Andl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /4 ib
    (with1 (andl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andl r32 imm32: r/m32 AND imm32.
(instance WriteInst.Andl.Gpr32.I32 (forall W Error) (WriteInst W Error (Andl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /4 id
    (with1 (andl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andl m32 imm32: r/m32 AND imm32.
(instance WriteInst.Andl.Memory.I32 (forall W Error) (WriteInst W Error (Andl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /4 id
    (with1 (andl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andl _Eax imm32: EAX AND imm32.
(instance WriteInst.Andl.|Eax.I32 (forall W Error) (WriteInst W Error (Andl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 25 id
    (with1 (andl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 37 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Andnpd Op0 Op1) (andnpd: Op0 Op1))

; andnpd xmm xmm: Bitwise logical AND NOT of xmm2/m128 and xmm1.
(instance WriteInst.Andnpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Andnpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 55 /r
    (with1 (andnpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 85 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andnpd xmm m128: Bitwise logical AND NOT of xmm2/m128 and xmm1.
(instance WriteInst.Andnpd.Xmm.Memory (forall W Error) (WriteInst W Error (Andnpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 55 /r
    (with1 (andnpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 85 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Andnps Op0 Op1) (andnps: Op0 Op1))

; andnps xmm xmm: Bitwise logical AND NOT of xmm2/m128 and xmm1.
(instance WriteInst.Andnps.Xmm.Xmm (forall W Error) (WriteInst W Error (Andnps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 55 /r
    (with1 (andnps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 85 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andnps xmm m128: Bitwise logical AND NOT of xmm2/m128 and xmm1.
(instance WriteInst.Andnps.Xmm.Memory (forall W Error) (WriteInst W Error (Andnps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 55 /r
    (with1 (andnps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 85 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Andpd Op0 Op1) (andpd: Op0 Op1))

; andpd xmm xmm: Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.
(instance WriteInst.Andpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Andpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 54 /r
    (with1 (andpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 84 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andpd xmm m128: Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/m128.
(instance WriteInst.Andpd.Xmm.Memory (forall W Error) (WriteInst W Error (Andpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 54 /r
    (with1 (andpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 84 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Andps Op0 Op1) (andps: Op0 Op1))

; andps xmm xmm: Bitwise logical AND of xmm2/m128 and xmm1.
(instance WriteInst.Andps.Xmm.Xmm (forall W Error) (WriteInst W Error (Andps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 54 /r
    (with1 (andps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 84 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andps xmm m128: Bitwise logical AND of xmm2/m128 and xmm1.
(instance WriteInst.Andps.Xmm.Memory (forall W Error) (WriteInst W Error (Andps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 54 /r
    (with1 (andps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 84 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Andq Op0 Op1) (andq: Op0 Op1))

; andq r64 r64: r64 AND r/m64.
(instance WriteInst.Andq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Andq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 23 /r
    (with1 (andq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 35 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andq r64 m64: r64 AND r/m64.
(instance WriteInst.Andq.Gpr64.Memory (forall W Error) (WriteInst W Error (Andq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 23 /r
    (with1 (andq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 35 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andq m64 r64: r/m64 AND r32.
(instance WriteInst.Andq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Andq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 21 /r
    (with1 (andq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 33 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andq r64 imm8: r/m64 AND imm8 (sign-extended).
(instance WriteInst.Andq.Gpr64.I8 (forall W Error) (WriteInst W Error (Andq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /4 ib
    (with1 (andq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andq m64 imm8: r/m64 AND imm8 (sign-extended).
(instance WriteInst.Andq.Memory.I8 (forall W Error) (WriteInst W Error (Andq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /4 ib
    (with1 (andq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andq r64 imm32: r/m64 AND imm32 sign extended to 64-bits.
(instance WriteInst.Andq.Gpr64.I32 (forall W Error) (WriteInst W Error (Andq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /4 id
    (with1 (andq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andq m64 imm32: r/m64 AND imm32 sign extended to 64-bits.
(instance WriteInst.Andq.Memory.I32 (forall W Error) (WriteInst W Error (Andq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /4 id
    (with1 (andq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andq _Rax imm32: RAX AND imm32 sign-extended to 64-bits.
(instance WriteInst.Andq.|Rax.I32 (forall W Error) (WriteInst W Error (Andq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 25 id
    (with1 (andq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 37 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Andw Op0 Op1) (andw: Op0 Op1))

; andw r16 r16: r16 AND r/m16.
(instance WriteInst.Andw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Andw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 23 /r
    (with1 (andw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 35 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andw r16 m16: r16 AND r/m16.
(instance WriteInst.Andw.Gpr16.Memory (forall W Error) (WriteInst W Error (Andw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 23 /r
    (with1 (andw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 35 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andw m16 r16: r/m16 AND r16.
(instance WriteInst.Andw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Andw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 21 /r
    (with1 (andw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 33 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; andw r16 imm8: r/m16 AND imm8 (sign-extended).
(instance WriteInst.Andw.Gpr16.I8 (forall W Error) (WriteInst W Error (Andw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /4 ib
    (with1 (andw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andw m16 imm8: r/m16 AND imm8 (sign-extended).
(instance WriteInst.Andw.Memory.I8 (forall W Error) (WriteInst W Error (Andw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /4 ib
    (with1 (andw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andw r16 imm16: r/m16 AND imm16.
(instance WriteInst.Andw.Gpr16.I16 (forall W Error) (WriteInst W Error (Andw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /4 iw
    (with1 (andw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andw m16 imm16: r/m16 AND imm16.
(instance WriteInst.Andw.Memory.I16 (forall W Error) (WriteInst W Error (Andw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /4 iw
    (with1 (andw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; andw _Ax imm16: AX AND imm16.
(instance WriteInst.Andw.|Ax.I16 (forall W Error) (WriteInst W Error (Andw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 25 iw
    (with1 (andw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 37 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Blendpd Op0 Op1 Op2) (blendpd: Op0 Op1 Op2))

; blendpd xmm xmm imm8: Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
(instance WriteInst.Blendpd.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Blendpd Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0D /r ib
    (with1 (blendpd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 13 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; blendpd xmm m128 imm8: Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
(instance WriteInst.Blendpd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Blendpd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0D /r ib
    (with1 (blendpd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 13 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Blendps Op0 Op1 Op2) (blendps: Op0 Op1 Op2))

; blendps xmm xmm imm8: Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
(instance WriteInst.Blendps.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Blendps Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0C /r ib
    (with1 (blendps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 12 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; blendps xmm m128 imm8: Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
(instance WriteInst.Blendps.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Blendps Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0C /r ib
    (with1 (blendps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 12 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Blendvpd Op0 Op1 Op2) (blendvpd: Op0 Op1 Op2))

; blendvpd xmm xmm _Xmm0: Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.
(instance WriteInst.Blendvpd.Xmm.Xmm.|Xmm0 (forall W Error) (WriteInst W Error (Blendvpd Xmm Xmm |Xmm0)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 15 /r
    (with1 (blendvpd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 21 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; blendvpd xmm m128 _Xmm0: Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.
(instance WriteInst.Blendvpd.Xmm.Memory.|Xmm0 (forall W Error) (WriteInst W Error (Blendvpd Xmm Memory |Xmm0)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 15 /r
    (with1 (blendvpd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 21 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Blendvps Op0 Op1 Op2) (blendvps: Op0 Op1 Op2))

; blendvps xmm xmm _Xmm0: Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.
(instance WriteInst.Blendvps.Xmm.Xmm.|Xmm0 (forall W Error) (WriteInst W Error (Blendvps Xmm Xmm |Xmm0)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 14 /r
    (with1 (blendvps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 20 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; blendvps xmm m128 _Xmm0: Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.
(instance WriteInst.Blendvps.Xmm.Memory.|Xmm0 (forall W Error) (WriteInst W Error (Blendvps Xmm Memory |Xmm0)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 14 /r
    (with1 (blendvps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 20 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Bsfl Op0 Op1) (bsfl: Op0 Op1))

; bsfl r32 r32: Bit scan forward on r/m32.
(instance WriteInst.Bsfl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Bsfl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BC /r
    (with1 (bsfl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 188 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; bsfl r32 m32: Bit scan forward on r/m32.
(instance WriteInst.Bsfl.Gpr32.Memory (forall W Error) (WriteInst W Error (Bsfl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BC /r
    (with1 (bsfl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 188 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Bsfq Op0 Op1) (bsfq: Op0 Op1))

; bsfq r64 r64: Bit scan forward on r/m64.
(instance WriteInst.Bsfq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Bsfq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BC /r
    (with1 (bsfq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 188 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; bsfq r64 m64: Bit scan forward on r/m64.
(instance WriteInst.Bsfq.Gpr64.Memory (forall W Error) (WriteInst W Error (Bsfq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BC /r
    (with1 (bsfq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 188 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Bsfw Op0 Op1) (bsfw: Op0 Op1))

; bsfw r16 r16: Bit scan forward on r/m16.
(instance WriteInst.Bsfw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Bsfw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BC /r
    (with1 (bsfw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 188 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; bsfw r16 m16: Bit scan forward on r/m16.
(instance WriteInst.Bsfw.Gpr16.Memory (forall W Error) (WriteInst W Error (Bsfw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BC /r
    (with1 (bsfw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 188 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Bsrl Op0 Op1) (bsrl: Op0 Op1))

; bsrl r32 r32: Bit scan reverse on r/m32.
(instance WriteInst.Bsrl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Bsrl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BD /r
    (with1 (bsrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 189 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; bsrl r32 m32: Bit scan reverse on r/m32.
(instance WriteInst.Bsrl.Gpr32.Memory (forall W Error) (WriteInst W Error (Bsrl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BD /r
    (with1 (bsrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 189 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Bsrq Op0 Op1) (bsrq: Op0 Op1))

; bsrq r64 r64: Bit scan reverse on r/m64.
(instance WriteInst.Bsrq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Bsrq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BD /r
    (with1 (bsrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 189 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; bsrq r64 m64: Bit scan reverse on r/m64.
(instance WriteInst.Bsrq.Gpr64.Memory (forall W Error) (WriteInst W Error (Bsrq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BD /r
    (with1 (bsrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 189 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Bsrw Op0 Op1) (bsrw: Op0 Op1))

; bsrw r16 r16: Bit scan reverse on r/m16.
(instance WriteInst.Bsrw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Bsrw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BD /r
    (with1 (bsrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 189 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; bsrw r16 m16: Bit scan reverse on r/m16.
(instance WriteInst.Bsrw.Gpr16.Memory (forall W Error) (WriteInst W Error (Bsrw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BD /r
    (with1 (bsrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 189 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Bswap Op0) (bswap: Op0))

; bswap r32: Reverses the byte order of a 32-bit register.
(instance WriteInst.Bswap.Gpr32 (forall W Error) (WriteInst W Error (Bswap Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C8 +rd
    (with1 (bswap: (let op0)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! (+ 200 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

; bswap r64: Reverses the byte order of a 64-bit register.
(instance WriteInst.Bswap.Gpr64 (forall W Error) (WriteInst W Error (Bswap Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F C8 +ro
    (with1 (bswap: (let op0)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! (+ 200 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

(value-data (Btcl Op0 Op1) (btcl: Op0 Op1))

; btcl r32 r32: Store selected bit in CF flag and complement.
(instance WriteInst.Btcl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Btcl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BB /r
    (with1 (btcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 187 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btcl m32 r32: Store selected bit in CF flag and complement.
(instance WriteInst.Btcl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Btcl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BB /r
    (with1 (btcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 187 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btcl r32 imm8: Store selected bit in CF flag and complement.
(instance WriteInst.Btcl.Gpr32.I8 (forall W Error) (WriteInst W Error (Btcl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BA /7 ib
    (with1 (btcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btcl m32 imm8: Store selected bit in CF flag and complement.
(instance WriteInst.Btcl.Memory.I8 (forall W Error) (WriteInst W Error (Btcl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BA /7 ib
    (with1 (btcl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btcq Op0 Op1) (btcq: Op0 Op1))

; btcq r64 r64: Store selected bit in CF flag and complement.
(instance WriteInst.Btcq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Btcq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BB /r
    (with1 (btcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 187 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btcq m64 r64: Store selected bit in CF flag and complement.
(instance WriteInst.Btcq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Btcq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BB /r
    (with1 (btcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 187 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btcq r64 imm8: Store selected bit in CF flag and complement.
(instance WriteInst.Btcq.Gpr64.I8 (forall W Error) (WriteInst W Error (Btcq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BA /7 ib
    (with1 (btcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btcq m64 imm8: Store selected bit in CF flag and complement.
(instance WriteInst.Btcq.Memory.I8 (forall W Error) (WriteInst W Error (Btcq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BA /7 ib
    (with1 (btcq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btcw Op0 Op1) (btcw: Op0 Op1))

; btcw r16 r16: Store selected bit in CF flag and complement.
(instance WriteInst.Btcw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Btcw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BB /r
    (with1 (btcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 187 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btcw m16 r16: Store selected bit in CF flag and complement.
(instance WriteInst.Btcw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Btcw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BB /r
    (with1 (btcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 187 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btcw r16 imm8: Store selected bit in CF flag and complement.
(instance WriteInst.Btcw.Gpr16.I8 (forall W Error) (WriteInst W Error (Btcw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BA /7 ib
    (with1 (btcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btcw m16 imm8: Store selected bit in CF flag and complement.
(instance WriteInst.Btcw.Memory.I8 (forall W Error) (WriteInst W Error (Btcw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BA /7 ib
    (with1 (btcw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btl Op0 Op1) (btl: Op0 Op1))

; btl r32 r32: Store selected bit in CF flag.
(instance WriteInst.Btl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Btl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F A3 /r
    (with1 (btl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 163 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btl m32 r32: Store selected bit in CF flag.
(instance WriteInst.Btl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Btl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F A3 /r
    (with1 (btl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 163 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btl r32 imm8: Store selected bit in CF flag.
(instance WriteInst.Btl.Gpr32.I8 (forall W Error) (WriteInst W Error (Btl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BA /4 ib
    (with1 (btl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btl m32 imm8: Store selected bit in CF flag.
(instance WriteInst.Btl.Memory.I8 (forall W Error) (WriteInst W Error (Btl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BA /4 ib
    (with1 (btl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btq Op0 Op1) (btq: Op0 Op1))

; btq r64 r64: Store selected bit in CF flag.
(instance WriteInst.Btq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Btq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F A3 /r
    (with1 (btq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 163 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btq m64 r64: Store selected bit in CF flag.
(instance WriteInst.Btq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Btq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F A3 /r
    (with1 (btq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 163 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btq r64 imm8: Store selected bit in CF flag.
(instance WriteInst.Btq.Gpr64.I8 (forall W Error) (WriteInst W Error (Btq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BA /4 ib
    (with1 (btq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btq m64 imm8: Store selected bit in CF flag.
(instance WriteInst.Btq.Memory.I8 (forall W Error) (WriteInst W Error (Btq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BA /4 ib
    (with1 (btq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btrl Op0 Op1) (btrl: Op0 Op1))

; btrl r32 r32: Store selected bit in CF flag and clear.
(instance WriteInst.Btrl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Btrl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B3 /r
    (with1 (btrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 179 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btrl m32 r32: Store selected bit in CF flag and clear.
(instance WriteInst.Btrl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Btrl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B3 /r
    (with1 (btrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 179 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btrl r32 imm8: Store selected bit in CF flag and clear.
(instance WriteInst.Btrl.Gpr32.I8 (forall W Error) (WriteInst W Error (Btrl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BA /6 ib
    (with1 (btrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btrl m32 imm8: Store selected bit in CF flag and clear.
(instance WriteInst.Btrl.Memory.I8 (forall W Error) (WriteInst W Error (Btrl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BA /6 ib
    (with1 (btrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btrq Op0 Op1) (btrq: Op0 Op1))

; btrq r64 r64: Store selected bit in CF flag and clear.
(instance WriteInst.Btrq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Btrq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F B3 /r
    (with1 (btrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 179 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btrq m64 r64: Store selected bit in CF flag and clear.
(instance WriteInst.Btrq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Btrq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F B3 /r
    (with1 (btrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 179 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btrq r64 imm8: Store selected bit in CF flag and clear.
(instance WriteInst.Btrq.Gpr64.I8 (forall W Error) (WriteInst W Error (Btrq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BA /6 ib
    (with1 (btrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btrq m64 imm8: Store selected bit in CF flag and clear.
(instance WriteInst.Btrq.Memory.I8 (forall W Error) (WriteInst W Error (Btrq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BA /6 ib
    (with1 (btrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btrw Op0 Op1) (btrw: Op0 Op1))

; btrw r16 r16: Store selected bit in CF flag and clear.
(instance WriteInst.Btrw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Btrw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F B3 /r
    (with1 (btrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 179 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btrw m16 r16: Store selected bit in CF flag and clear.
(instance WriteInst.Btrw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Btrw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F B3 /r
    (with1 (btrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 179 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btrw r16 imm8: Store selected bit in CF flag and clear.
(instance WriteInst.Btrw.Gpr16.I8 (forall W Error) (WriteInst W Error (Btrw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BA /6 ib
    (with1 (btrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btrw m16 imm8: Store selected bit in CF flag and clear.
(instance WriteInst.Btrw.Memory.I8 (forall W Error) (WriteInst W Error (Btrw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BA /6 ib
    (with1 (btrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btsl Op0 Op1) (btsl: Op0 Op1))

; btsl r32 r32: Store selected bit in CF flag and set.
(instance WriteInst.Btsl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Btsl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AB /r
    (with1 (btsl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 171 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btsl m32 r32: Store selected bit in CF flag and set.
(instance WriteInst.Btsl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Btsl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AB /r
    (with1 (btsl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 171 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btsl r32 imm8: Store selected bit in CF flag and set.
(instance WriteInst.Btsl.Gpr32.I8 (forall W Error) (WriteInst W Error (Btsl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BA /5 ib
    (with1 (btsl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btsl m32 imm8: Store selected bit in CF flag and set.
(instance WriteInst.Btsl.Memory.I8 (forall W Error) (WriteInst W Error (Btsl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BA /5 ib
    (with1 (btsl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btsq Op0 Op1) (btsq: Op0 Op1))

; btsq r64 r64: Store selected bit in CF flag and set.
(instance WriteInst.Btsq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Btsq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F AB /r
    (with1 (btsq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 171 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btsq m64 r64: Store selected bit in CF flag and set.
(instance WriteInst.Btsq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Btsq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F AB /r
    (with1 (btsq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 171 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btsq r64 imm8: Store selected bit in CF flag and set.
(instance WriteInst.Btsq.Gpr64.I8 (forall W Error) (WriteInst W Error (Btsq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BA /5 ib
    (with1 (btsq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btsq m64 imm8: Store selected bit in CF flag and set.
(instance WriteInst.Btsq.Memory.I8 (forall W Error) (WriteInst W Error (Btsq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BA /5 ib
    (with1 (btsq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btsw Op0 Op1) (btsw: Op0 Op1))

; btsw r16 r16: Store selected bit in CF flag and set.
(instance WriteInst.Btsw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Btsw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F AB /r
    (with1 (btsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 171 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btsw m16 r16: Store selected bit in CF flag and set.
(instance WriteInst.Btsw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Btsw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F AB /r
    (with1 (btsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 171 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btsw r16 imm8: Store selected bit in CF flag and set.
(instance WriteInst.Btsw.Gpr16.I8 (forall W Error) (WriteInst W Error (Btsw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BA /5 ib
    (with1 (btsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btsw m16 imm8: Store selected bit in CF flag and set.
(instance WriteInst.Btsw.Memory.I8 (forall W Error) (WriteInst W Error (Btsw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BA /5 ib
    (with1 (btsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Btw Op0 Op1) (btw: Op0 Op1))

; btw r16 r16: Store selected bit in CF flag.
(instance WriteInst.Btw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Btw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F A3 /r
    (with1 (btw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 163 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btw m16 r16: Store selected bit in CF flag.
(instance WriteInst.Btw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Btw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F A3 /r
    (with1 (btw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 163 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; btw r16 imm8: Store selected bit in CF flag.
(instance WriteInst.Btw.Gpr16.I8 (forall W Error) (WriteInst W Error (Btw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BA /4 ib
    (with1 (btw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; btw m16 imm8: Store selected bit in CF flag.
(instance WriteInst.Btw.Memory.I8 (forall W Error) (WriteInst W Error (Btw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BA /4 ib
    (with1 (btw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 186 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Callq Op0) (callq: Op0))

; callq rel32: Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.
(instance WriteInst.Callq.I32 (forall W Error) (WriteInst W Error (Callq I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; E8 cd
    (with1 (callq: (let op0)) inst
      (let ()
        (write-u8! 232 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; callq r64: Call near, absolute indirect, address given in r/m64.
(instance WriteInst.Callq.Gpr64 (forall W Error) (WriteInst W Error (Callq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /2
    (with1 (callq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; callq m64: Call near, absolute indirect, address given in r/m64.
(instance WriteInst.Callq.Memory (forall W Error) (WriteInst W Error (Callq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /2
    (with1 (callq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Cbtw cbtw:)

; cbtw: AX = sign-extend of AL.
(instance WriteInst.Cbtw (forall W Error) (WriteInst W Error Cbtw) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 98
    (with1 cbtw: inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 152 w)!
        (ok unit)))))

(value-data Clc clc:)

; clc: Clear CF flag.
(instance WriteInst.Clc (forall W Error) (WriteInst W Error Clc) (where (Write W Error))
  (function (write-inst! w inst)
    ; F8
    (with1 clc: inst
      (let ()
        (write-u8! 248 w)!
        (ok unit)))))

(value-data Cld cld:)

; cld: Clear DF flag.
(instance WriteInst.Cld (forall W Error) (WriteInst W Error Cld) (where (Write W Error))
  (function (write-inst! w inst)
    ; FC
    (with1 cld: inst
      (let ()
        (write-u8! 252 w)!
        (ok unit)))))

(value-data Cli cli:)

; cli: Clear interrupt flag; interrupts disabled when interrupt flag cleared.
(instance WriteInst.Cli (forall W Error) (WriteInst W Error Cli) (where (Write W Error))
  (function (write-inst! w inst)
    ; FA
    (with1 cli: inst
      (let ()
        (write-u8! 250 w)!
        (ok unit)))))

(value-data Cltd cltd:)

; cltd: EDX:EAX = sign-extend of EAX.
(instance WriteInst.Cltd (forall W Error) (WriteInst W Error Cltd) (where (Write W Error))
  (function (write-inst! w inst)
    ; 99
    (with1 cltd: inst
      (let ()
        (write-u8! 153 w)!
        (ok unit)))))

(value-data Cltq cltq:)

; cltq: RAX = sign-extend of EAX.
(instance WriteInst.Cltq (forall W Error) (WriteInst W Error Cltq) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 98
    (with1 cltq: inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 152 w)!
        (ok unit)))))

(value-data Clts clts:)

; clts: Clears TS flag in CR0.
(instance WriteInst.Clts (forall W Error) (WriteInst W Error Clts) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 06
    (with1 clts: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 6 w)!
        (ok unit)))))

(value-data Cmc cmc:)

; cmc: Complement CF flag.
(instance WriteInst.Cmc (forall W Error) (WriteInst W Error Cmc) (where (Write W Error))
  (function (write-inst! w inst)
    ; F5
    (with1 cmc: inst
      (let ()
        (write-u8! 245 w)!
        (ok unit)))))

(value-data (Cmpb Op0 Op1) (cmpb: Op0 Op1))

; cmpb r8 r8: Compare r/m8 with r8.
(instance WriteInst.Cmpb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Cmpb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 3A /r
    (with1 (cmpb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 58 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpb r8 m8: Compare r/m8 with r8.
(instance WriteInst.Cmpb.Gpr8.Memory (forall W Error) (WriteInst W Error (Cmpb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 3A /r
    (with1 (cmpb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 58 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpb m8 r8: Compare r8 with r/m8.
(instance WriteInst.Cmpb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Cmpb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 38 /r
    (with1 (cmpb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 56 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpb r8 imm8: Compare imm8 with r/m8.
(instance WriteInst.Cmpb.Gpr8.I8 (forall W Error) (WriteInst W Error (Cmpb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /7 ib
    (with1 (cmpb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpb m8 imm8: Compare imm8 with r/m8.
(instance WriteInst.Cmpb.Memory.I8 (forall W Error) (WriteInst W Error (Cmpb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /7 ib
    (with1 (cmpb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpb _Al imm8: Compare imm8 with AL.
(instance WriteInst.Cmpb.|Al.I8 (forall W Error) (WriteInst W Error (Cmpb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 3C ib
    (with1 (cmpb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 60 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Cmpl Op0 Op1) (cmpl: Op0 Op1))

; cmpl r32 r32: Compare r/m32 with r32.
(instance WriteInst.Cmpl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Cmpl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 3B /r
    (with1 (cmpl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 59 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpl r32 m32: Compare r/m32 with r32.
(instance WriteInst.Cmpl.Gpr32.Memory (forall W Error) (WriteInst W Error (Cmpl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 3B /r
    (with1 (cmpl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 59 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpl m32 r32: Compare r32 with r/m32.
(instance WriteInst.Cmpl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Cmpl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 39 /r
    (with1 (cmpl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 57 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpl r32 imm8: Compare imm8 with r/m32.
(instance WriteInst.Cmpl.Gpr32.I8 (forall W Error) (WriteInst W Error (Cmpl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /7 ib
    (with1 (cmpl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpl m32 imm8: Compare imm8 with r/m32.
(instance WriteInst.Cmpl.Memory.I8 (forall W Error) (WriteInst W Error (Cmpl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /7 ib
    (with1 (cmpl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpl r32 imm32: Compare imm32 with r/m32.
(instance WriteInst.Cmpl.Gpr32.I32 (forall W Error) (WriteInst W Error (Cmpl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /7 id
    (with1 (cmpl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpl m32 imm32: Compare imm32 with r/m32.
(instance WriteInst.Cmpl.Memory.I32 (forall W Error) (WriteInst W Error (Cmpl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /7 id
    (with1 (cmpl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpl _Eax imm32: Compare imm32 with EAX.
(instance WriteInst.Cmpl.|Eax.I32 (forall W Error) (WriteInst W Error (Cmpl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 3D id
    (with1 (cmpl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 61 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Cmppd Op0 Op1 Op2) (cmppd: Op0 Op1 Op2))

; cmppd xmm xmm imm8: Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.
(instance WriteInst.Cmppd.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Cmppd Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C2 /r ib
    (with1 (cmppd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 194 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; cmppd xmm m128 imm8: Compare packed double-precision floating- point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.
(instance WriteInst.Cmppd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Cmppd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C2 /r ib
    (with1 (cmppd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 194 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Cmpps Op0 Op1 Op2) (cmpps: Op0 Op1 Op2))

; cmpps xmm xmm imm8: Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.
(instance WriteInst.Cmpps.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Cmpps Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C2 /r ib
    (with1 (cmpps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 194 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; cmpps xmm m128 imm8: Compare packed single-precision floating- point values in xmm2/mem and xmm1 using imm8 as comparison predicate.
(instance WriteInst.Cmpps.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Cmpps Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C2 /r ib
    (with1 (cmpps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 194 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Cmpq Op0 Op1) (cmpq: Op0 Op1))

; cmpq r64 r64: Compare r/m64 with r64.
(instance WriteInst.Cmpq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Cmpq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 3B /r
    (with1 (cmpq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 59 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpq r64 m64: Compare r/m64 with r64.
(instance WriteInst.Cmpq.Gpr64.Memory (forall W Error) (WriteInst W Error (Cmpq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 3B /r
    (with1 (cmpq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 59 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpq m64 r64: Compare r64 with r/m64.
(instance WriteInst.Cmpq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Cmpq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 39 /r
    (with1 (cmpq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 57 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpq r64 imm8: Compare imm8 with r/m64.
(instance WriteInst.Cmpq.Gpr64.I8 (forall W Error) (WriteInst W Error (Cmpq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /7 ib
    (with1 (cmpq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpq m64 imm8: Compare imm8 with r/m64.
(instance WriteInst.Cmpq.Memory.I8 (forall W Error) (WriteInst W Error (Cmpq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /7 ib
    (with1 (cmpq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpq r64 imm32: Compare imm32 sign-extended to 64-bits with r/m64.
(instance WriteInst.Cmpq.Gpr64.I32 (forall W Error) (WriteInst W Error (Cmpq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /7 id
    (with1 (cmpq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpq m64 imm32: Compare imm32 sign-extended to 64-bits with r/m64.
(instance WriteInst.Cmpq.Memory.I32 (forall W Error) (WriteInst W Error (Cmpq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /7 id
    (with1 (cmpq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpq _Rax imm32: Compare imm32 sign-extended to 64-bits with RAX.
(instance WriteInst.Cmpq.|Rax.I32 (forall W Error) (WriteInst W Error (Cmpq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 3D id
    (with1 (cmpq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 61 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Cmpsd Op0 Op1 Op2) (cmpsd: Op0 Op1 Op2))

; cmpsd xmm xmm imm8: Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.
(instance WriteInst.Cmpsd.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Cmpsd Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F C2 /r ib
    (with1 (cmpsd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 194 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; cmpsd xmm m64 imm8: Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.
(instance WriteInst.Cmpsd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Cmpsd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F C2 /r ib
    (with1 (cmpsd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 194 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data Cmpsl cmpsl:)

; cmpsl: For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly.
(instance WriteInst.Cmpsl (forall W Error) (WriteInst W Error Cmpsl) (where (Write W Error))
  (function (write-inst! w inst)
    ; A7
    (with1 cmpsl: inst
      (let ()
        (write-u8! 167 w)!
        (ok unit)))))

(value-data (Cmpss Op0 Op1 Op2) (cmpss: Op0 Op1 Op2))

; cmpss xmm xmm imm8: Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.
(instance WriteInst.Cmpss.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Cmpss Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F C2 /r ib
    (with1 (cmpss: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 194 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; cmpss xmm m32 imm8: Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.
(instance WriteInst.Cmpss.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Cmpss Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F C2 /r ib
    (with1 (cmpss: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 194 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Cmpw Op0 Op1) (cmpw: Op0 Op1))

; cmpw r16 r16: Compare r/m16 with r16.
(instance WriteInst.Cmpw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Cmpw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 3B /r
    (with1 (cmpw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 59 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpw r16 m16: Compare r/m16 with r16.
(instance WriteInst.Cmpw.Gpr16.Memory (forall W Error) (WriteInst W Error (Cmpw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 3B /r
    (with1 (cmpw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 59 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpw m16 r16: Compare r16 with r/m16.
(instance WriteInst.Cmpw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Cmpw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 39 /r
    (with1 (cmpw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 57 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpw r16 imm8: Compare imm8 with r/m16.
(instance WriteInst.Cmpw.Gpr16.I8 (forall W Error) (WriteInst W Error (Cmpw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /7 ib
    (with1 (cmpw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpw m16 imm8: Compare imm8 with r/m16.
(instance WriteInst.Cmpw.Memory.I8 (forall W Error) (WriteInst W Error (Cmpw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /7 ib
    (with1 (cmpw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpw r16 imm16: Compare imm16 with r/m16.
(instance WriteInst.Cmpw.Gpr16.I16 (forall W Error) (WriteInst W Error (Cmpw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /7 iw
    (with1 (cmpw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpw m16 imm16: Compare imm16 with r/m16.
(instance WriteInst.Cmpw.Memory.I16 (forall W Error) (WriteInst W Error (Cmpw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /7 iw
    (with1 (cmpw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; cmpw _Ax imm16: Compare imm16 with AX.
(instance WriteInst.Cmpw.|Ax.I16 (forall W Error) (WriteInst W Error (Cmpw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 3D iw
    (with1 (cmpw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 61 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Cmpxchgb Op0 Op1) (cmpxchgb: Op0 Op1))

; cmpxchgb r8 r8: Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.
(instance WriteInst.Cmpxchgb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Cmpxchgb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B0 /r
    (with1 (cmpxchgb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 176 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpxchgb m8 r8: Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.
(instance WriteInst.Cmpxchgb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Cmpxchgb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B0 /r
    (with1 (cmpxchgb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 176 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cmpxchgl Op0 Op1) (cmpxchgl: Op0 Op1))

; cmpxchgl r32 r32: Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.
(instance WriteInst.Cmpxchgl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Cmpxchgl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B1 /r
    (with1 (cmpxchgl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 177 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpxchgl m32 r32: Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.
(instance WriteInst.Cmpxchgl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Cmpxchgl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B1 /r
    (with1 (cmpxchgl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 177 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cmpxchgq Op0 Op1) (cmpxchgq: Op0 Op1))

; cmpxchgq r64 r64: Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.
(instance WriteInst.Cmpxchgq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Cmpxchgq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F B1 /r
    (with1 (cmpxchgq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 177 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpxchgq m64 r64: Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.
(instance WriteInst.Cmpxchgq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Cmpxchgq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F B1 /r
    (with1 (cmpxchgq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 177 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cmpxchgw Op0 Op1) (cmpxchgw: Op0 Op1))

; cmpxchgw r16 r16: Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.
(instance WriteInst.Cmpxchgw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Cmpxchgw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F B1 /r
    (with1 (cmpxchgw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 177 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cmpxchgw m16 r16: Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.
(instance WriteInst.Cmpxchgw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Cmpxchgw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F B1 /r
    (with1 (cmpxchgw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 177 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Comisd Op0 Op1) (comisd: Op0 Op1))

; comisd xmm xmm: Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
(instance WriteInst.Comisd.Xmm.Xmm (forall W Error) (WriteInst W Error (Comisd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 2F /r
    (with1 (comisd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 47 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; comisd xmm m64: Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.
(instance WriteInst.Comisd.Xmm.Memory (forall W Error) (WriteInst W Error (Comisd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 2F /r
    (with1 (comisd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 47 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Comiss Op0 Op1) (comiss: Op0 Op1))

; comiss xmm xmm: Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
(instance WriteInst.Comiss.Xmm.Xmm (forall W Error) (WriteInst W Error (Comiss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 2F /r
    (with1 (comiss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 47 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; comiss xmm m32: Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.
(instance WriteInst.Comiss.Xmm.Memory (forall W Error) (WriteInst W Error (Comiss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 2F /r
    (with1 (comiss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 47 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Cpuid cpuid:)

; cpuid: Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well).
(instance WriteInst.Cpuid (forall W Error) (WriteInst W Error Cpuid) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F A2
    (with1 cpuid: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 162 w)!
        (ok unit)))))

(value-data Cqto cqto:)

; cqto: RDX:RAX = sign-extend of RAX.
(instance WriteInst.Cqto (forall W Error) (WriteInst W Error Cqto) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 99
    (with1 cqto: inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 153 w)!
        (ok unit)))))

(value-data (Crc32b Op0 Op1) (crc32b: Op0 Op1))

; crc32b r32 r8: Accumulate CRC32 on r/m8.
(instance WriteInst.Crc32b.Gpr32.Gpr8 (forall W Error) (WriteInst W Error (Crc32b Gpr32 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 38 F0 /r
    (with1 (crc32b: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 240 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; crc32b r32 m8: Accumulate CRC32 on r/m8.
(instance WriteInst.Crc32b.Gpr32.Memory (forall W Error) (WriteInst W Error (Crc32b Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 38 F0 /r
    (with1 (crc32b: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 240 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; crc32b r64 r8: Accumulate CRC32 on r/m8.
(instance WriteInst.Crc32b.Gpr64.Gpr8 (forall W Error) (WriteInst W Error (Crc32b Gpr64 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 38 F0 /r
    (with1 (crc32b: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 240 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; crc32b r64 m8: Accumulate CRC32 on r/m8.
(instance WriteInst.Crc32b.Gpr64.Memory (forall W Error) (WriteInst W Error (Crc32b Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 38 F0 /r
    (with1 (crc32b: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 240 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Crc32l Op0 Op1) (crc32l: Op0 Op1))

; crc32l r32 r32: Accumulate CRC32 on r/m32.
(instance WriteInst.Crc32l.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Crc32l Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 38 F1 /r
    (with1 (crc32l: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 241 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; crc32l r32 m32: Accumulate CRC32 on r/m32.
(instance WriteInst.Crc32l.Gpr32.Memory (forall W Error) (WriteInst W Error (Crc32l Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 38 F1 /r
    (with1 (crc32l: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 241 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Crc32q Op0 Op1) (crc32q: Op0 Op1))

; crc32q r64 r64: Accumulate CRC32 on r/m64.
(instance WriteInst.Crc32q.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Crc32q Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 38 F1 /r
    (with1 (crc32q: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 241 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; crc32q r64 m64: Accumulate CRC32 on r/m64.
(instance WriteInst.Crc32q.Gpr64.Memory (forall W Error) (WriteInst W Error (Crc32q Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 38 F1 /r
    (with1 (crc32q: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 241 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Crc32w Op0 Op1) (crc32w: Op0 Op1))

; crc32w r32 r16: Accumulate CRC32 on r/m16.
(instance WriteInst.Crc32w.Gpr32.Gpr16 (forall W Error) (WriteInst W Error (Crc32w Gpr32 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 66 0F 38 F1 /r
    (with1 (crc32w: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 241 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; crc32w r32 m16: Accumulate CRC32 on r/m16.
(instance WriteInst.Crc32w.Gpr32.Memory (forall W Error) (WriteInst W Error (Crc32w Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 66 0F 38 F1 /r
    (with1 (crc32w: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 241 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtdq2pd Op0 Op1) (cvtdq2pd: Op0 Op1))

; cvtdq2pd xmm xmm: Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.
(instance WriteInst.Cvtdq2pd.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvtdq2pd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F E6 /r
    (with1 (cvtdq2pd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 230 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtdq2pd xmm m64: Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.
(instance WriteInst.Cvtdq2pd.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtdq2pd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F E6 /r
    (with1 (cvtdq2pd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 230 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtdq2ps Op0 Op1) (cvtdq2ps: Op0 Op1))

; cvtdq2ps xmm xmm: Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.
(instance WriteInst.Cvtdq2ps.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvtdq2ps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5B /r
    (with1 (cvtdq2ps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 91 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtdq2ps xmm m128: Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.
(instance WriteInst.Cvtdq2ps.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtdq2ps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5B /r
    (with1 (cvtdq2ps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 91 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtpd2dq Op0 Op1) (cvtpd2dq: Op0 Op1))

; cvtpd2dq xmm xmm: Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.
(instance WriteInst.Cvtpd2dq.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvtpd2dq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F E6 /r
    (with1 (cvtpd2dq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 230 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtpd2dq xmm m128: Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1.
(instance WriteInst.Cvtpd2dq.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtpd2dq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F E6 /r
    (with1 (cvtpd2dq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 230 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtpd2ps Op0 Op1) (cvtpd2ps: Op0 Op1))

; cvtpd2ps xmm xmm: Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.
(instance WriteInst.Cvtpd2ps.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvtpd2ps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5A /r
    (with1 (cvtpd2ps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 90 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtpd2ps xmm m128: Convert two packed double-precision floating- point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.
(instance WriteInst.Cvtpd2ps.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtpd2ps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5A /r
    (with1 (cvtpd2ps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 90 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtps2dq Op0 Op1) (cvtps2dq: Op0 Op1))

; cvtps2dq xmm xmm: Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.
(instance WriteInst.Cvtps2dq.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvtps2dq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5B /r
    (with1 (cvtps2dq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 91 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtps2dq xmm m128: Convert four packed single-precision floating- point values from xmm2/m128 to four packed signed doubleword integers in xmm1.
(instance WriteInst.Cvtps2dq.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtps2dq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5B /r
    (with1 (cvtps2dq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 91 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtps2pd Op0 Op1) (cvtps2pd: Op0 Op1))

; cvtps2pd xmm xmm: Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.
(instance WriteInst.Cvtps2pd.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvtps2pd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5A /r
    (with1 (cvtps2pd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 90 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtps2pd xmm m64: Convert two packed single-precision floating- point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.
(instance WriteInst.Cvtps2pd.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtps2pd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5A /r
    (with1 (cvtps2pd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 90 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtsd2si Op0 Op1) (cvtsd2si: Op0 Op1))

; cvtsd2si r32 xmm: Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.
(instance WriteInst.Cvtsd2si.Gpr32.Xmm (forall W Error) (WriteInst W Error (Cvtsd2si Gpr32 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 2D /r
    (with1 (cvtsd2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 45 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtsd2si r32 m64: Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.
(instance WriteInst.Cvtsd2si.Gpr32.Memory (forall W Error) (WriteInst W Error (Cvtsd2si Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 2D /r
    (with1 (cvtsd2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 45 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtsd2si r64 xmm: Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.
(instance WriteInst.Cvtsd2si.Gpr64.Xmm (forall W Error) (WriteInst W Error (Cvtsd2si Gpr64 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 2D /r
    (with1 (cvtsd2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 45 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtsd2si r64 m64: Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.
(instance WriteInst.Cvtsd2si.Gpr64.Memory (forall W Error) (WriteInst W Error (Cvtsd2si Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 2D /r
    (with1 (cvtsd2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 45 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtsd2ss Op0 Op1) (cvtsd2ss: Op0 Op1))

; cvtsd2ss xmm xmm: Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.
(instance WriteInst.Cvtsd2ss.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvtsd2ss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5A /r
    (with1 (cvtsd2ss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 90 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtsd2ss xmm m64: Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.
(instance WriteInst.Cvtsd2ss.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtsd2ss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5A /r
    (with1 (cvtsd2ss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 90 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtsi2sdl Op0 Op1) (cvtsi2sdl: Op0 Op1))

; cvtsi2sdl xmm r32: Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.
(instance WriteInst.Cvtsi2sdl.Xmm.Gpr32 (forall W Error) (WriteInst W Error (Cvtsi2sdl Xmm Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 2A /r
    (with1 (cvtsi2sdl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtsi2sdl xmm m32: Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.
(instance WriteInst.Cvtsi2sdl.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtsi2sdl Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 2A /r
    (with1 (cvtsi2sdl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtsi2sdq Op0 Op1) (cvtsi2sdq: Op0 Op1))

; cvtsi2sdq xmm r64: Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.
(instance WriteInst.Cvtsi2sdq.Xmm.Gpr64 (forall W Error) (WriteInst W Error (Cvtsi2sdq Xmm Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 2A /r
    (with1 (cvtsi2sdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtsi2sdq xmm m64: Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.
(instance WriteInst.Cvtsi2sdq.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtsi2sdq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 2A /r
    (with1 (cvtsi2sdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtsi2ssl Op0 Op1) (cvtsi2ssl: Op0 Op1))

; cvtsi2ssl xmm r32: Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.
(instance WriteInst.Cvtsi2ssl.Xmm.Gpr32 (forall W Error) (WriteInst W Error (Cvtsi2ssl Xmm Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 2A /r
    (with1 (cvtsi2ssl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtsi2ssl xmm m32: Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.
(instance WriteInst.Cvtsi2ssl.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtsi2ssl Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 2A /r
    (with1 (cvtsi2ssl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtsi2ssq Op0 Op1) (cvtsi2ssq: Op0 Op1))

; cvtsi2ssq xmm r64: Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.
(instance WriteInst.Cvtsi2ssq.Xmm.Gpr64 (forall W Error) (WriteInst W Error (Cvtsi2ssq Xmm Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 REX.W+ 0F 2A /r
    (with1 (cvtsi2ssq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtsi2ssq xmm m64: Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.
(instance WriteInst.Cvtsi2ssq.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtsi2ssq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 REX.W+ 0F 2A /r
    (with1 (cvtsi2ssq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtss2sd Op0 Op1) (cvtss2sd: Op0 Op1))

; cvtss2sd xmm xmm: Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.
(instance WriteInst.Cvtss2sd.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvtss2sd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5A /r
    (with1 (cvtss2sd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 90 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtss2sd xmm m32: Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.
(instance WriteInst.Cvtss2sd.Xmm.Memory (forall W Error) (WriteInst W Error (Cvtss2sd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5A /r
    (with1 (cvtss2sd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 90 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvtss2si Op0 Op1) (cvtss2si: Op0 Op1))

; cvtss2si r32 xmm: Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.
(instance WriteInst.Cvtss2si.Gpr32.Xmm (forall W Error) (WriteInst W Error (Cvtss2si Gpr32 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 2D /r
    (with1 (cvtss2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 45 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtss2si r32 m32: Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.
(instance WriteInst.Cvtss2si.Gpr32.Memory (forall W Error) (WriteInst W Error (Cvtss2si Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 2D /r
    (with1 (cvtss2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 45 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtss2si r64 xmm: Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.
(instance WriteInst.Cvtss2si.Gpr64.Xmm (forall W Error) (WriteInst W Error (Cvtss2si Gpr64 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 REX.W+ 0F 2D /r
    (with1 (cvtss2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 45 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvtss2si r64 m32: Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.
(instance WriteInst.Cvtss2si.Gpr64.Memory (forall W Error) (WriteInst W Error (Cvtss2si Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 REX.W+ 0F 2D /r
    (with1 (cvtss2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 45 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvttpd2dq Op0 Op1) (cvttpd2dq: Op0 Op1))

; cvttpd2dq xmm xmm: Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.
(instance WriteInst.Cvttpd2dq.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvttpd2dq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E6 /r
    (with1 (cvttpd2dq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 230 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvttpd2dq xmm m128: Convert two packed double-precision floating- point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.
(instance WriteInst.Cvttpd2dq.Xmm.Memory (forall W Error) (WriteInst W Error (Cvttpd2dq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E6 /r
    (with1 (cvttpd2dq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 230 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvttps2dq Op0 Op1) (cvttps2dq: Op0 Op1))

; cvttps2dq xmm xmm: Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.
(instance WriteInst.Cvttps2dq.Xmm.Xmm (forall W Error) (WriteInst W Error (Cvttps2dq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5B /r
    (with1 (cvttps2dq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 91 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvttps2dq xmm m128: Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.
(instance WriteInst.Cvttps2dq.Xmm.Memory (forall W Error) (WriteInst W Error (Cvttps2dq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5B /r
    (with1 (cvttps2dq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 91 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvttsd2si Op0 Op1) (cvttsd2si: Op0 Op1))

; cvttsd2si r32 xmm: Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.
(instance WriteInst.Cvttsd2si.Gpr32.Xmm (forall W Error) (WriteInst W Error (Cvttsd2si Gpr32 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 2C /r
    (with1 (cvttsd2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 44 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvttsd2si r32 m64: Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.
(instance WriteInst.Cvttsd2si.Gpr32.Memory (forall W Error) (WriteInst W Error (Cvttsd2si Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 2C /r
    (with1 (cvttsd2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 44 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvttsd2si r64 xmm: Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.
(instance WriteInst.Cvttsd2si.Gpr64.Xmm (forall W Error) (WriteInst W Error (Cvttsd2si Gpr64 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 2C /r
    (with1 (cvttsd2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 44 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvttsd2si r64 m64: Convert one double precision floating-point value from xmm/m64 to one signedquadword integer in r64 using truncation.
(instance WriteInst.Cvttsd2si.Gpr64.Memory (forall W Error) (WriteInst W Error (Cvttsd2si Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 REX.W+ 0F 2C /r
    (with1 (cvttsd2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 44 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Cvttss2si Op0 Op1) (cvttss2si: Op0 Op1))

; cvttss2si r32 xmm: Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.
(instance WriteInst.Cvttss2si.Gpr32.Xmm (forall W Error) (WriteInst W Error (Cvttss2si Gpr32 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 2C /r
    (with1 (cvttss2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 44 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvttss2si r32 m32: Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.
(instance WriteInst.Cvttss2si.Gpr32.Memory (forall W Error) (WriteInst W Error (Cvttss2si Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 2C /r
    (with1 (cvttss2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 44 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvttss2si r64 xmm: Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.
(instance WriteInst.Cvttss2si.Gpr64.Xmm (forall W Error) (WriteInst W Error (Cvttss2si Gpr64 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 REX.W+ 0F 2C /r
    (with1 (cvttss2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 44 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; cvttss2si r64 m32: Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.
(instance WriteInst.Cvttss2si.Gpr64.Memory (forall W Error) (WriteInst W Error (Cvttss2si Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 REX.W+ 0F 2C /r
    (with1 (cvttss2si: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 44 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Cwtd cwtd:)

; cwtd: DX:AX = sign-extend of AX.
(instance WriteInst.Cwtd (forall W Error) (WriteInst W Error Cwtd) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 99
    (with1 cwtd: inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 153 w)!
        (ok unit)))))

(value-data Cwtl cwtl:)

; cwtl: EAX = sign-extend of AX.
(instance WriteInst.Cwtl (forall W Error) (WriteInst W Error Cwtl) (where (Write W Error))
  (function (write-inst! w inst)
    ; 98
    (with1 cwtl: inst
      (let ()
        (write-u8! 152 w)!
        (ok unit)))))

(value-data (Decb Op0) (decb: Op0))

; decb r8: Decrement r/m8 by 1.
(instance WriteInst.Decb.Gpr8 (forall W Error) (WriteInst W Error (Decb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FE /1
    (with1 (decb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 254 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; decb m8: Decrement r/m8 by 1.
(instance WriteInst.Decb.Memory (forall W Error) (WriteInst W Error (Decb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FE /1
    (with1 (decb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 254 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Decl Op0) (decl: Op0))

; decl r32: Decrement r/m32 by 1.
(instance WriteInst.Decl.Gpr32 (forall W Error) (WriteInst W Error (Decl Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /1
    (with1 (decl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; decl m32: Decrement r/m32 by 1.
(instance WriteInst.Decl.Memory (forall W Error) (WriteInst W Error (Decl Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /1
    (with1 (decl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Decq Op0) (decq: Op0))

; decq r64: Decrement r/m64 by 1.
(instance WriteInst.Decq.Gpr64 (forall W Error) (WriteInst W Error (Decq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ FF /1
    (with1 (decq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; decq m64: Decrement r/m64 by 1.
(instance WriteInst.Decq.Memory (forall W Error) (WriteInst W Error (Decq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ FF /1
    (with1 (decq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Decw Op0) (decw: Op0))

; decw r16: Decrement r/m16 by 1.
(instance WriteInst.Decw.Gpr16 (forall W Error) (WriteInst W Error (Decw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 FF /1
    (with1 (decw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; decw m16: Decrement r/m16 by 1.
(instance WriteInst.Decw.Memory (forall W Error) (WriteInst W Error (Decw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 FF /1
    (with1 (decw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Divb Op0) (divb: Op0))

; divb r8: Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
(instance WriteInst.Divb.Gpr8 (forall W Error) (WriteInst W Error (Divb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /6
    (with1 (divb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; divb m8: Unsigned divide AX by r/m8, with result stored in AL = Quotient, AH = Remainder.
(instance WriteInst.Divb.Memory (forall W Error) (WriteInst W Error (Divb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /6
    (with1 (divb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Divl Op0) (divl: Op0))

; divl r32: Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
(instance WriteInst.Divl.Gpr32 (forall W Error) (WriteInst W Error (Divl Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /6
    (with1 (divl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; divl m32: Unsigned divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
(instance WriteInst.Divl.Memory (forall W Error) (WriteInst W Error (Divl Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /6
    (with1 (divl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Divpd Op0 Op1) (divpd: Op0 Op1))

; divpd xmm xmm: Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.
(instance WriteInst.Divpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Divpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5E /r
    (with1 (divpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 94 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; divpd xmm m128: Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values xmm2/m128.
(instance WriteInst.Divpd.Xmm.Memory (forall W Error) (WriteInst W Error (Divpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5E /r
    (with1 (divpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 94 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Divps Op0 Op1) (divps: Op0 Op1))

; divps xmm xmm: Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.
(instance WriteInst.Divps.Xmm.Xmm (forall W Error) (WriteInst W Error (Divps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5E /r
    (with1 (divps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 94 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; divps xmm m128: Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values xmm2/m128.
(instance WriteInst.Divps.Xmm.Memory (forall W Error) (WriteInst W Error (Divps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5E /r
    (with1 (divps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 94 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Divq Op0) (divq: Op0))

; divq r64: Unsigned divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
(instance WriteInst.Divq.Gpr64 (forall W Error) (WriteInst W Error (Divq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /6
    (with1 (divq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; divq m64: Unsigned divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
(instance WriteInst.Divq.Memory (forall W Error) (WriteInst W Error (Divq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /6
    (with1 (divq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Divsd Op0 Op1) (divsd: Op0 Op1))

; divsd xmm xmm: Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.
(instance WriteInst.Divsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Divsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5E /r
    (with1 (divsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 94 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; divsd xmm m64: Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/mem64.
(instance WriteInst.Divsd.Xmm.Memory (forall W Error) (WriteInst W Error (Divsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5E /r
    (with1 (divsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 94 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Divss Op0 Op1) (divss: Op0 Op1))

; divss xmm xmm: Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.
(instance WriteInst.Divss.Xmm.Xmm (forall W Error) (WriteInst W Error (Divss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5E /r
    (with1 (divss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 94 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; divss xmm m32: Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32.
(instance WriteInst.Divss.Xmm.Memory (forall W Error) (WriteInst W Error (Divss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5E /r
    (with1 (divss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 94 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Divw Op0) (divw: Op0))

; divw r16: Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
(instance WriteInst.Divw.Gpr16 (forall W Error) (WriteInst W Error (Divw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /6
    (with1 (divw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; divw m16: Unsigned divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
(instance WriteInst.Divw.Memory (forall W Error) (WriteInst W Error (Divw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /6
    (with1 (divw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Dppd Op0 Op1 Op2) (dppd: Op0 Op1 Op2))

; dppd xmm xmm imm8: Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.
(instance WriteInst.Dppd.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Dppd Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 41 /r ib
    (with1 (dppd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 65 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; dppd xmm m128 imm8: Selectively multiply packed DP floating-point values from xmm1 with packed DP floating- point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.
(instance WriteInst.Dppd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Dppd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 41 /r ib
    (with1 (dppd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 65 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Dpps Op0 Op1 Op2) (dpps: Op0 Op1 Op2))

; dpps xmm xmm imm8: Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.
(instance WriteInst.Dpps.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Dpps Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 40 /r ib
    (with1 (dpps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 64 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; dpps xmm m128 imm8: Selectively multiply packed SP floating-point values from xmm1 with packed SP floating- point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.
(instance WriteInst.Dpps.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Dpps Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 40 /r ib
    (with1 (dpps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 64 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data Emms emms:)

; emms: Set the x87 FPU tag word to empty.
(instance WriteInst.Emms (forall W Error) (WriteInst W Error Emms) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 77
    (with1 emms: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 119 w)!
        (ok unit)))))

(value-data (Extractps Op0 Op1 Op2) (extractps: Op0 Op1 Op2))

; extractps reg xmm imm8: Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.
(instance WriteInst.Extractps.Gpr64.Xmm.I8 (forall W Error) (WriteInst W Error (Extractps Gpr64 Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 17 /r ib
    (with1 (extractps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 23 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; extractps m32 xmm imm8: Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.
(instance WriteInst.Extractps.Memory.Xmm.I8 (forall W Error) (WriteInst W Error (Extractps Memory Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 17 /r ib
    (with1 (extractps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 23 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data Hlt hlt:)

; hlt: Halt
(instance WriteInst.Hlt (forall W Error) (WriteInst W Error Hlt) (where (Write W Error))
  (function (write-inst! w inst)
    ; F4
    (with1 hlt: inst
      (let ()
        (write-u8! 244 w)!
        (ok unit)))))

(value-data (Idivb Op0) (idivb: Op0))

; idivb r8: Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.
(instance WriteInst.Idivb.Gpr8 (forall W Error) (WriteInst W Error (Idivb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /7
    (with1 (idivb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; idivb m8: Signed divide AX by r/m8, with result stored in: AL = Quotient, AH = Remainder.
(instance WriteInst.Idivb.Memory (forall W Error) (WriteInst W Error (Idivb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /7
    (with1 (idivb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Idivl Op0) (idivl: Op0))

; idivl r32: Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
(instance WriteInst.Idivl.Gpr32 (forall W Error) (WriteInst W Error (Idivl Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /7
    (with1 (idivl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; idivl m32: Signed divide EDX:EAX by r/m32, with result stored in EAX = Quotient, EDX = Remainder.
(instance WriteInst.Idivl.Memory (forall W Error) (WriteInst W Error (Idivl Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /7
    (with1 (idivl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Idivq Op0) (idivq: Op0))

; idivq r64: Signed divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
(instance WriteInst.Idivq.Gpr64 (forall W Error) (WriteInst W Error (Idivq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /7
    (with1 (idivq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; idivq m64: Signed divide RDX:RAX by r/m64, with result stored in RAX = Quotient, RDX = Remainder.
(instance WriteInst.Idivq.Memory (forall W Error) (WriteInst W Error (Idivq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /7
    (with1 (idivq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Idivw Op0) (idivw: Op0))

; idivw r16: Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
(instance WriteInst.Idivw.Gpr16 (forall W Error) (WriteInst W Error (Idivw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /7
    (with1 (idivw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; idivw m16: Signed divide DX:AX by r/m16, with result stored in AX = Quotient, DX = Remainder.
(instance WriteInst.Idivw.Memory (forall W Error) (WriteInst W Error (Idivw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /7
    (with1 (idivw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Imulb Op0) (imulb: Op0))

; imulb r8: AX= AL * r/m byte.
(instance WriteInst.Imulb.Gpr8 (forall W Error) (WriteInst W Error (Imulb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /5
    (with1 (imulb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; imulb m8: AX= AL * r/m byte.
(instance WriteInst.Imulb.Memory (forall W Error) (WriteInst W Error (Imulb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /5
    (with1 (imulb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Imull Op0 Op1 Op2) (imull: Op0 Op1 Op2))

; imull r32 r32 imm8: doubleword register = r/m32 * sign- extended immediate byte.
(instance WriteInst.Imull.Gpr32.Gpr32.I8 (forall W Error) (WriteInst W Error (Imull Gpr32 Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 6B /r ib
    (with1 (imull: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 107 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imull r32 m32 imm8: doubleword register = r/m32 * sign- extended immediate byte.
(instance WriteInst.Imull.Gpr32.Memory.I8 (forall W Error) (WriteInst W Error (Imull Gpr32 Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 6B /r ib
    (with1 (imull: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 107 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imull r32 r32 imm32: doubleword register = r/m32 * immediate doubleword.
(instance WriteInst.Imull.Gpr32.Gpr32.I32 (forall W Error) (WriteInst W Error (Imull Gpr32 Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 69 /r id
    (with1 (imull: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 105 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imull r32 m32 imm32: doubleword register = r/m32 * immediate doubleword.
(instance WriteInst.Imull.Gpr32.Memory.I32 (forall W Error) (WriteInst W Error (Imull Gpr32 Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 69 /r id
    (with1 (imull: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 105 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Imull1 Op0) (imull1: Op0))

; imull r32: EDX:EAX = EAX * r/m32.
(instance WriteInst.Imull1.Gpr32 (forall W Error) (WriteInst W Error (Imull1 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /5
    (with1 (imull1: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; imull m32: EDX:EAX = EAX * r/m32.
(instance WriteInst.Imull1.Memory (forall W Error) (WriteInst W Error (Imull1 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /5
    (with1 (imull1: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Imull2 Op0 Op1) (imull2: Op0 Op1))

; imull r32 r32: doubleword register = doubleword register *  r/m32.
(instance WriteInst.Imull2.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Imull2 Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AF /r
    (with1 (imull2: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 175 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; imull r32 m32: doubleword register = doubleword register *  r/m32.
(instance WriteInst.Imull2.Gpr32.Memory (forall W Error) (WriteInst W Error (Imull2 Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AF /r
    (with1 (imull2: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 175 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Imulq Op0 Op1 Op2) (imulq: Op0 Op1 Op2))

; imulq r64 r64 imm8: Quadword register = r/m64 * sign-extended  immediate byte.
(instance WriteInst.Imulq.Gpr64.Gpr64.I8 (forall W Error) (WriteInst W Error (Imulq Gpr64 Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 6B /r ib
    (with1 (imulq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 107 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imulq r64 m64 imm8: Quadword register = r/m64 * sign-extended  immediate byte.
(instance WriteInst.Imulq.Gpr64.Memory.I8 (forall W Error) (WriteInst W Error (Imulq Gpr64 Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 6B /r ib
    (with1 (imulq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 107 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imulq r64 r64 imm32: Quadword register = r/m64 * immediate doubleword.
(instance WriteInst.Imulq.Gpr64.Gpr64.I32 (forall W Error) (WriteInst W Error (Imulq Gpr64 Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 69 /r id
    (with1 (imulq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 105 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imulq r64 m64 imm32: Quadword register = r/m64 * immediate doubleword.
(instance WriteInst.Imulq.Gpr64.Memory.I32 (forall W Error) (WriteInst W Error (Imulq Gpr64 Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 69 /r id
    (with1 (imulq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 105 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Imulq1 Op0) (imulq1: Op0))

; imulq r64: RDX:RAX = RAX * r/m64.
(instance WriteInst.Imulq1.Gpr64 (forall W Error) (WriteInst W Error (Imulq1 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /5
    (with1 (imulq1: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; imulq m64: RDX:RAX = RAX * r/m64.
(instance WriteInst.Imulq1.Memory (forall W Error) (WriteInst W Error (Imulq1 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /5
    (with1 (imulq1: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Imulq2 Op0 Op1) (imulq2: Op0 Op1))

; imulq r64 r64: Quadword register = Quadword register *  r/m64.
(instance WriteInst.Imulq2.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Imulq2 Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F AF /r
    (with1 (imulq2: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 175 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; imulq r64 m64: Quadword register = Quadword register *  r/m64.
(instance WriteInst.Imulq2.Gpr64.Memory (forall W Error) (WriteInst W Error (Imulq2 Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F AF /r
    (with1 (imulq2: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 175 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Imulw Op0 Op1 Op2) (imulw: Op0 Op1 Op2))

; imulw r16 r16 imm8: word register = r/m16 * sign-extended immediate byte.
(instance WriteInst.Imulw.Gpr16.Gpr16.I8 (forall W Error) (WriteInst W Error (Imulw Gpr16 Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 6B /r ib
    (with1 (imulw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 107 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imulw r16 m16 imm8: word register = r/m16 * sign-extended immediate byte.
(instance WriteInst.Imulw.Gpr16.Memory.I8 (forall W Error) (WriteInst W Error (Imulw Gpr16 Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 6B /r ib
    (with1 (imulw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 107 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imulw r16 r16 imm16: word register = r/m16 * immediate word.
(instance WriteInst.Imulw.Gpr16.Gpr16.I16 (forall W Error) (WriteInst W Error (Imulw Gpr16 Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 69 /r iw
    (with1 (imulw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 105 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; imulw r16 m16 imm16: word register = r/m16 * immediate word.
(instance WriteInst.Imulw.Gpr16.Memory.I16 (forall W Error) (WriteInst W Error (Imulw Gpr16 Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 69 /r iw
    (with1 (imulw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 105 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Imulw1 Op0) (imulw1: Op0))

; imulw r16: DX:AX = AX * r/m word.
(instance WriteInst.Imulw1.Gpr16 (forall W Error) (WriteInst W Error (Imulw1 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /5
    (with1 (imulw1: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; imulw m16: DX:AX = AX * r/m word.
(instance WriteInst.Imulw1.Memory (forall W Error) (WriteInst W Error (Imulw1 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /5
    (with1 (imulw1: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Imulw2 Op0 Op1) (imulw2: Op0 Op1))

; imulw r16 r16: word register = word register * r/m16.
(instance WriteInst.Imulw2.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Imulw2 Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F AF /r
    (with1 (imulw2: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 175 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; imulw r16 m16: word register = word register * r/m16.
(instance WriteInst.Imulw2.Gpr16.Memory (forall W Error) (WriteInst W Error (Imulw2 Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F AF /r
    (with1 (imulw2: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 175 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Inb Op0 Op1) (inb: Op0 Op1))

; inb _Al imm8: Input byte from imm8 I/O port address into AL.
(instance WriteInst.Inb.|Al.I8 (forall W Error) (WriteInst W Error (Inb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; E4 ib
    (with1 (inb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 228 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; inb _Al _Dx: Input byte from I/O port in DX into AL.
(instance WriteInst.Inb.|Al.|Dx (forall W Error) (WriteInst W Error (Inb |Al |Dx)) (where (Write W Error))
  (function (write-inst! w inst)
    ; EC
    (with1 (inb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 236 w)!
        (ok unit)))))

(value-data (Incb Op0) (incb: Op0))

; incb r8: Increment r/m byte by 1.
(instance WriteInst.Incb.Gpr8 (forall W Error) (WriteInst W Error (Incb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FE /0
    (with1 (incb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 254 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; incb m8: Increment r/m byte by 1.
(instance WriteInst.Incb.Memory (forall W Error) (WriteInst W Error (Incb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FE /0
    (with1 (incb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 254 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Incl Op0) (incl: Op0))

; incl r32: Increment r/m doubleword by 1.
(instance WriteInst.Incl.Gpr32 (forall W Error) (WriteInst W Error (Incl Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /0
    (with1 (incl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; incl m32: Increment r/m doubleword by 1.
(instance WriteInst.Incl.Memory (forall W Error) (WriteInst W Error (Incl Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /0
    (with1 (incl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Incq Op0) (incq: Op0))

; incq r64: Increment r/m quadword by 1.
(instance WriteInst.Incq.Gpr64 (forall W Error) (WriteInst W Error (Incq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ FF /0
    (with1 (incq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; incq m64: Increment r/m quadword by 1.
(instance WriteInst.Incq.Memory (forall W Error) (WriteInst W Error (Incq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ FF /0
    (with1 (incq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Incw Op0) (incw: Op0))

; incw r16: Increment r/m word by 1.
(instance WriteInst.Incw.Gpr16 (forall W Error) (WriteInst W Error (Incw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 FF /0
    (with1 (incw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; incw m16: Increment r/m word by 1.
(instance WriteInst.Incw.Memory (forall W Error) (WriteInst W Error (Incw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 FF /0
    (with1 (incw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Inl Op0 Op1) (inl: Op0 Op1))

; inl _Eax imm8: Input dword from imm8 I/O port address into EAX.
(instance WriteInst.Inl.|Eax.I8 (forall W Error) (WriteInst W Error (Inl |Eax I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; E5 ib
    (with1 (inl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 229 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; inl _Eax _Dx: Input doubleword from I/O port in DX into EAX.
(instance WriteInst.Inl.|Eax.|Dx (forall W Error) (WriteInst W Error (Inl |Eax |Dx)) (where (Write W Error))
  (function (write-inst! w inst)
    ; ED
    (with1 (inl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 237 w)!
        (ok unit)))))

(value-data (Insertps Op0 Op1 Op2) (insertps: Op0 Op1 Op2))

; insertps xmm xmm imm8: Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
(instance WriteInst.Insertps.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Insertps Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 21 /r ib
    (with1 (insertps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 33 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; insertps xmm m32 imm8: Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.
(instance WriteInst.Insertps.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Insertps Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 21 /r ib
    (with1 (insertps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 33 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Int Op0) (int: Op0))

; int imm8: Interrupt vector number specified by immediate byte.
(instance WriteInst.Int.I8 (forall W Error) (WriteInst W Error (Int I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; CD ib
    (with1 (int: (let op0)) inst
      (let ()
        (write-u8! 205 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; int _3: Interrupt 3-trap to debugger.
(instance WriteInst.Int.|3 (forall W Error) (WriteInst W Error (Int |3)) (where (Write W Error))
  (function (write-inst! w inst)
    ; CC
    (with1 (int: (let op0)) inst
      (let ()
        (write-u8! 204 w)!
        (ok unit)))))

(value-data Invd invd:)

; invd: Flush internal caches; initiate flushing of external caches.
(instance WriteInst.Invd (forall W Error) (WriteInst W Error Invd) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 08
    (with1 invd: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 8 w)!
        (ok unit)))))

(value-data (Invlpg Op0) (invlpg: Op0))

; invlpg m: Invalidate TLB Entry for page that contains m.
(instance WriteInst.Invlpg.Memory (forall W Error) (WriteInst W Error (Invlpg Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 01 /7
    (with1 (invlpg: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 1 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Inw Op0 Op1) (inw: Op0 Op1))

; inw _Ax imm8: Input word from imm8 I/O port address into AX.
(instance WriteInst.Inw.|Ax.I8 (forall W Error) (WriteInst W Error (Inw |Ax I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 E5 ib
    (with1 (inw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 229 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; inw _Ax _Dx: Input word from I/O port in DX into AX.
(instance WriteInst.Inw.|Ax.|Dx (forall W Error) (WriteInst W Error (Inw |Ax |Dx)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 ED
    (with1 (inw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 237 w)!
        (ok unit)))))

(value-data Iretl iretl:)

; iretl: Interrupt return (32-bit operand size).
(instance WriteInst.Iretl (forall W Error) (WriteInst W Error Iretl) (where (Write W Error))
  (function (write-inst! w inst)
    ; CF
    (with1 iretl: inst
      (let ()
        (write-u8! 207 w)!
        (ok unit)))))

(value-data Iretq iretq:)

; iretq: Interrupt return (64-bit operand size).
(instance WriteInst.Iretq (forall W Error) (WriteInst W Error Iretq) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ CF
    (with1 iretq: inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 207 w)!
        (ok unit)))))

(value-data Iretw iretw:)

; iretw: Interrupt return (16-bit operand size).
(instance WriteInst.Iretw (forall W Error) (WriteInst W Error Iretw) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 CF
    (with1 iretw: inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 207 w)!
        (ok unit)))))

(value-data (Ja Op0) (ja: Op0))

; ja rel8: Jump short if above (CF=0 and ZF=0).
(instance WriteInst.Ja.I8 (forall W Error) (WriteInst W Error (Ja I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 77 cb
    (with1 (ja: (let op0)) inst
      (let ()
        (write-u8! 119 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; ja rel32: Jump near if above (CF=0 and ZF=0).
(instance WriteInst.Ja.I32 (forall W Error) (WriteInst W Error (Ja I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 87 cd
    (with1 (ja: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 135 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jae Op0) (jae: Op0))

; jae rel8: Jump short if above or equal (CF=0).
(instance WriteInst.Jae.I8 (forall W Error) (WriteInst W Error (Jae I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 73 cb
    (with1 (jae: (let op0)) inst
      (let ()
        (write-u8! 115 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jae rel32: Jump near if above or equal (CF=0).
(instance WriteInst.Jae.I32 (forall W Error) (WriteInst W Error (Jae I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 83 cd
    (with1 (jae: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 131 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jb Op0) (jb: Op0))

; jb rel8: Jump short if below (CF=1).
(instance WriteInst.Jb.I8 (forall W Error) (WriteInst W Error (Jb I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 72 cb
    (with1 (jb: (let op0)) inst
      (let ()
        (write-u8! 114 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jb rel32: Jump near if below (CF=1).
(instance WriteInst.Jb.I32 (forall W Error) (WriteInst W Error (Jb I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 82 cd
    (with1 (jb: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 130 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jbe Op0) (jbe: Op0))

; jbe rel8: Jump short if below or equal (CF=1 or ZF=1).
(instance WriteInst.Jbe.I8 (forall W Error) (WriteInst W Error (Jbe I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 76 cb
    (with1 (jbe: (let op0)) inst
      (let ()
        (write-u8! 118 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jbe rel32: Jump near if below or equal (CF=1 or ZF=1).
(instance WriteInst.Jbe.I32 (forall W Error) (WriteInst W Error (Jbe I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 86 cd
    (with1 (jbe: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 134 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jc Op0) (jc: Op0))

; jc rel8: Jump short if carry (CF=1).
(instance WriteInst.Jc.I8 (forall W Error) (WriteInst W Error (Jc I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 72 cb
    (with1 (jc: (let op0)) inst
      (let ()
        (write-u8! 114 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jc rel32: Jump near if carry (CF=1).
(instance WriteInst.Jc.I32 (forall W Error) (WriteInst W Error (Jc I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 82 cd
    (with1 (jc: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 130 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Je Op0) (je: Op0))

; je rel8: Jump short if equal (ZF=1).
(instance WriteInst.Je.I8 (forall W Error) (WriteInst W Error (Je I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 74 cb
    (with1 (je: (let op0)) inst
      (let ()
        (write-u8! 116 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; je rel32: Jump near if 0 (ZF=1).
(instance WriteInst.Je.I32 (forall W Error) (WriteInst W Error (Je I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 84 cd
    (with1 (je: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 132 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jecxz Op0) (jecxz: Op0))

; jecxz rel8: Jump short if ECX register is 0.
(instance WriteInst.Jecxz.I8 (forall W Error) (WriteInst W Error (Jecxz I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; E3 cb
    (with1 (jecxz: (let op0)) inst
      (let ()
        (write-u8! 227 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jg Op0) (jg: Op0))

; jg rel8: Jump short if greater (ZF=0 and SF=OF).
(instance WriteInst.Jg.I8 (forall W Error) (WriteInst W Error (Jg I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7F cb
    (with1 (jg: (let op0)) inst
      (let ()
        (write-u8! 127 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jg rel32: Jump near if greater (ZF=0 and SF=OF).
(instance WriteInst.Jg.I32 (forall W Error) (WriteInst W Error (Jg I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8F cd
    (with1 (jg: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 143 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jge Op0) (jge: Op0))

; jge rel8: Jump short if greater or equal (SF=OF).
(instance WriteInst.Jge.I8 (forall W Error) (WriteInst W Error (Jge I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7D cb
    (with1 (jge: (let op0)) inst
      (let ()
        (write-u8! 125 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jge rel32: Jump near if greater or equal (SF=OF).
(instance WriteInst.Jge.I32 (forall W Error) (WriteInst W Error (Jge I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8D cd
    (with1 (jge: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 141 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jl Op0) (jl: Op0))

; jl rel8: Jump short if less (SF!= OF).
(instance WriteInst.Jl.I8 (forall W Error) (WriteInst W Error (Jl I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7C cb
    (with1 (jl: (let op0)) inst
      (let ()
        (write-u8! 124 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jl rel32: Jump near if less (SF!= OF).
(instance WriteInst.Jl.I32 (forall W Error) (WriteInst W Error (Jl I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8C cd
    (with1 (jl: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 140 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jle Op0) (jle: Op0))

; jle rel8: Jump short if less or equal (ZF=1 or SF!= OF).
(instance WriteInst.Jle.I8 (forall W Error) (WriteInst W Error (Jle I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7E cb
    (with1 (jle: (let op0)) inst
      (let ()
        (write-u8! 126 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jle rel32: Jump near if less or equal (ZF=1 or SF!= OF).
(instance WriteInst.Jle.I32 (forall W Error) (WriteInst W Error (Jle I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8E cd
    (with1 (jle: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 142 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jmpq Op0) (jmpq: Op0))

; jmpq rel8: Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits
(instance WriteInst.Jmpq.I8 (forall W Error) (WriteInst W Error (Jmpq I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; EB cb
    (with1 (jmpq: (let op0)) inst
      (let ()
        (write-u8! 235 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jmpq rel32: Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits
(instance WriteInst.Jmpq.I32 (forall W Error) (WriteInst W Error (Jmpq I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; E9 cd
    (with1 (jmpq: (let op0)) inst
      (let ()
        (write-u8! 233 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jmpq r64: Jump near, absolute indirect, RIP = 64-Bit offset from register or memory
(instance WriteInst.Jmpq.Gpr64 (forall W Error) (WriteInst W Error (Jmpq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /4
    (with1 (jmpq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; jmpq m64: Jump near, absolute indirect, RIP = 64-Bit offset from register or memory
(instance WriteInst.Jmpq.Memory (forall W Error) (WriteInst W Error (Jmpq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /4
    (with1 (jmpq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Jna Op0) (jna: Op0))

; jna rel8: Jump short if not above (CF=1 or ZF=1).
(instance WriteInst.Jna.I8 (forall W Error) (WriteInst W Error (Jna I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 76 cb
    (with1 (jna: (let op0)) inst
      (let ()
        (write-u8! 118 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jna rel32: Jump near if not above (CF=1 or ZF=1).
(instance WriteInst.Jna.I32 (forall W Error) (WriteInst W Error (Jna I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 86 cd
    (with1 (jna: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 134 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnae Op0) (jnae: Op0))

; jnae rel8: Jump short if not above or equal (CF=1).
(instance WriteInst.Jnae.I8 (forall W Error) (WriteInst W Error (Jnae I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 72 cb
    (with1 (jnae: (let op0)) inst
      (let ()
        (write-u8! 114 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnae rel32: Jump near if not above or equal (CF=1).
(instance WriteInst.Jnae.I32 (forall W Error) (WriteInst W Error (Jnae I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 82 cd
    (with1 (jnae: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 130 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnb Op0) (jnb: Op0))

; jnb rel8: Jump short if not below (CF=0).
(instance WriteInst.Jnb.I8 (forall W Error) (WriteInst W Error (Jnb I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 73 cb
    (with1 (jnb: (let op0)) inst
      (let ()
        (write-u8! 115 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnb rel32: Jump near if not below (CF=0).
(instance WriteInst.Jnb.I32 (forall W Error) (WriteInst W Error (Jnb I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 83 cd
    (with1 (jnb: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 131 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnbe Op0) (jnbe: Op0))

; jnbe rel8: Jump short if not below or equal (CF=0 and ZF=0).
(instance WriteInst.Jnbe.I8 (forall W Error) (WriteInst W Error (Jnbe I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 77 cb
    (with1 (jnbe: (let op0)) inst
      (let ()
        (write-u8! 119 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnbe rel32: Jump near if not below or equal (CF=0 and ZF=0).
(instance WriteInst.Jnbe.I32 (forall W Error) (WriteInst W Error (Jnbe I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 87 cd
    (with1 (jnbe: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 135 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnc Op0) (jnc: Op0))

; jnc rel8: Jump short if not carry (CF=0).
(instance WriteInst.Jnc.I8 (forall W Error) (WriteInst W Error (Jnc I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 73 cb
    (with1 (jnc: (let op0)) inst
      (let ()
        (write-u8! 115 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnc rel32: Jump near if not carry (CF=0).
(instance WriteInst.Jnc.I32 (forall W Error) (WriteInst W Error (Jnc I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 83 cd
    (with1 (jnc: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 131 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jne Op0) (jne: Op0))

; jne rel8: Jump short if not equal (ZF=0).
(instance WriteInst.Jne.I8 (forall W Error) (WriteInst W Error (Jne I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 75 cb
    (with1 (jne: (let op0)) inst
      (let ()
        (write-u8! 117 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jne rel32: Jump near if not equal (ZF=0).
(instance WriteInst.Jne.I32 (forall W Error) (WriteInst W Error (Jne I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 85 cd
    (with1 (jne: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 133 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jng Op0) (jng: Op0))

; jng rel8: Jump short if not greater (ZF=1 or SF!= OF).
(instance WriteInst.Jng.I8 (forall W Error) (WriteInst W Error (Jng I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7E cb
    (with1 (jng: (let op0)) inst
      (let ()
        (write-u8! 126 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jng rel32: Jump near if not greater (ZF=1 or SF != OF).
(instance WriteInst.Jng.I32 (forall W Error) (WriteInst W Error (Jng I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8E cd
    (with1 (jng: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 142 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnge Op0) (jnge: Op0))

; jnge rel8: Jump short if not greater or equal (SF!= OF).
(instance WriteInst.Jnge.I8 (forall W Error) (WriteInst W Error (Jnge I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7C cb
    (with1 (jnge: (let op0)) inst
      (let ()
        (write-u8! 124 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnge rel32: Jump near if not greater or equal (SF != OF).
(instance WriteInst.Jnge.I32 (forall W Error) (WriteInst W Error (Jnge I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8C cd
    (with1 (jnge: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 140 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnl Op0) (jnl: Op0))

; jnl rel8: Jump short if not less (SF=OF).
(instance WriteInst.Jnl.I8 (forall W Error) (WriteInst W Error (Jnl I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7D cb
    (with1 (jnl: (let op0)) inst
      (let ()
        (write-u8! 125 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnl rel32: Jump near if not less (SF=OF).
(instance WriteInst.Jnl.I32 (forall W Error) (WriteInst W Error (Jnl I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8D cd
    (with1 (jnl: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 141 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnle Op0) (jnle: Op0))

; jnle rel8: Jump short if not less or equal (ZF=0 and SF=OF).
(instance WriteInst.Jnle.I8 (forall W Error) (WriteInst W Error (Jnle I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7F cb
    (with1 (jnle: (let op0)) inst
      (let ()
        (write-u8! 127 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnle rel32: Jump near if not less or equal (ZF=0 and SF=OF).
(instance WriteInst.Jnle.I32 (forall W Error) (WriteInst W Error (Jnle I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8F cd
    (with1 (jnle: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 143 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jno Op0) (jno: Op0))

; jno rel8: Jump short if not overflow (OF=0).
(instance WriteInst.Jno.I8 (forall W Error) (WriteInst W Error (Jno I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 71 cb
    (with1 (jno: (let op0)) inst
      (let ()
        (write-u8! 113 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jno rel32: Jump near if not overflow (OF=0).
(instance WriteInst.Jno.I32 (forall W Error) (WriteInst W Error (Jno I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 81 cd
    (with1 (jno: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 129 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnp Op0) (jnp: Op0))

; jnp rel8: Jump short if not parity (PF=0).
(instance WriteInst.Jnp.I8 (forall W Error) (WriteInst W Error (Jnp I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7B cb
    (with1 (jnp: (let op0)) inst
      (let ()
        (write-u8! 123 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnp rel32: Jump near if not parity (PF=0).
(instance WriteInst.Jnp.I32 (forall W Error) (WriteInst W Error (Jnp I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8B cd
    (with1 (jnp: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 139 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jns Op0) (jns: Op0))

; jns rel8: Jump short if not sign (SF=0).
(instance WriteInst.Jns.I8 (forall W Error) (WriteInst W Error (Jns I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 79 cb
    (with1 (jns: (let op0)) inst
      (let ()
        (write-u8! 121 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jns rel32: Jump near if not sign (SF=0).
(instance WriteInst.Jns.I32 (forall W Error) (WriteInst W Error (Jns I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 89 cd
    (with1 (jns: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 137 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jnz Op0) (jnz: Op0))

; jnz rel8: Jump short if not zero (ZF=0).
(instance WriteInst.Jnz.I8 (forall W Error) (WriteInst W Error (Jnz I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 75 cb
    (with1 (jnz: (let op0)) inst
      (let ()
        (write-u8! 117 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jnz rel32: Jump near if not zero (ZF=0).
(instance WriteInst.Jnz.I32 (forall W Error) (WriteInst W Error (Jnz I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 85 cd
    (with1 (jnz: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 133 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jo Op0) (jo: Op0))

; jo rel8: Jump short if overflow (OF=1).
(instance WriteInst.Jo.I8 (forall W Error) (WriteInst W Error (Jo I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 70 cb
    (with1 (jo: (let op0)) inst
      (let ()
        (write-u8! 112 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jo rel32: Jump near if overflow (OF=1).
(instance WriteInst.Jo.I32 (forall W Error) (WriteInst W Error (Jo I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 80 cd
    (with1 (jo: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 128 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jp Op0) (jp: Op0))

; jp rel8: Jump short if parity (PF=1).
(instance WriteInst.Jp.I8 (forall W Error) (WriteInst W Error (Jp I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7A cb
    (with1 (jp: (let op0)) inst
      (let ()
        (write-u8! 122 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jp rel32: Jump near if parity (PF=1).
(instance WriteInst.Jp.I32 (forall W Error) (WriteInst W Error (Jp I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8A cd
    (with1 (jp: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 138 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jpe Op0) (jpe: Op0))

; jpe rel8: Jump short if parity even (PF=1).
(instance WriteInst.Jpe.I8 (forall W Error) (WriteInst W Error (Jpe I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7A cb
    (with1 (jpe: (let op0)) inst
      (let ()
        (write-u8! 122 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jpe rel32: Jump near if parity even (PF=1).
(instance WriteInst.Jpe.I32 (forall W Error) (WriteInst W Error (Jpe I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8A cd
    (with1 (jpe: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 138 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jpo Op0) (jpo: Op0))

; jpo rel8: Jump short if parity odd (PF=0).
(instance WriteInst.Jpo.I8 (forall W Error) (WriteInst W Error (Jpo I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 7B cb
    (with1 (jpo: (let op0)) inst
      (let ()
        (write-u8! 123 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jpo rel32: Jump near if parity odd (PF=0).
(instance WriteInst.Jpo.I32 (forall W Error) (WriteInst W Error (Jpo I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 8B cd
    (with1 (jpo: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 139 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jrcxz Op0) (jrcxz: Op0))

; jrcxz rel8: Jump short if RCX register is 0.
(instance WriteInst.Jrcxz.I8 (forall W Error) (WriteInst W Error (Jrcxz I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; E3 cb
    (with1 (jrcxz: (let op0)) inst
      (let ()
        (write-u8! 227 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Js Op0) (js: Op0))

; js rel8: Jump short if sign (SF=1).
(instance WriteInst.Js.I8 (forall W Error) (WriteInst W Error (Js I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 78 cb
    (with1 (js: (let op0)) inst
      (let ()
        (write-u8! 120 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; js rel32: Jump near if sign (SF=1).
(instance WriteInst.Js.I32 (forall W Error) (WriteInst W Error (Js I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 88 cd
    (with1 (js: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 136 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Jz Op0) (jz: Op0))

; jz rel8: Jump short if zero (ZF = 1).
(instance WriteInst.Jz.I8 (forall W Error) (WriteInst W Error (Jz I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 74 cb
    (with1 (jz: (let op0)) inst
      (let ()
        (write-u8! 116 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; jz rel32: Jump near if 0 (ZF=1).
(instance WriteInst.Jz.I32 (forall W Error) (WriteInst W Error (Jz I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 84 cd
    (with1 (jz: (let op0)) inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 132 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Ldmxcsr Op0) (ldmxcsr: Op0))

; ldmxcsr m32: Load MXCSR register from m32.
(instance WriteInst.Ldmxcsr.Memory (forall W Error) (WriteInst W Error (Ldmxcsr Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AE /2
    (with1 (ldmxcsr: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 174 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Leal Op0 Op1) (leal: Op0 Op1))

; leal r32 m: Store effective address for m in register r32.
(instance WriteInst.Leal.Gpr32.Memory (forall W Error) (WriteInst W Error (Leal Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 8D /r
    (with1 (leal: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 141 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Leaq Op0 Op1) (leaq: Op0 Op1))

; leaq r64 m: Store effective address for m in register r64.
(instance WriteInst.Leaq.Gpr64.Memory (forall W Error) (WriteInst W Error (Leaq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 8D /r
    (with1 (leaq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 141 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Leaveq leaveq:)

; leaveq: Set RSP to RBP, then pop RBP.
(instance WriteInst.Leaveq (forall W Error) (WriteInst W Error Leaveq) (where (Write W Error))
  (function (write-inst! w inst)
    ; C9
    (with1 leaveq: inst
      (let ()
        (write-u8! 201 w)!
        (ok unit)))))

(value-data Leavew leavew:)

; leavew: Set SP to BP, then pop BP.
(instance WriteInst.Leavew (forall W Error) (WriteInst W Error Leavew) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C9
    (with1 leavew: inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 201 w)!
        (ok unit)))))

(value-data (Leaw Op0 Op1) (leaw: Op0 Op1))

; leaw r16 m: Store effective address for m in register r16.
(instance WriteInst.Leaw.Gpr16.Memory (forall W Error) (WriteInst W Error (Leaw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 8D /r
    (with1 (leaw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 141 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Lfence lfence:)

; lfence: Serializes load operations.
(instance WriteInst.Lfence (forall W Error) (WriteInst W Error Lfence) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AE E8
    (with1 lfence: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 174 w)!
        (write-u8! 232 w)!
        (ok unit)))))

(value-data (Lmsw Op0) (lmsw: Op0))

; lmsw r16: Loads r/m16 in machine status word of CR0.
(instance WriteInst.Lmsw.Gpr16 (forall W Error) (WriteInst W Error (Lmsw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 01 /6
    (with1 (lmsw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 1 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; lmsw m16: Loads r/m16 in machine status word of CR0.
(instance WriteInst.Lmsw.Memory (forall W Error) (WriteInst W Error (Lmsw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 01 /6
    (with1 (lmsw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 1 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Lock lock:)

; lock: Asserts LOCK# signal for duration of the accompanying instruction.
(instance WriteInst.Lock (forall W Error) (WriteInst W Error Lock) (where (Write W Error))
  (function (write-inst! w inst)
    ; F0
    (with1 lock: inst
      (let ()
        (write-u8! 240 w)!
        (ok unit)))))

(value-data (Maskmovdqu Op0 Op1) (maskmovdqu: Op0 Op1))

; maskmovdqu xmm xmm: Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.
(instance WriteInst.Maskmovdqu.Xmm.Xmm (forall W Error) (WriteInst W Error (Maskmovdqu Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F7 /r
    (with1 (maskmovdqu: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Maxpd Op0 Op1) (maxpd: Op0 Op1))

; maxpd xmm xmm: Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.
(instance WriteInst.Maxpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Maxpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5F /r
    (with1 (maxpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 95 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; maxpd xmm m128: Return the maximum double-precision floating-point values between xmm2/m128 and xmm1.
(instance WriteInst.Maxpd.Xmm.Memory (forall W Error) (WriteInst W Error (Maxpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5F /r
    (with1 (maxpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 95 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Maxps Op0 Op1) (maxps: Op0 Op1))

; maxps xmm xmm: Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.
(instance WriteInst.Maxps.Xmm.Xmm (forall W Error) (WriteInst W Error (Maxps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5F /r
    (with1 (maxps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 95 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; maxps xmm m128: Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.
(instance WriteInst.Maxps.Xmm.Memory (forall W Error) (WriteInst W Error (Maxps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5F /r
    (with1 (maxps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 95 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Maxsd Op0 Op1) (maxsd: Op0 Op1))

; maxsd xmm xmm: Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
(instance WriteInst.Maxsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Maxsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5F /r
    (with1 (maxsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 95 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; maxsd xmm m64: Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
(instance WriteInst.Maxsd.Xmm.Memory (forall W Error) (WriteInst W Error (Maxsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5F /r
    (with1 (maxsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 95 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Maxss Op0 Op1) (maxss: Op0 Op1))

; maxss xmm xmm: Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
(instance WriteInst.Maxss.Xmm.Xmm (forall W Error) (WriteInst W Error (Maxss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5F /r
    (with1 (maxss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 95 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; maxss xmm m32: Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
(instance WriteInst.Maxss.Xmm.Memory (forall W Error) (WriteInst W Error (Maxss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5F /r
    (with1 (maxss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 95 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Mfence mfence:)

; mfence: Serializes load and store operations.
(instance WriteInst.Mfence (forall W Error) (WriteInst W Error Mfence) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AE F0
    (with1 mfence: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 174 w)!
        (write-u8! 240 w)!
        (ok unit)))))

(value-data (Minpd Op0 Op1) (minpd: Op0 Op1))

; minpd xmm xmm: Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.
(instance WriteInst.Minpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Minpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5D /r
    (with1 (minpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 93 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; minpd xmm m128: Return the minimum double-precision floating-point values between xmm2/m128 and xmm1.
(instance WriteInst.Minpd.Xmm.Memory (forall W Error) (WriteInst W Error (Minpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5D /r
    (with1 (minpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 93 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Minps Op0 Op1) (minps: Op0 Op1))

; minps xmm xmm: Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.
(instance WriteInst.Minps.Xmm.Xmm (forall W Error) (WriteInst W Error (Minps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5D /r
    (with1 (minps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 93 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; minps xmm m128: Return the minimum single-precision floating-point values between xmm2/m128 and xmm1.
(instance WriteInst.Minps.Xmm.Memory (forall W Error) (WriteInst W Error (Minps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5D /r
    (with1 (minps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 93 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Minsd Op0 Op1) (minsd: Op0 Op1))

; minsd xmm xmm: Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
(instance WriteInst.Minsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Minsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5D /r
    (with1 (minsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 93 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; minsd xmm m64: Return the minimum scalar double-precision floating-point value between xmm2/mem64 and xmm1.
(instance WriteInst.Minsd.Xmm.Memory (forall W Error) (WriteInst W Error (Minsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5D /r
    (with1 (minsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 93 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Minss Op0 Op1) (minss: Op0 Op1))

; minss xmm xmm: Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
(instance WriteInst.Minss.Xmm.Xmm (forall W Error) (WriteInst W Error (Minss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5D /r
    (with1 (minss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 93 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; minss xmm m32: Return the minimum scalar single-precision floating-point value between xmm2/mem32 and xmm1.
(instance WriteInst.Minss.Xmm.Memory (forall W Error) (WriteInst W Error (Minss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5D /r
    (with1 (minss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 93 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movapd Op0 Op1) (movapd: Op0 Op1))

; movapd xmm xmm: Move packed double-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Movapd.Xmm.Xmm (forall W Error) (WriteInst W Error (Movapd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 28 /r
    (with1 (movapd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 40 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movapd xmm m128: Move packed double-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Movapd.Xmm.Memory (forall W Error) (WriteInst W Error (Movapd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 28 /r
    (with1 (movapd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 40 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movapd m128 xmm: Move packed double-precision floating-point values from xmm1 to xmm2/m128.
(instance WriteInst.Movapd.Memory.Xmm (forall W Error) (WriteInst W Error (Movapd Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 29 /r
    (with1 (movapd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 41 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movaps Op0 Op1) (movaps: Op0 Op1))

; movaps xmm xmm: Move packed single-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Movaps.Xmm.Xmm (forall W Error) (WriteInst W Error (Movaps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 28 /r
    (with1 (movaps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 40 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movaps xmm m128: Move packed single-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Movaps.Xmm.Memory (forall W Error) (WriteInst W Error (Movaps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 28 /r
    (with1 (movaps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 40 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movaps m128 xmm: Move packed single-precision floating-point values from xmm1 to xmm2/m128.
(instance WriteInst.Movaps.Memory.Xmm (forall W Error) (WriteInst W Error (Movaps Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 29 /r
    (with1 (movaps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 41 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movb Op0 Op1) (movb: Op0 Op1))

; movb r8 imm8: Move imm8 to r8.
(instance WriteInst.Movb.Gpr8.I8 (forall W Error) (WriteInst W Error (Movb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; B0 +rb ib
    (with1 (movb: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 176 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; movb r8 r8: Move r/m8 to r8.
(instance WriteInst.Movb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Movb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 8A /r
    (with1 (movb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 138 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movb r8 m8: Move r/m8 to r8.
(instance WriteInst.Movb.Gpr8.Memory (forall W Error) (WriteInst W Error (Movb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 8A /r
    (with1 (movb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 138 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movb m8 r8: Move r8 to r/m8.
(instance WriteInst.Movb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Movb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 88 /r
    (with1 (movb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 136 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movb m8 imm8: Move imm8 to r/m8.
(instance WriteInst.Movb.Memory.I8 (forall W Error) (WriteInst W Error (Movb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C6 /0 ib
    (with1 (movb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 198 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Movd Op0 Op1) (movd: Op0 Op1))

; movd r32 xmm: Move doubleword from xmm register to r/m32.
(instance WriteInst.Movd.Gpr32.Xmm (forall W Error) (WriteInst W Error (Movd Gpr32 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 7E /r
    (with1 (movd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 126 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movd m32 xmm: Move doubleword from xmm register to r/m32.
(instance WriteInst.Movd.Memory.Xmm (forall W Error) (WriteInst W Error (Movd Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 7E /r
    (with1 (movd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 126 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movd xmm r32: Move doubleword from r/m32 to xmm.
(instance WriteInst.Movd.Xmm.Gpr32 (forall W Error) (WriteInst W Error (Movd Xmm Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6E /r
    (with1 (movd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 110 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movd xmm m32: Move doubleword from r/m32 to xmm.
(instance WriteInst.Movd.Xmm.Memory (forall W Error) (WriteInst W Error (Movd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6E /r
    (with1 (movd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 110 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movdqa Op0 Op1) (movdqa: Op0 Op1))

; movdqa xmm xmm: Move aligned double quadword from xmm2/m128 to xmm1.
(instance WriteInst.Movdqa.Xmm.Xmm (forall W Error) (WriteInst W Error (Movdqa Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6F /r
    (with1 (movdqa: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 111 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movdqa xmm m128: Move aligned double quadword from xmm2/m128 to xmm1.
(instance WriteInst.Movdqa.Xmm.Memory (forall W Error) (WriteInst W Error (Movdqa Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6F /r
    (with1 (movdqa: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 111 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movdqa m128 xmm: Move aligned double quadword from xmm1 to xmm2/m128.
(instance WriteInst.Movdqa.Memory.Xmm (forall W Error) (WriteInst W Error (Movdqa Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 7F /r
    (with1 (movdqa: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 127 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movdqu Op0 Op1) (movdqu: Op0 Op1))

; movdqu xmm xmm: Move unaligned double quadword from xmm2/m128 to xmm1.
(instance WriteInst.Movdqu.Xmm.Xmm (forall W Error) (WriteInst W Error (Movdqu Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 6F /r
    (with1 (movdqu: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 111 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movdqu xmm m128: Move unaligned double quadword from xmm2/m128 to xmm1.
(instance WriteInst.Movdqu.Xmm.Memory (forall W Error) (WriteInst W Error (Movdqu Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 6F /r
    (with1 (movdqu: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 111 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movdqu m128 xmm: Move unaligned double quadword from xmm1 to xmm2/m128.
(instance WriteInst.Movdqu.Memory.Xmm (forall W Error) (WriteInst W Error (Movdqu Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 7F /r
    (with1 (movdqu: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 127 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movhlps Op0 Op1) (movhlps: Op0 Op1))

; movhlps xmm xmm: Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1.
(instance WriteInst.Movhlps.Xmm.Xmm (forall W Error) (WriteInst W Error (Movhlps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 12 /r
    (with1 (movhlps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 18 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movhpd Op0 Op1) (movhpd: Op0 Op1))

; movhpd m64 xmm: Move double-precision floating-point value from high quadword of xmm to m64.
(instance WriteInst.Movhpd.Memory.Xmm (forall W Error) (WriteInst W Error (Movhpd Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 17 /r
    (with1 (movhpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 23 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movhpd xmm m64: Move double-precision floating-point value from m64 to high quadword of xmm.
(instance WriteInst.Movhpd.Xmm.Memory (forall W Error) (WriteInst W Error (Movhpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 16 /r
    (with1 (movhpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 22 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movhps Op0 Op1) (movhps: Op0 Op1))

; movhps m64 xmm: Move two packed single-precision floating-point values from high quadword of xmm to m64.
(instance WriteInst.Movhps.Memory.Xmm (forall W Error) (WriteInst W Error (Movhps Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 17 /r
    (with1 (movhps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 23 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movhps xmm m64: Move two packed single-precision floating-point values from m64 to high quadword of xmm.
(instance WriteInst.Movhps.Xmm.Memory (forall W Error) (WriteInst W Error (Movhps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 16 /r
    (with1 (movhps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 22 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movl Op0 Op1) (movl: Op0 Op1))

; movl r32 imm32: Move imm32 to r32.
(instance WriteInst.Movl.Gpr32.I32 (forall W Error) (WriteInst W Error (Movl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; B8 +rd id
    (with1 (movl: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 184 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; movl r32 r32: Move r/m32 to r32.
(instance WriteInst.Movl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Movl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 8B /r
    (with1 (movl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 139 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movl r32 m32: Move r/m32 to r32.
(instance WriteInst.Movl.Gpr32.Memory (forall W Error) (WriteInst W Error (Movl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 8B /r
    (with1 (movl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 139 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movl m32 r32: Move r32 to r/m32.
(instance WriteInst.Movl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Movl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 89 /r
    (with1 (movl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 137 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movl m32 imm32: Move imm32 to r/m32.
(instance WriteInst.Movl.Memory.I32 (forall W Error) (WriteInst W Error (Movl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C7 /0 id
    (with1 (movl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 199 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Movlhps Op0 Op1) (movlhps: Op0 Op1))

; movlhps xmm xmm: Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1.
(instance WriteInst.Movlhps.Xmm.Xmm (forall W Error) (WriteInst W Error (Movlhps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 16 /r
    (with1 (movlhps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 22 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movlpd Op0 Op1) (movlpd: Op0 Op1))

; movlpd m64 xmm: Move double-precision floating-point nvalue from low quadword of xmm register to m64.
(instance WriteInst.Movlpd.Memory.Xmm (forall W Error) (WriteInst W Error (Movlpd Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 13 /r
    (with1 (movlpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 19 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movlpd xmm m64: Move double-precision floating-point value from m64 to low quadword of xmm register.
(instance WriteInst.Movlpd.Xmm.Memory (forall W Error) (WriteInst W Error (Movlpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 12 /r
    (with1 (movlpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 18 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movlps Op0 Op1) (movlps: Op0 Op1))

; movlps m64 xmm: Move two packed single-precision floating-point values from low quadword of xmm to m64.
(instance WriteInst.Movlps.Memory.Xmm (forall W Error) (WriteInst W Error (Movlps Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 13 /r
    (with1 (movlps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 19 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movlps xmm m64: Move two packed single-precision floating-point values from m64 to low quadword of xmm.
(instance WriteInst.Movlps.Xmm.Memory (forall W Error) (WriteInst W Error (Movlps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 12 /r
    (with1 (movlps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 18 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movmskpd Op0 Op1) (movmskpd: Op0 Op1))

; movmskpd reg xmm: Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.
(instance WriteInst.Movmskpd.Gpr64.Xmm (forall W Error) (WriteInst W Error (Movmskpd Gpr64 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 50 /r
    (with1 (movmskpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 80 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movmskps Op0 Op1) (movmskps: Op0 Op1))

; movmskps reg xmm: Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros.
(instance WriteInst.Movmskps.Gpr64.Xmm (forall W Error) (WriteInst W Error (Movmskps Gpr64 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 50 /r
    (with1 (movmskps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 80 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movntdq Op0 Op1) (movntdq: Op0 Op1))

; movntdq m128 xmm: Move double quadword from xmm to m128 using non-temporal hint.
(instance WriteInst.Movntdq.Memory.Xmm (forall W Error) (WriteInst W Error (Movntdq Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E7 /r
    (with1 (movntdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 231 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movntdqa Op0 Op1) (movntdqa: Op0 Op1))

; movntdqa xmm m128: Move double quadword from m128 to xmm using non-temporal hint if WC memory type.
(instance WriteInst.Movntdqa.Xmm.Memory (forall W Error) (WriteInst W Error (Movntdqa Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 2A /r
    (with1 (movntdqa: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movnti Op0 Op1) (movnti: Op0 Op1))

; movnti m32 r32: Move doubleword from r32 to m32 using non-temporal hint.
(instance WriteInst.Movnti.Memory.Gpr32 (forall W Error) (WriteInst W Error (Movnti Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C3 /r
    (with1 (movnti: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 195 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movnti m64 r64: Move quadword from r64 to m64 using non-temporal hint.
(instance WriteInst.Movnti.Memory.Gpr64 (forall W Error) (WriteInst W Error (Movnti Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F C3 /r
    (with1 (movnti: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 195 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movntpd Op0 Op1) (movntpd: Op0 Op1))

; movntpd m128 xmm: Move packed double-precision floating-point values from xmm to m128 using non-temporal hint.
(instance WriteInst.Movntpd.Memory.Xmm (forall W Error) (WriteInst W Error (Movntpd Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 2B /r
    (with1 (movntpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movntps Op0 Op1) (movntps: Op0 Op1))

; movntps m128 xmm: Move packed single-precision floating-point values from xmm to m128 using non-temporal hint.
(instance WriteInst.Movntps.Memory.Xmm (forall W Error) (WriteInst W Error (Movntps Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 2B /r
    (with1 (movntps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movq Op0 Op1) (movq: Op0 Op1))

; movq r64 imm64: Move imm64 to r64.
(instance WriteInst.Movq.Gpr64.I64 (forall W Error) (WriteInst W Error (Movq Gpr64 I64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ B8 +ro io
    (with1 (movq: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #t) (write-u8! b w)!)
        (write-u8! (+ 184 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; movq r64 r64: Move r/m64 to r64.
(instance WriteInst.Movq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Movq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 8B /r
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 139 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movq r64 m64: Move r/m64 to r64.
(instance WriteInst.Movq.Gpr64.Memory (forall W Error) (WriteInst W Error (Movq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 8B /r
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 139 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movq m64 r64: Move r64 to r/m64.
(instance WriteInst.Movq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Movq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 89 /r
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 137 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movq r64 imm32: Move imm32 sign extended to 64-bits to r/m64.
(instance WriteInst.Movq.Gpr64.I32 (forall W Error) (WriteInst W Error (Movq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C7 /0 id
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 199 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; movq m64 imm32: Move imm32 sign extended to 64-bits to r/m64.
(instance WriteInst.Movq.Memory.I32 (forall W Error) (WriteInst W Error (Movq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C7 /0 id
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 199 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; movq r64 xmm: Move quadword from xmm register to r/m64.
(instance WriteInst.Movq.Gpr64.Xmm (forall W Error) (WriteInst W Error (Movq Gpr64 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 REX.W+ 0F 7E /r
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 126 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movq m64 xmm: Move quadword from xmm register to r/m64.
(instance WriteInst.Movq.Memory.Xmm (forall W Error) (WriteInst W Error (Movq Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 REX.W+ 0F 7E /r
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 126 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movq xmm r64: Move quadword from r/m64 to xmm.
(instance WriteInst.Movq.Xmm.Gpr64 (forall W Error) (WriteInst W Error (Movq Xmm Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 REX.W+ 0F 6E /r
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 110 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movq xmm m64: Move quadword from r/m64 to xmm.
(instance WriteInst.Movq.Xmm.Memory (forall W Error) (WriteInst W Error (Movq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 REX.W+ 0F 6E /r
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 110 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movq xmm xmm: Move quadword from xmm2/mem64 to xmm1.
(instance WriteInst.Movq.Xmm.Xmm (forall W Error) (WriteInst W Error (Movq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 7E /r
    (with1 (movq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 126 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movsbl Op0 Op1) (movsbl: Op0 Op1))

; movsbl r32 r8: Move byte to doubleword with sign-extension.
(instance WriteInst.Movsbl.Gpr32.Gpr8 (forall W Error) (WriteInst W Error (Movsbl Gpr32 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BE /r
    (with1 (movsbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 190 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movsbl r32 m8: Move byte to doubleword with sign-extension.
(instance WriteInst.Movsbl.Gpr32.Memory (forall W Error) (WriteInst W Error (Movsbl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BE /r
    (with1 (movsbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 190 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movsbq Op0 Op1) (movsbq: Op0 Op1))

; movsbq r64 r8: Move byte to quadword with sign-extension.
(instance WriteInst.Movsbq.Gpr64.Gpr8 (forall W Error) (WriteInst W Error (Movsbq Gpr64 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BE /r
    (with1 (movsbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 190 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movsbq r64 m8: Move byte to quadword with sign-extension.
(instance WriteInst.Movsbq.Gpr64.Memory (forall W Error) (WriteInst W Error (Movsbq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BE /r
    (with1 (movsbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 190 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movsbw Op0 Op1) (movsbw: Op0 Op1))

; movsbw r16 r8: Move byte to word with sign-extension.
(instance WriteInst.Movsbw.Gpr16.Gpr8 (forall W Error) (WriteInst W Error (Movsbw Gpr16 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BE /r
    (with1 (movsbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 190 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movsbw r16 m8: Move byte to word with sign-extension.
(instance WriteInst.Movsbw.Gpr16.Memory (forall W Error) (WriteInst W Error (Movsbw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F BE /r
    (with1 (movsbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 190 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movsd Op0 Op1) (movsd: Op0 Op1))

; movsd xmm xmm: Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.
(instance WriteInst.Movsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Movsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 10 /r
    (with1 (movsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movsd xmm m64: Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.
(instance WriteInst.Movsd.Xmm.Memory (forall W Error) (WriteInst W Error (Movsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 10 /r
    (with1 (movsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movsd m64 xmm: Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.
(instance WriteInst.Movsd.Memory.Xmm (forall W Error) (WriteInst W Error (Movsd Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 11 /r
    (with1 (movsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 17 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Movsl movsl:)

; movsl: For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.
(instance WriteInst.Movsl (forall W Error) (WriteInst W Error Movsl) (where (Write W Error))
  (function (write-inst! w inst)
    ; A5
    (with1 movsl: inst
      (let ()
        (write-u8! 165 w)!
        (ok unit)))))

(value-data (Movslq Op0 Op1) (movslq: Op0 Op1))

; movslq r64 r32: Move doubleword to quadword with sign-extension.
(instance WriteInst.Movslq.Gpr64.Gpr32 (forall W Error) (WriteInst W Error (Movslq Gpr64 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 63 /r
    (with1 (movslq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 99 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movslq r64 m32: Move doubleword to quadword with sign-extension.
(instance WriteInst.Movslq.Gpr64.Memory (forall W Error) (WriteInst W Error (Movslq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 63 /r
    (with1 (movslq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 99 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movss Op0 Op1) (movss: Op0 Op1))

; movss xmm xmm: Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.
(instance WriteInst.Movss.Xmm.Xmm (forall W Error) (WriteInst W Error (Movss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 10 /r
    (with1 (movss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movss xmm m32: Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.
(instance WriteInst.Movss.Xmm.Memory (forall W Error) (WriteInst W Error (Movss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 10 /r
    (with1 (movss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movss m32 xmm: Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.
(instance WriteInst.Movss.Memory.Xmm (forall W Error) (WriteInst W Error (Movss Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 11 /r
    (with1 (movss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 17 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movswl Op0 Op1) (movswl: Op0 Op1))

; movswl r32 r16: Move word to doubleword, with sign-extension.
(instance WriteInst.Movswl.Gpr32.Gpr16 (forall W Error) (WriteInst W Error (Movswl Gpr32 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BF /r
    (with1 (movswl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 191 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movswl r32 m16: Move word to doubleword, with sign-extension.
(instance WriteInst.Movswl.Gpr32.Memory (forall W Error) (WriteInst W Error (Movswl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F BF /r
    (with1 (movswl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 191 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movswq Op0 Op1) (movswq: Op0 Op1))

; movswq r64 r16: Move word to quadword with sign-extension.
(instance WriteInst.Movswq.Gpr64.Gpr16 (forall W Error) (WriteInst W Error (Movswq Gpr64 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BF /r
    (with1 (movswq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 191 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movswq r64 m16: Move word to quadword with sign-extension.
(instance WriteInst.Movswq.Gpr64.Memory (forall W Error) (WriteInst W Error (Movswq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F BF /r
    (with1 (movswq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 191 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movupd Op0 Op1) (movupd: Op0 Op1))

; movupd xmm xmm: Move packed double-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Movupd.Xmm.Xmm (forall W Error) (WriteInst W Error (Movupd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 10 /r
    (with1 (movupd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movupd xmm m128: Move packed double-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Movupd.Xmm.Memory (forall W Error) (WriteInst W Error (Movupd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 10 /r
    (with1 (movupd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movupd m128 xmm: Move packed double-precision floating-point values from xmm1 to xmm2/m128.
(instance WriteInst.Movupd.Memory.Xmm (forall W Error) (WriteInst W Error (Movupd Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 11 /r
    (with1 (movupd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 17 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movups Op0 Op1) (movups: Op0 Op1))

; movups xmm xmm: Move packed single-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Movups.Xmm.Xmm (forall W Error) (WriteInst W Error (Movups Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 10 /r
    (with1 (movups: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movups xmm m128: Move packed single-precision floating-point values from xmm2/m128 to xmm1.
(instance WriteInst.Movups.Xmm.Memory (forall W Error) (WriteInst W Error (Movups Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 10 /r
    (with1 (movups: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movups m128 xmm: Move packed single-precision floating-point values from xmm1 to xmm2/m128.
(instance WriteInst.Movups.Memory.Xmm (forall W Error) (WriteInst W Error (Movups Memory Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 11 /r
    (with1 (movups: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 17 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movw Op0 Op1) (movw: Op0 Op1))

; movw r16 imm16: Move imm16 to r16.
(instance WriteInst.Movw.Gpr16.I16 (forall W Error) (WriteInst W Error (Movw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 B8 +rw iw
    (with1 (movw: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 184 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; movw r16 r16: Move r/m16 to r16.
(instance WriteInst.Movw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Movw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 8B /r
    (with1 (movw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 139 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movw r16 m16: Move r/m16 to r16.
(instance WriteInst.Movw.Gpr16.Memory (forall W Error) (WriteInst W Error (Movw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 8B /r
    (with1 (movw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 139 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movw m16 r16: Move r16 to r/m16.
(instance WriteInst.Movw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Movw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 89 /r
    (with1 (movw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 137 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movw m16 imm16: Move imm16 to r/m16.
(instance WriteInst.Movw.Memory.I16 (forall W Error) (WriteInst W Error (Movw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C7 /0 iw
    (with1 (movw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 199 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Movzbl Op0 Op1) (movzbl: Op0 Op1))

; movzbl r32 r8: Move byte to doubleword, zero-extension.
(instance WriteInst.Movzbl.Gpr32.Gpr8 (forall W Error) (WriteInst W Error (Movzbl Gpr32 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B6 /r
    (with1 (movzbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 182 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movzbl r32 m8: Move byte to doubleword, zero-extension.
(instance WriteInst.Movzbl.Gpr32.Memory (forall W Error) (WriteInst W Error (Movzbl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B6 /r
    (with1 (movzbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 182 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movzbq Op0 Op1) (movzbq: Op0 Op1))

; movzbq r64 r8: Move byte to quadword, zero-extension.
(instance WriteInst.Movzbq.Gpr64.Gpr8 (forall W Error) (WriteInst W Error (Movzbq Gpr64 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F B6 /r
    (with1 (movzbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 182 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movzbq r64 m8: Move byte to quadword, zero-extension.
(instance WriteInst.Movzbq.Gpr64.Memory (forall W Error) (WriteInst W Error (Movzbq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F B6 /r
    (with1 (movzbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 182 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movzbw Op0 Op1) (movzbw: Op0 Op1))

; movzbw r16 r8: Move byte to word with zero-extension.
(instance WriteInst.Movzbw.Gpr16.Gpr8 (forall W Error) (WriteInst W Error (Movzbw Gpr16 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F B6 /r
    (with1 (movzbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 182 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movzbw r16 m8: Move byte to word with zero-extension.
(instance WriteInst.Movzbw.Gpr16.Memory (forall W Error) (WriteInst W Error (Movzbw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F B6 /r
    (with1 (movzbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 182 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movzwl Op0 Op1) (movzwl: Op0 Op1))

; movzwl r32 r16: Move word to doubleword, zero-extension.
(instance WriteInst.Movzwl.Gpr32.Gpr16 (forall W Error) (WriteInst W Error (Movzwl Gpr32 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B7 /r
    (with1 (movzwl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 183 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movzwl r32 m16: Move word to doubleword, zero-extension.
(instance WriteInst.Movzwl.Gpr32.Memory (forall W Error) (WriteInst W Error (Movzwl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F B7 /r
    (with1 (movzwl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 183 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Movzwq Op0 Op1) (movzwq: Op0 Op1))

; movzwq r64 r16: Move word to quadword, zero-extension.
(instance WriteInst.Movzwq.Gpr64.Gpr16 (forall W Error) (WriteInst W Error (Movzwq Gpr64 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F B7 /r
    (with1 (movzwq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 183 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; movzwq r64 m16: Move word to quadword, zero-extension.
(instance WriteInst.Movzwq.Gpr64.Memory (forall W Error) (WriteInst W Error (Movzwq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F B7 /r
    (with1 (movzwq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 183 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Mpsadbw Op0 Op1 Op2) (mpsadbw: Op0 Op1 Op2))

; mpsadbw xmm xmm imm8: Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.
(instance WriteInst.Mpsadbw.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Mpsadbw Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 42 /r ib
    (with1 (mpsadbw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 66 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; mpsadbw xmm m128 imm8: Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.
(instance WriteInst.Mpsadbw.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Mpsadbw Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 42 /r ib
    (with1 (mpsadbw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 66 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Mulb Op0) (mulb: Op0))

; mulb r8: Unsigned multiply (AX = AL * r/m8).
(instance WriteInst.Mulb.Gpr8 (forall W Error) (WriteInst W Error (Mulb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /4
    (with1 (mulb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; mulb m8: Unsigned multiply (AX = AL * r/m8).
(instance WriteInst.Mulb.Memory (forall W Error) (WriteInst W Error (Mulb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /4
    (with1 (mulb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Mull Op0) (mull: Op0))

; mull r32: Unsigned multiply (EDX:EAX = EAX * r/m32).
(instance WriteInst.Mull.Gpr32 (forall W Error) (WriteInst W Error (Mull Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /4
    (with1 (mull: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; mull m32: Unsigned multiply (EDX:EAX = EAX * r/m32).
(instance WriteInst.Mull.Memory (forall W Error) (WriteInst W Error (Mull Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /4
    (with1 (mull: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Mulpd Op0 Op1) (mulpd: Op0 Op1))

; mulpd xmm xmm: Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.
(instance WriteInst.Mulpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Mulpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 59 /r
    (with1 (mulpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 89 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; mulpd xmm m128: Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.
(instance WriteInst.Mulpd.Xmm.Memory (forall W Error) (WriteInst W Error (Mulpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 59 /r
    (with1 (mulpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 89 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Mulps Op0 Op1) (mulps: Op0 Op1))

; mulps xmm xmm: Multiply packed single-precision floating-point values in xmm2/mem by xmm1.
(instance WriteInst.Mulps.Xmm.Xmm (forall W Error) (WriteInst W Error (Mulps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 59 /r
    (with1 (mulps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 89 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; mulps xmm m128: Multiply packed single-precision floating-point values in xmm2/mem by xmm1.
(instance WriteInst.Mulps.Xmm.Memory (forall W Error) (WriteInst W Error (Mulps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 59 /r
    (with1 (mulps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 89 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Mulq Op0) (mulq: Op0))

; mulq r64: Unsigned multiply (RDX:RAX = RAX * r/m64.
(instance WriteInst.Mulq.Gpr64 (forall W Error) (WriteInst W Error (Mulq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /4
    (with1 (mulq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; mulq m64: Unsigned multiply (RDX:RAX = RAX * r/m64.
(instance WriteInst.Mulq.Memory (forall W Error) (WriteInst W Error (Mulq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /4
    (with1 (mulq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Mulsd Op0 Op1) (mulsd: Op0 Op1))

; mulsd xmm xmm: Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.
(instance WriteInst.Mulsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Mulsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 59 /r
    (with1 (mulsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 89 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; mulsd xmm m64: Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.
(instance WriteInst.Mulsd.Xmm.Memory (forall W Error) (WriteInst W Error (Mulsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 59 /r
    (with1 (mulsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 89 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Mulss Op0 Op1) (mulss: Op0 Op1))

; mulss xmm xmm: Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.
(instance WriteInst.Mulss.Xmm.Xmm (forall W Error) (WriteInst W Error (Mulss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 59 /r
    (with1 (mulss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 89 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; mulss xmm m32: Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.
(instance WriteInst.Mulss.Xmm.Memory (forall W Error) (WriteInst W Error (Mulss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 59 /r
    (with1 (mulss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 89 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Mulw Op0) (mulw: Op0))

; mulw r16: Unsigned multiply (DX:AX = AX * r/m16).
(instance WriteInst.Mulw.Gpr16 (forall W Error) (WriteInst W Error (Mulw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /4
    (with1 (mulw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; mulw m16: Unsigned multiply (DX:AX = AX * r/m16).
(instance WriteInst.Mulw.Memory (forall W Error) (WriteInst W Error (Mulw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /4
    (with1 (mulw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Negb Op0) (negb: Op0))

; negb r8: Two's complement negate r/m8.
(instance WriteInst.Negb.Gpr8 (forall W Error) (WriteInst W Error (Negb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /3
    (with1 (negb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; negb m8: Two's complement negate r/m8.
(instance WriteInst.Negb.Memory (forall W Error) (WriteInst W Error (Negb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /3
    (with1 (negb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Negl Op0) (negl: Op0))

; negl r32: Two's complement negate r/m32.
(instance WriteInst.Negl.Gpr32 (forall W Error) (WriteInst W Error (Negl Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /3
    (with1 (negl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; negl m32: Two's complement negate r/m32.
(instance WriteInst.Negl.Memory (forall W Error) (WriteInst W Error (Negl Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /3
    (with1 (negl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Negq Op0) (negq: Op0))

; negq r64: Two's complement negate r/m64.
(instance WriteInst.Negq.Gpr64 (forall W Error) (WriteInst W Error (Negq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /3
    (with1 (negq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; negq m64: Two's complement negate r/m64.
(instance WriteInst.Negq.Memory (forall W Error) (WriteInst W Error (Negq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /3
    (with1 (negq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Negw Op0) (negw: Op0))

; negw r16: Two's complement negate r/m16.
(instance WriteInst.Negw.Gpr16 (forall W Error) (WriteInst W Error (Negw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /3
    (with1 (negw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; negw m16: Two's complement negate r/m16.
(instance WriteInst.Negw.Memory (forall W Error) (WriteInst W Error (Negw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /3
    (with1 (negw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Nop nop:)

; nop: One byte no-operation instruction.
(instance WriteInst.Nop (forall W Error) (WriteInst W Error Nop) (where (Write W Error))
  (function (write-inst! w inst)
    ; 90
    (with1 nop: inst
      (let ()
        (write-u8! 144 w)!
        (ok unit)))))

(value-data (Notb Op0) (notb: Op0))

; notb r8: Reverse each bit of r/m8.
(instance WriteInst.Notb.Gpr8 (forall W Error) (WriteInst W Error (Notb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /2
    (with1 (notb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; notb m8: Reverse each bit of r/m8.
(instance WriteInst.Notb.Memory (forall W Error) (WriteInst W Error (Notb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /2
    (with1 (notb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Notl Op0) (notl: Op0))

; notl r32: Reverse each bit of r/m32.
(instance WriteInst.Notl.Gpr32 (forall W Error) (WriteInst W Error (Notl Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /2
    (with1 (notl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; notl m32: Reverse each bit of r/m32.
(instance WriteInst.Notl.Memory (forall W Error) (WriteInst W Error (Notl Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /2
    (with1 (notl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Notq Op0) (notq: Op0))

; notq r64: Reverse each bit of r/m64.
(instance WriteInst.Notq.Gpr64 (forall W Error) (WriteInst W Error (Notq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /2
    (with1 (notq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; notq m64: Reverse each bit of r/m64.
(instance WriteInst.Notq.Memory (forall W Error) (WriteInst W Error (Notq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /2
    (with1 (notq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Notw Op0) (notw: Op0))

; notw r16: Reverse each bit of r/m16.
(instance WriteInst.Notw.Gpr16 (forall W Error) (WriteInst W Error (Notw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /2
    (with1 (notw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; notw m16: Reverse each bit of r/m16.
(instance WriteInst.Notw.Memory (forall W Error) (WriteInst W Error (Notw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /2
    (with1 (notw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Orb Op0 Op1) (orb: Op0 Op1))

; orb r8 r8: r8 OR r/m8.
(instance WriteInst.Orb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Orb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0A /r
    (with1 (orb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 10 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orb r8 m8: r8 OR r/m8.
(instance WriteInst.Orb.Gpr8.Memory (forall W Error) (WriteInst W Error (Orb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0A /r
    (with1 (orb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 10 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orb m8 r8: r/m8 OR r8.
(instance WriteInst.Orb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Orb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 08 /r
    (with1 (orb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 8 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orb r8 imm8: r/m8 OR imm8.
(instance WriteInst.Orb.Gpr8.I8 (forall W Error) (WriteInst W Error (Orb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /1 ib
    (with1 (orb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orb m8 imm8: r/m8 OR imm8.
(instance WriteInst.Orb.Memory.I8 (forall W Error) (WriteInst W Error (Orb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /1 ib
    (with1 (orb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orb _Al imm8: AL OR imm8.
(instance WriteInst.Orb.|Al.I8 (forall W Error) (WriteInst W Error (Orb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0C ib
    (with1 (orb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 12 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Orl Op0 Op1) (orl: Op0 Op1))

; orl r32 r32: r32 OR r/m32.
(instance WriteInst.Orl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Orl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0B /r
    (with1 (orl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 11 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orl r32 m32: r32 OR r/m32.
(instance WriteInst.Orl.Gpr32.Memory (forall W Error) (WriteInst W Error (Orl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0B /r
    (with1 (orl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 11 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orl m32 r32: r/m32 OR r32.
(instance WriteInst.Orl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Orl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 09 /r
    (with1 (orl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 9 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orl r32 imm8: r/m32 OR imm8 (sign-extended).
(instance WriteInst.Orl.Gpr32.I8 (forall W Error) (WriteInst W Error (Orl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /1 ib
    (with1 (orl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orl m32 imm8: r/m32 OR imm8 (sign-extended).
(instance WriteInst.Orl.Memory.I8 (forall W Error) (WriteInst W Error (Orl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /1 ib
    (with1 (orl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orl r32 imm32: r/m32 OR imm32.
(instance WriteInst.Orl.Gpr32.I32 (forall W Error) (WriteInst W Error (Orl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /1 id
    (with1 (orl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orl m32 imm32: r/m32 OR imm32.
(instance WriteInst.Orl.Memory.I32 (forall W Error) (WriteInst W Error (Orl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /1 id
    (with1 (orl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orl _Eax imm32: EAX OR imm32.
(instance WriteInst.Orl.|Eax.I32 (forall W Error) (WriteInst W Error (Orl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0D id
    (with1 (orl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 13 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Orpd Op0 Op1) (orpd: Op0 Op1))

; orpd xmm xmm: Bitwise OR of xmm2/m128 and xmm1.
(instance WriteInst.Orpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Orpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 56 /r
    (with1 (orpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 86 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orpd xmm m128: Bitwise OR of xmm2/m128 and xmm1.
(instance WriteInst.Orpd.Xmm.Memory (forall W Error) (WriteInst W Error (Orpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 56 /r
    (with1 (orpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 86 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Orps Op0 Op1) (orps: Op0 Op1))

; orps xmm xmm: Bitwise OR of xmm1 and xmm2/m128.
(instance WriteInst.Orps.Xmm.Xmm (forall W Error) (WriteInst W Error (Orps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 56 /r
    (with1 (orps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 86 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orps xmm m128: Bitwise OR of xmm1 and xmm2/m128.
(instance WriteInst.Orps.Xmm.Memory (forall W Error) (WriteInst W Error (Orps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 56 /r
    (with1 (orps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 86 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Orq Op0 Op1) (orq: Op0 Op1))

; orq r64 r64: r64 OR r/m64.
(instance WriteInst.Orq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Orq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0B /r
    (with1 (orq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 11 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orq r64 m64: r64 OR r/m64.
(instance WriteInst.Orq.Gpr64.Memory (forall W Error) (WriteInst W Error (Orq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0B /r
    (with1 (orq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 11 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orq m64 r64: r/m64 OR r64.
(instance WriteInst.Orq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Orq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 09 /r
    (with1 (orq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 9 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orq r64 imm8: r/m64 OR imm8 (sign-extended).
(instance WriteInst.Orq.Gpr64.I8 (forall W Error) (WriteInst W Error (Orq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /1 ib
    (with1 (orq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orq m64 imm8: r/m64 OR imm8 (sign-extended).
(instance WriteInst.Orq.Memory.I8 (forall W Error) (WriteInst W Error (Orq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /1 ib
    (with1 (orq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orq r64 imm32: r/m64 OR imm32 (sign-extended).
(instance WriteInst.Orq.Gpr64.I32 (forall W Error) (WriteInst W Error (Orq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /1 id
    (with1 (orq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orq m64 imm32: r/m64 OR imm32 (sign-extended).
(instance WriteInst.Orq.Memory.I32 (forall W Error) (WriteInst W Error (Orq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /1 id
    (with1 (orq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orq _Rax imm32: RAX OR imm32 (sign-extended).
(instance WriteInst.Orq.|Rax.I32 (forall W Error) (WriteInst W Error (Orq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0D id
    (with1 (orq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 13 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Orw Op0 Op1) (orw: Op0 Op1))

; orw r16 r16: r16 OR r/m16.
(instance WriteInst.Orw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Orw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0B /r
    (with1 (orw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 11 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orw r16 m16: r16 OR r/m16.
(instance WriteInst.Orw.Gpr16.Memory (forall W Error) (WriteInst W Error (Orw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0B /r
    (with1 (orw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 11 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orw m16 r16: r/m16 OR r16.
(instance WriteInst.Orw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Orw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 09 /r
    (with1 (orw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 9 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; orw r16 imm8: r/m16 OR imm8 (sign-extended).
(instance WriteInst.Orw.Gpr16.I8 (forall W Error) (WriteInst W Error (Orw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /1 ib
    (with1 (orw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orw m16 imm8: r/m16 OR imm8 (sign-extended).
(instance WriteInst.Orw.Memory.I8 (forall W Error) (WriteInst W Error (Orw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /1 ib
    (with1 (orw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orw r16 imm16: r/m16 OR imm16.
(instance WriteInst.Orw.Gpr16.I16 (forall W Error) (WriteInst W Error (Orw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /1 iw
    (with1 (orw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orw m16 imm16: r/m16 OR imm16.
(instance WriteInst.Orw.Memory.I16 (forall W Error) (WriteInst W Error (Orw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /1 iw
    (with1 (orw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; orw _Ax imm16: AX OR imm16.
(instance WriteInst.Orw.|Ax.I16 (forall W Error) (WriteInst W Error (Orw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0D iw
    (with1 (orw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 13 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Outb Op0 Op1) (outb: Op0 Op1))

; outb imm8 _Al: Output byte in AL to I/O port address imm8.
(instance WriteInst.Outb.I8.|Al (forall W Error) (WriteInst W Error (Outb I8 |Al)) (where (Write W Error))
  (function (write-inst! w inst)
    ; E6 ib
    (with1 (outb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 230 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; outb _Dx _Al: Output byte in AL to I/O port address in DX.
(instance WriteInst.Outb.|Dx.|Al (forall W Error) (WriteInst W Error (Outb |Dx |Al)) (where (Write W Error))
  (function (write-inst! w inst)
    ; EE
    (with1 (outb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 238 w)!
        (ok unit)))))

(value-data (Outl Op0 Op1) (outl: Op0 Op1))

; outl imm8 _Eax: Output doubleword in EAX to I/O port address imm8.
(instance WriteInst.Outl.I8.|Eax (forall W Error) (WriteInst W Error (Outl I8 |Eax)) (where (Write W Error))
  (function (write-inst! w inst)
    ; E7 ib
    (with1 (outl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 231 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; outl _Dx _Eax: Output doubleword in EAX to I/O port address in DX.
(instance WriteInst.Outl.|Dx.|Eax (forall W Error) (WriteInst W Error (Outl |Dx |Eax)) (where (Write W Error))
  (function (write-inst! w inst)
    ; EF
    (with1 (outl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 239 w)!
        (ok unit)))))

(value-data (Outw Op0 Op1) (outw: Op0 Op1))

; outw imm8 _Ax: Output word in AX to I/O port address imm8.
(instance WriteInst.Outw.I8.|Ax (forall W Error) (WriteInst W Error (Outw I8 |Ax)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 E7 ib
    (with1 (outw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 231 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; outw _Dx _Ax: Output word in AX to I/O port address in DX.
(instance WriteInst.Outw.|Dx.|Ax (forall W Error) (WriteInst W Error (Outw |Dx |Ax)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 EF
    (with1 (outw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 239 w)!
        (ok unit)))))

(value-data (Packssdw Op0 Op1) (packssdw: Op0 Op1))

; packssdw xmm xmm: Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.
(instance WriteInst.Packssdw.Xmm.Xmm (forall W Error) (WriteInst W Error (Packssdw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6B /r
    (with1 (packssdw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 107 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; packssdw xmm m128: Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.
(instance WriteInst.Packssdw.Xmm.Memory (forall W Error) (WriteInst W Error (Packssdw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6B /r
    (with1 (packssdw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 107 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Packsswb Op0 Op1) (packsswb: Op0 Op1))

; packsswb xmm xmm: Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.
(instance WriteInst.Packsswb.Xmm.Xmm (forall W Error) (WriteInst W Error (Packsswb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 63 /r
    (with1 (packsswb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 99 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; packsswb xmm m128: Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.
(instance WriteInst.Packsswb.Xmm.Memory (forall W Error) (WriteInst W Error (Packsswb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 63 /r
    (with1 (packsswb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 99 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Packusdw Op0 Op1) (packusdw: Op0 Op1))

; packusdw xmm xmm: Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
(instance WriteInst.Packusdw.Xmm.Xmm (forall W Error) (WriteInst W Error (Packusdw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 2B /r
    (with1 (packusdw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; packusdw xmm m128: Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.
(instance WriteInst.Packusdw.Xmm.Memory (forall W Error) (WriteInst W Error (Packusdw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 2B /r
    (with1 (packusdw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Packuswb Op0 Op1) (packuswb: Op0 Op1))

; packuswb xmm xmm: Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
(instance WriteInst.Packuswb.Xmm.Xmm (forall W Error) (WriteInst W Error (Packuswb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 67 /r
    (with1 (packuswb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 103 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; packuswb xmm m128: Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.
(instance WriteInst.Packuswb.Xmm.Memory (forall W Error) (WriteInst W Error (Packuswb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 67 /r
    (with1 (packuswb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 103 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Paddb Op0 Op1) (paddb: Op0 Op1))

; paddb xmm xmm: Add packed byte integers from xmm2/m128 and xmm1.
(instance WriteInst.Paddb.Xmm.Xmm (forall W Error) (WriteInst W Error (Paddb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FC /r
    (with1 (paddb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 252 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; paddb xmm m128: Add packed byte integers from xmm2/m128 and xmm1.
(instance WriteInst.Paddb.Xmm.Memory (forall W Error) (WriteInst W Error (Paddb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FC /r
    (with1 (paddb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 252 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Paddd Op0 Op1) (paddd: Op0 Op1))

; paddd xmm xmm: Add packed doubleword integers from xmm2/m128 and xmm1.
(instance WriteInst.Paddd.Xmm.Xmm (forall W Error) (WriteInst W Error (Paddd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FE /r
    (with1 (paddd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 254 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; paddd xmm m128: Add packed doubleword integers from xmm2/m128 and xmm1.
(instance WriteInst.Paddd.Xmm.Memory (forall W Error) (WriteInst W Error (Paddd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FE /r
    (with1 (paddd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 254 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Paddq Op0 Op1) (paddq: Op0 Op1))

; paddq xmm xmm: Add packed quadword integers xmm2/m128 to xmm1.
(instance WriteInst.Paddq.Xmm.Xmm (forall W Error) (WriteInst W Error (Paddq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D4 /r
    (with1 (paddq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 212 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; paddq xmm m128: Add packed quadword integers xmm2/m128 to xmm1.
(instance WriteInst.Paddq.Xmm.Memory (forall W Error) (WriteInst W Error (Paddq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D4 /r
    (with1 (paddq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 212 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Paddsb Op0 Op1) (paddsb: Op0 Op1))

; paddsb xmm xmm: Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.
(instance WriteInst.Paddsb.Xmm.Xmm (forall W Error) (WriteInst W Error (Paddsb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EC /r
    (with1 (paddsb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 236 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; paddsb xmm m128: Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.
(instance WriteInst.Paddsb.Xmm.Memory (forall W Error) (WriteInst W Error (Paddsb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EC /r
    (with1 (paddsb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 236 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Paddsw Op0 Op1) (paddsw: Op0 Op1))

; paddsw xmm xmm: Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.
(instance WriteInst.Paddsw.Xmm.Xmm (forall W Error) (WriteInst W Error (Paddsw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F ED /r
    (with1 (paddsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 237 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; paddsw xmm m128: Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.
(instance WriteInst.Paddsw.Xmm.Memory (forall W Error) (WriteInst W Error (Paddsw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F ED /r
    (with1 (paddsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 237 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Paddusb Op0 Op1) (paddusb: Op0 Op1))

; paddusb xmm xmm: Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.
(instance WriteInst.Paddusb.Xmm.Xmm (forall W Error) (WriteInst W Error (Paddusb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DC /r
    (with1 (paddusb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 220 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; paddusb xmm m128: Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.
(instance WriteInst.Paddusb.Xmm.Memory (forall W Error) (WriteInst W Error (Paddusb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DC /r
    (with1 (paddusb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 220 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Paddusw Op0 Op1) (paddusw: Op0 Op1))

; paddusw xmm xmm: Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.
(instance WriteInst.Paddusw.Xmm.Xmm (forall W Error) (WriteInst W Error (Paddusw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DD /r
    (with1 (paddusw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 221 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; paddusw xmm m128: Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.
(instance WriteInst.Paddusw.Xmm.Memory (forall W Error) (WriteInst W Error (Paddusw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DD /r
    (with1 (paddusw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 221 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Paddw Op0 Op1) (paddw: Op0 Op1))

; paddw xmm xmm: Add packed word integers from xmm2/m128 and xmm1.
(instance WriteInst.Paddw.Xmm.Xmm (forall W Error) (WriteInst W Error (Paddw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FD /r
    (with1 (paddw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 253 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; paddw xmm m128: Add packed word integers from xmm2/m128 and xmm1.
(instance WriteInst.Paddw.Xmm.Memory (forall W Error) (WriteInst W Error (Paddw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FD /r
    (with1 (paddw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 253 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pand Op0 Op1) (pand: Op0 Op1))

; pand xmm xmm: Bitwise AND of xmm2/m128 and xmm1.
(instance WriteInst.Pand.Xmm.Xmm (forall W Error) (WriteInst W Error (Pand Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DB /r
    (with1 (pand: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 219 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pand xmm m128: Bitwise AND of xmm2/m128 and xmm1.
(instance WriteInst.Pand.Xmm.Memory (forall W Error) (WriteInst W Error (Pand Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DB /r
    (with1 (pand: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 219 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pandn Op0 Op1) (pandn: Op0 Op1))

; pandn xmm xmm: Bitwise AND NOT of xmm2/m128 and xmm1.
(instance WriteInst.Pandn.Xmm.Xmm (forall W Error) (WriteInst W Error (Pandn Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DF /r
    (with1 (pandn: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 223 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pandn xmm m128: Bitwise AND NOT of xmm2/m128 and xmm1.
(instance WriteInst.Pandn.Xmm.Memory (forall W Error) (WriteInst W Error (Pandn Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DF /r
    (with1 (pandn: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 223 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Pause pause:)

; pause: Gives hint to processor that improves performance of spin-wait loops.
(instance WriteInst.Pause (forall W Error) (WriteInst W Error Pause) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 90
    (with1 pause: inst
      (let ()
        (write-u8! 243 w)!
        (write-u8! 144 w)!
        (ok unit)))))

(value-data (Pavgb Op0 Op1) (pavgb: Op0 Op1))

; pavgb xmm xmm: Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.
(instance WriteInst.Pavgb.Xmm.Xmm (forall W Error) (WriteInst W Error (Pavgb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E0 /r
    (with1 (pavgb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 224 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pavgb xmm m128: Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.
(instance WriteInst.Pavgb.Xmm.Memory (forall W Error) (WriteInst W Error (Pavgb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E0 /r
    (with1 (pavgb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 224 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pavgw Op0 Op1) (pavgw: Op0 Op1))

; pavgw xmm xmm: Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.
(instance WriteInst.Pavgw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pavgw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E3 /r
    (with1 (pavgw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 227 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pavgw xmm m128: Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.
(instance WriteInst.Pavgw.Xmm.Memory (forall W Error) (WriteInst W Error (Pavgw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E3 /r
    (with1 (pavgw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 227 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pblendvb Op0 Op1 Op2) (pblendvb: Op0 Op1 Op2))

; pblendvb xmm xmm _Xmm0: Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.
(instance WriteInst.Pblendvb.Xmm.Xmm.|Xmm0 (forall W Error) (WriteInst W Error (Pblendvb Xmm Xmm |Xmm0)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 10 /r
    (with1 (pblendvb: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pblendvb xmm m128 _Xmm0: Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.
(instance WriteInst.Pblendvb.Xmm.Memory.|Xmm0 (forall W Error) (WriteInst W Error (Pblendvb Xmm Memory |Xmm0)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 10 /r
    (with1 (pblendvb: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 16 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pblendw Op0 Op1 Op2) (pblendw: Op0 Op1 Op2))

; pblendw xmm xmm imm8: Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
(instance WriteInst.Pblendw.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Pblendw Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0E /r ib
    (with1 (pblendw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 14 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pblendw xmm m128 imm8: Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.
(instance WriteInst.Pblendw.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pblendw Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0E /r ib
    (with1 (pblendw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 14 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pcmpeqb Op0 Op1) (pcmpeqb: Op0 Op1))

; pcmpeqb xmm xmm: Compare packed bytes in xmm2/m128 and xmm1 for equality.
(instance WriteInst.Pcmpeqb.Xmm.Xmm (forall W Error) (WriteInst W Error (Pcmpeqb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 74 /r
    (with1 (pcmpeqb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 116 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pcmpeqb xmm m128: Compare packed bytes in xmm2/m128 and xmm1 for equality.
(instance WriteInst.Pcmpeqb.Xmm.Memory (forall W Error) (WriteInst W Error (Pcmpeqb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 74 /r
    (with1 (pcmpeqb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 116 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pcmpeqd Op0 Op1) (pcmpeqd: Op0 Op1))

; pcmpeqd xmm xmm: Compare packed doublewords in xmm2/m128 and xmm1 for equality.
(instance WriteInst.Pcmpeqd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pcmpeqd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 76 /r
    (with1 (pcmpeqd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 118 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pcmpeqd xmm m128: Compare packed doublewords in xmm2/m128 and xmm1 for equality.
(instance WriteInst.Pcmpeqd.Xmm.Memory (forall W Error) (WriteInst W Error (Pcmpeqd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 76 /r
    (with1 (pcmpeqd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 118 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pcmpeqq Op0 Op1) (pcmpeqq: Op0 Op1))

; pcmpeqq xmm xmm: Compare packed qwords in xmm2/m128 and xmm1 for equality.
(instance WriteInst.Pcmpeqq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pcmpeqq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 29 /r
    (with1 (pcmpeqq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 41 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pcmpeqq xmm m128: Compare packed qwords in xmm2/m128 and xmm1 for equality.
(instance WriteInst.Pcmpeqq.Xmm.Memory (forall W Error) (WriteInst W Error (Pcmpeqq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 29 /r
    (with1 (pcmpeqq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 41 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pcmpeqw Op0 Op1) (pcmpeqw: Op0 Op1))

; pcmpeqw xmm xmm: Compare packed words in xmm2/m128 and xmm1 for equality.
(instance WriteInst.Pcmpeqw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pcmpeqw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 75 /r
    (with1 (pcmpeqw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 117 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pcmpeqw xmm m128: Compare packed words in xmm2/m128 and xmm1 for equality.
(instance WriteInst.Pcmpeqw.Xmm.Memory (forall W Error) (WriteInst W Error (Pcmpeqw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 75 /r
    (with1 (pcmpeqw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 117 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pcmpestri Op0 Op1 Op2) (pcmpestri: Op0 Op1 Op2))

; pcmpestri xmm xmm imm8: Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
(instance WriteInst.Pcmpestri.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Pcmpestri Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 61 /r ib
    (with1 (pcmpestri: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 97 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pcmpestri xmm m128 imm8: Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.
(instance WriteInst.Pcmpestri.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pcmpestri Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 61 /r ib
    (with1 (pcmpestri: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 97 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pcmpestrm Op0 Op1 Op2) (pcmpestrm: Op0 Op1 Op2))

; pcmpestrm xmm xmm imm8: Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0
(instance WriteInst.Pcmpestrm.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Pcmpestrm Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 60 /r ib
    (with1 (pcmpestrm: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 96 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pcmpestrm xmm m128 imm8: Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0
(instance WriteInst.Pcmpestrm.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pcmpestrm Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 60 /r ib
    (with1 (pcmpestrm: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 96 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pcmpgtb Op0 Op1) (pcmpgtb: Op0 Op1))

; pcmpgtb xmm xmm: Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.
(instance WriteInst.Pcmpgtb.Xmm.Xmm (forall W Error) (WriteInst W Error (Pcmpgtb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 64 /r
    (with1 (pcmpgtb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 100 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pcmpgtb xmm m128: Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.
(instance WriteInst.Pcmpgtb.Xmm.Memory (forall W Error) (WriteInst W Error (Pcmpgtb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 64 /r
    (with1 (pcmpgtb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 100 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pcmpgtd Op0 Op1) (pcmpgtd: Op0 Op1))

; pcmpgtd xmm xmm: Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.
(instance WriteInst.Pcmpgtd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pcmpgtd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 66 /r
    (with1 (pcmpgtd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 102 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pcmpgtd xmm m128: Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.
(instance WriteInst.Pcmpgtd.Xmm.Memory (forall W Error) (WriteInst W Error (Pcmpgtd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 66 /r
    (with1 (pcmpgtd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 102 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pcmpgtq Op0 Op1) (pcmpgtq: Op0 Op1))

; pcmpgtq xmm xmm: Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.
(instance WriteInst.Pcmpgtq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pcmpgtq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 37 /r
    (with1 (pcmpgtq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 55 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pcmpgtq xmm m128: Compare packed signed qwords in xmm2/m128 and xmm1 for greater than.
(instance WriteInst.Pcmpgtq.Xmm.Memory (forall W Error) (WriteInst W Error (Pcmpgtq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 37 /r
    (with1 (pcmpgtq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 55 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pcmpgtw Op0 Op1) (pcmpgtw: Op0 Op1))

; pcmpgtw xmm xmm: Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.
(instance WriteInst.Pcmpgtw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pcmpgtw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 65 /r
    (with1 (pcmpgtw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 101 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pcmpgtw xmm m128: Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.
(instance WriteInst.Pcmpgtw.Xmm.Memory (forall W Error) (WriteInst W Error (Pcmpgtw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 65 /r
    (with1 (pcmpgtw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 101 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pcmpistri Op0 Op1 Op2) (pcmpistri: Op0 Op1 Op2))

; pcmpistri xmm xmm imm8: Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
(instance WriteInst.Pcmpistri.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Pcmpistri Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 63 /r ib
    (with1 (pcmpistri: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 99 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pcmpistri xmm m128 imm8: Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.
(instance WriteInst.Pcmpistri.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pcmpistri Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 63 /r ib
    (with1 (pcmpistri: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 99 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pcmpistrm Op0 Op1 Op2) (pcmpistrm: Op0 Op1 Op2))

; pcmpistrm xmm xmm imm8: Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
(instance WriteInst.Pcmpistrm.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Pcmpistrm Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 62 /r ib
    (with1 (pcmpistrm: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 98 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pcmpistrm xmm m128 imm8: Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.
(instance WriteInst.Pcmpistrm.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pcmpistrm Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 62 /r ib
    (with1 (pcmpistrm: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 98 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pextrb Op0 Op1 Op2) (pextrb: Op0 Op1 Op2))

; pextrb reg xmm imm8: Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.
(instance WriteInst.Pextrb.Gpr64.Xmm.I8 (forall W Error) (WriteInst W Error (Pextrb Gpr64 Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 14 /r ib
    (with1 (pextrb: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 20 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pextrb m8 xmm imm8: Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.
(instance WriteInst.Pextrb.Memory.Xmm.I8 (forall W Error) (WriteInst W Error (Pextrb Memory Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 14 /r ib
    (with1 (pextrb: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 20 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pextrd Op0 Op1 Op2) (pextrd: Op0 Op1 Op2))

; pextrd r32 xmm imm8: Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.
(instance WriteInst.Pextrd.Gpr32.Xmm.I8 (forall W Error) (WriteInst W Error (Pextrd Gpr32 Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 16 /r ib
    (with1 (pextrd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 22 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pextrd m32 xmm imm8: Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.
(instance WriteInst.Pextrd.Memory.Xmm.I8 (forall W Error) (WriteInst W Error (Pextrd Memory Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 16 /r ib
    (with1 (pextrd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 22 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pextrq Op0 Op1 Op2) (pextrq: Op0 Op1 Op2))

; pextrq r64 xmm imm8: Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.
(instance WriteInst.Pextrq.Gpr64.Xmm.I8 (forall W Error) (WriteInst W Error (Pextrq Gpr64 Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 REX.W+ 0F 3A 16 /r ib
    (with1 (pextrq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 22 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pextrq m64 xmm imm8: Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.
(instance WriteInst.Pextrq.Memory.Xmm.I8 (forall W Error) (WriteInst W Error (Pextrq Memory Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 REX.W+ 0F 3A 16 /r ib
    (with1 (pextrq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 22 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pextrw Op0 Op1 Op2) (pextrw: Op0 Op1 Op2))

; pextrw reg xmm imm8: Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.
(instance WriteInst.Pextrw.Gpr64.Xmm.I8 (forall W Error) (WriteInst W Error (Pextrw Gpr64 Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C5 /r ib
    (with1 (pextrw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 197 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pextrw m16 xmm imm8: Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.
(instance WriteInst.Pextrw.Memory.Xmm.I8 (forall W Error) (WriteInst W Error (Pextrw Memory Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 15 /r ib
    (with1 (pextrw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 21 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Phminposuw Op0 Op1) (phminposuw: Op0 Op1))

; phminposuw xmm xmm: Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
(instance WriteInst.Phminposuw.Xmm.Xmm (forall W Error) (WriteInst W Error (Phminposuw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 41 /r
    (with1 (phminposuw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 65 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; phminposuw xmm m128: Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.
(instance WriteInst.Phminposuw.Xmm.Memory (forall W Error) (WriteInst W Error (Phminposuw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 41 /r
    (with1 (phminposuw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 65 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pinsrb Op0 Op1 Op2) (pinsrb: Op0 Op1 Op2))

; pinsrb xmm r32 imm8: Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.
(instance WriteInst.Pinsrb.Xmm.Gpr32.I8 (forall W Error) (WriteInst W Error (Pinsrb Xmm Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 20 /r ib
    (with1 (pinsrb: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 32 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pinsrb xmm m8 imm8: Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8.
(instance WriteInst.Pinsrb.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pinsrb Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 20 /r ib
    (with1 (pinsrb: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 32 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pinsrd Op0 Op1 Op2) (pinsrd: Op0 Op1 Op2))

; pinsrd xmm r32 imm8: Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.
(instance WriteInst.Pinsrd.Xmm.Gpr32.I8 (forall W Error) (WriteInst W Error (Pinsrd Xmm Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 22 /r ib
    (with1 (pinsrd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 34 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pinsrd xmm m32 imm8: Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.
(instance WriteInst.Pinsrd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pinsrd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 22 /r ib
    (with1 (pinsrd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 34 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pinsrw Op0 Op1 Op2) (pinsrw: Op0 Op1 Op2))

; pinsrw xmm r32 imm8: Move the low word of r32 or from m16 into xmm at the word position specified by imm8.
(instance WriteInst.Pinsrw.Xmm.Gpr32.I8 (forall W Error) (WriteInst W Error (Pinsrw Xmm Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C4 /r ib
    (with1 (pinsrw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 196 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pinsrw xmm m16 imm8: Move the low word of r32 or from m16 into xmm at the word position specified by imm8.
(instance WriteInst.Pinsrw.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pinsrw Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C4 /r ib
    (with1 (pinsrw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 196 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pmaddwd Op0 Op1) (pmaddwd: Op0 Op1))

; pmaddwd xmm xmm: Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.
(instance WriteInst.Pmaddwd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmaddwd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F5 /r
    (with1 (pmaddwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 245 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmaddwd xmm m128: Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.
(instance WriteInst.Pmaddwd.Xmm.Memory (forall W Error) (WriteInst W Error (Pmaddwd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F5 /r
    (with1 (pmaddwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 245 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmaxsb Op0 Op1) (pmaxsb: Op0 Op1))

; pmaxsb xmm xmm: Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
(instance WriteInst.Pmaxsb.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmaxsb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3C /r
    (with1 (pmaxsb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 60 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmaxsb xmm m128: Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
(instance WriteInst.Pmaxsb.Xmm.Memory (forall W Error) (WriteInst W Error (Pmaxsb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3C /r
    (with1 (pmaxsb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 60 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmaxsd Op0 Op1) (pmaxsd: Op0 Op1))

; pmaxsd xmm xmm: Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
(instance WriteInst.Pmaxsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmaxsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3D /r
    (with1 (pmaxsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 61 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmaxsd xmm m128: Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
(instance WriteInst.Pmaxsd.Xmm.Memory (forall W Error) (WriteInst W Error (Pmaxsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3D /r
    (with1 (pmaxsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 61 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmaxsw Op0 Op1) (pmaxsw: Op0 Op1))

; pmaxsw xmm xmm: Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.
(instance WriteInst.Pmaxsw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmaxsw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EE /r
    (with1 (pmaxsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 238 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmaxsw xmm m128: Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.
(instance WriteInst.Pmaxsw.Xmm.Memory (forall W Error) (WriteInst W Error (Pmaxsw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EE /r
    (with1 (pmaxsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 238 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmaxub Op0 Op1) (pmaxub: Op0 Op1))

; pmaxub xmm xmm: Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.
(instance WriteInst.Pmaxub.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmaxub Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DE /r
    (with1 (pmaxub: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 222 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmaxub xmm m128: Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.
(instance WriteInst.Pmaxub.Xmm.Memory (forall W Error) (WriteInst W Error (Pmaxub Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DE /r
    (with1 (pmaxub: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 222 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmaxud Op0 Op1) (pmaxud: Op0 Op1))

; pmaxud xmm xmm: Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
(instance WriteInst.Pmaxud.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmaxud Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3F /r
    (with1 (pmaxud: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 63 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmaxud xmm m128: Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
(instance WriteInst.Pmaxud.Xmm.Memory (forall W Error) (WriteInst W Error (Pmaxud Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3F /r
    (with1 (pmaxud: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 63 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmaxuw Op0 Op1) (pmaxuw: Op0 Op1))

; pmaxuw xmm xmm: Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
(instance WriteInst.Pmaxuw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmaxuw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3E /r
    (with1 (pmaxuw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 62 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmaxuw xmm m128: Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.
(instance WriteInst.Pmaxuw.Xmm.Memory (forall W Error) (WriteInst W Error (Pmaxuw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3E /r
    (with1 (pmaxuw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 62 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pminsb Op0 Op1) (pminsb: Op0 Op1))

; pminsb xmm xmm: Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
(instance WriteInst.Pminsb.Xmm.Xmm (forall W Error) (WriteInst W Error (Pminsb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 /r
    (with1 (pminsb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pminsb xmm m128: Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
(instance WriteInst.Pminsb.Xmm.Memory (forall W Error) (WriteInst W Error (Pminsb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 /r
    (with1 (pminsb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pminsd Op0 Op1) (pminsd: Op0 Op1))

; pminsd xmm xmm: Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
(instance WriteInst.Pminsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pminsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 39 /r
    (with1 (pminsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 57 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pminsd xmm m128: Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
(instance WriteInst.Pminsd.Xmm.Memory (forall W Error) (WriteInst W Error (Pminsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 39 /r
    (with1 (pminsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 57 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pminsw Op0 Op1) (pminsw: Op0 Op1))

; pminsw xmm xmm: Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.
(instance WriteInst.Pminsw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pminsw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EA /r
    (with1 (pminsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 234 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pminsw xmm m128: Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.
(instance WriteInst.Pminsw.Xmm.Memory (forall W Error) (WriteInst W Error (Pminsw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EA /r
    (with1 (pminsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 234 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pminub Op0 Op1) (pminub: Op0 Op1))

; pminub xmm xmm: Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.
(instance WriteInst.Pminub.Xmm.Xmm (forall W Error) (WriteInst W Error (Pminub Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DA /r
    (with1 (pminub: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 218 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pminub xmm m128: Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.
(instance WriteInst.Pminub.Xmm.Memory (forall W Error) (WriteInst W Error (Pminub Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F DA /r
    (with1 (pminub: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 218 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pminud Op0 Op1) (pminud: Op0 Op1))

; pminud xmm xmm: Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
(instance WriteInst.Pminud.Xmm.Xmm (forall W Error) (WriteInst W Error (Pminud Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3B /r
    (with1 (pminud: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 59 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pminud xmm m128: Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
(instance WriteInst.Pminud.Xmm.Memory (forall W Error) (WriteInst W Error (Pminud Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3B /r
    (with1 (pminud: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 59 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pminuw Op0 Op1) (pminuw: Op0 Op1))

; pminuw xmm xmm: Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
(instance WriteInst.Pminuw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pminuw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3A /r
    (with1 (pminuw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 58 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pminuw xmm m128: Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.
(instance WriteInst.Pminuw.Xmm.Memory (forall W Error) (WriteInst W Error (Pminuw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 3A /r
    (with1 (pminuw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 58 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovmskb Op0 Op1) (pmovmskb: Op0 Op1))

; pmovmskb reg xmm: Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed
(instance WriteInst.Pmovmskb.Gpr64.Xmm (forall W Error) (WriteInst W Error (Pmovmskb Gpr64 Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D7 /r
    (with1 (pmovmskb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 215 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovsxbd Op0 Op1) (pmovsxbd: Op0 Op1))

; pmovsxbd xmm xmm: Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.
(instance WriteInst.Pmovsxbd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovsxbd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 21 /r
    (with1 (pmovsxbd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 33 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovsxbd xmm m32: Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.
(instance WriteInst.Pmovsxbd.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovsxbd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 21 /r
    (with1 (pmovsxbd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 33 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovsxbq Op0 Op1) (pmovsxbq: Op0 Op1))

; pmovsxbq xmm xmm: Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.
(instance WriteInst.Pmovsxbq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovsxbq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 22 /r
    (with1 (pmovsxbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 34 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovsxbq xmm m16: Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.
(instance WriteInst.Pmovsxbq.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovsxbq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 22 /r
    (with1 (pmovsxbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 34 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovsxbw Op0 Op1) (pmovsxbw: Op0 Op1))

; pmovsxbw xmm xmm: Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.
(instance WriteInst.Pmovsxbw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovsxbw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 20 /r
    (with1 (pmovsxbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 32 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovsxbw xmm m64: Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.
(instance WriteInst.Pmovsxbw.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovsxbw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 20 /r
    (with1 (pmovsxbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 32 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovsxdq Op0 Op1) (pmovsxdq: Op0 Op1))

; pmovsxdq xmm xmm: Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.
(instance WriteInst.Pmovsxdq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovsxdq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 25 /r
    (with1 (pmovsxdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 37 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovsxdq xmm m64: Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.
(instance WriteInst.Pmovsxdq.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovsxdq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 25 /r
    (with1 (pmovsxdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 37 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovsxwd Op0 Op1) (pmovsxwd: Op0 Op1))

; pmovsxwd xmm xmm: Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.
(instance WriteInst.Pmovsxwd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovsxwd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 23 /r
    (with1 (pmovsxwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 35 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovsxwd xmm m64: Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.
(instance WriteInst.Pmovsxwd.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovsxwd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 23 /r
    (with1 (pmovsxwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 35 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovsxwq Op0 Op1) (pmovsxwq: Op0 Op1))

; pmovsxwq xmm xmm: Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.
(instance WriteInst.Pmovsxwq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovsxwq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 24 /r
    (with1 (pmovsxwq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 36 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovsxwq xmm m32: Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.
(instance WriteInst.Pmovsxwq.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovsxwq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 24 /r
    (with1 (pmovsxwq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 36 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovzxbd Op0 Op1) (pmovzxbd: Op0 Op1))

; pmovzxbd xmm xmm: Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
(instance WriteInst.Pmovzxbd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovzxbd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 31 /r
    (with1 (pmovzxbd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 49 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovzxbd xmm m32: Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.
(instance WriteInst.Pmovzxbd.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovzxbd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 31 /r
    (with1 (pmovzxbd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 49 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovzxbq Op0 Op1) (pmovzxbq: Op0 Op1))

; pmovzxbq xmm xmm: Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
(instance WriteInst.Pmovzxbq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovzxbq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 32 /r
    (with1 (pmovzxbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 50 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovzxbq xmm m16: Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.
(instance WriteInst.Pmovzxbq.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovzxbq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 32 /r
    (with1 (pmovzxbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 50 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovzxbw Op0 Op1) (pmovzxbw: Op0 Op1))

; pmovzxbw xmm xmm: Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
(instance WriteInst.Pmovzxbw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovzxbw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 30 /r
    (with1 (pmovzxbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 48 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovzxbw xmm m64: Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.
(instance WriteInst.Pmovzxbw.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovzxbw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 30 /r
    (with1 (pmovzxbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 48 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovzxdq Op0 Op1) (pmovzxdq: Op0 Op1))

; pmovzxdq xmm xmm: Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
(instance WriteInst.Pmovzxdq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovzxdq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 35 /r
    (with1 (pmovzxdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 53 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovzxdq xmm m64: Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.
(instance WriteInst.Pmovzxdq.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovzxdq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 35 /r
    (with1 (pmovzxdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 53 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovzxwd Op0 Op1) (pmovzxwd: Op0 Op1))

; pmovzxwd xmm xmm: Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
(instance WriteInst.Pmovzxwd.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovzxwd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 33 /r
    (with1 (pmovzxwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 51 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovzxwd xmm m64: Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.
(instance WriteInst.Pmovzxwd.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovzxwd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 33 /r
    (with1 (pmovzxwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 51 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmovzxwq Op0 Op1) (pmovzxwq: Op0 Op1))

; pmovzxwq xmm xmm: Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
(instance WriteInst.Pmovzxwq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmovzxwq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 34 /r
    (with1 (pmovzxwq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 52 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmovzxwq xmm m32: Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.
(instance WriteInst.Pmovzxwq.Xmm.Memory (forall W Error) (WriteInst W Error (Pmovzxwq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 34 /r
    (with1 (pmovzxwq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 52 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmuldq Op0 Op1) (pmuldq: Op0 Op1))

; pmuldq xmm xmm: Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.
(instance WriteInst.Pmuldq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmuldq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 28 /r
    (with1 (pmuldq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 40 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmuldq xmm m128: Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.
(instance WriteInst.Pmuldq.Xmm.Memory (forall W Error) (WriteInst W Error (Pmuldq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 28 /r
    (with1 (pmuldq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 40 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmulhuw Op0 Op1) (pmulhuw: Op0 Op1))

; pmulhuw xmm xmm: Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
(instance WriteInst.Pmulhuw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmulhuw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E4 /r
    (with1 (pmulhuw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 228 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmulhuw xmm m128: Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
(instance WriteInst.Pmulhuw.Xmm.Memory (forall W Error) (WriteInst W Error (Pmulhuw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E4 /r
    (with1 (pmulhuw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 228 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmulhw Op0 Op1) (pmulhw: Op0 Op1))

; pmulhw xmm xmm: Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
(instance WriteInst.Pmulhw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmulhw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E5 /r
    (with1 (pmulhw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 229 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmulhw xmm m128: Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.
(instance WriteInst.Pmulhw.Xmm.Memory (forall W Error) (WriteInst W Error (Pmulhw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E5 /r
    (with1 (pmulhw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 229 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmulld Op0 Op1) (pmulld: Op0 Op1))

; pmulld xmm xmm: Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.
(instance WriteInst.Pmulld.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmulld Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 40 /r
    (with1 (pmulld: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 64 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmulld xmm m128: Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.
(instance WriteInst.Pmulld.Xmm.Memory (forall W Error) (WriteInst W Error (Pmulld Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 40 /r
    (with1 (pmulld: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 64 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmullw Op0 Op1) (pmullw: Op0 Op1))

; pmullw xmm xmm: Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.
(instance WriteInst.Pmullw.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmullw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D5 /r
    (with1 (pmullw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 213 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmullw xmm m128: Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.
(instance WriteInst.Pmullw.Xmm.Memory (forall W Error) (WriteInst W Error (Pmullw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D5 /r
    (with1 (pmullw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 213 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pmuludq Op0 Op1) (pmuludq: Op0 Op1))

; pmuludq xmm xmm: Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.
(instance WriteInst.Pmuludq.Xmm.Xmm (forall W Error) (WriteInst W Error (Pmuludq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F4 /r
    (with1 (pmuludq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 244 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pmuludq xmm m128: Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.
(instance WriteInst.Pmuludq.Xmm.Memory (forall W Error) (WriteInst W Error (Pmuludq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F4 /r
    (with1 (pmuludq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 244 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Popcntl Op0 Op1) (popcntl: Op0 Op1))

; popcntl r32 r32: POPCNT on r/m32
(instance WriteInst.Popcntl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Popcntl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F B8 /r
    (with1 (popcntl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 184 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; popcntl r32 m32: POPCNT on r/m32
(instance WriteInst.Popcntl.Gpr32.Memory (forall W Error) (WriteInst W Error (Popcntl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F B8 /r
    (with1 (popcntl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 184 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Popcntq Op0 Op1) (popcntq: Op0 Op1))

; popcntq r64 r64: POPCNT on r/m64
(instance WriteInst.Popcntq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Popcntq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 REX.W+ 0F B8 /r
    (with1 (popcntq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 184 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; popcntq r64 m64: POPCNT on r/m64
(instance WriteInst.Popcntq.Gpr64.Memory (forall W Error) (WriteInst W Error (Popcntq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 REX.W+ 0F B8 /r
    (with1 (popcntq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 184 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Popcntw Op0 Op1) (popcntw: Op0 Op1))

; popcntw r16 r16: POPCNT on r/m16
(instance WriteInst.Popcntw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Popcntw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 66 0F B8 /r
    (with1 (popcntw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 184 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; popcntw r16 m16: POPCNT on r/m16
(instance WriteInst.Popcntw.Gpr16.Memory (forall W Error) (WriteInst W Error (Popcntw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 66 0F B8 /r
    (with1 (popcntw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 184 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Popfq popfq:)

; popfq: Pop top of stack and zero-extend into RFLAGS.
(instance WriteInst.Popfq (forall W Error) (WriteInst W Error Popfq) (where (Write W Error))
  (function (write-inst! w inst)
    ; 9D
    (with1 popfq: inst
      (let ()
        (write-u8! 157 w)!
        (ok unit)))))

(value-data Popfw popfw:)

; popfw: Pop top of stack into lower 16 bits of EFLAGS.
(instance WriteInst.Popfw (forall W Error) (WriteInst W Error Popfw) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 9D
    (with1 popfw: inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 157 w)!
        (ok unit)))))

(value-data (Popq Op0) (popq: Op0))

; popq r64: Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size.
(instance WriteInst.Popq.Gpr64 (forall W Error) (WriteInst W Error (Popq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 58 +ro
    (with1 (popq: (let op0)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 88 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

; popq m64: Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size.
(instance WriteInst.Popq.Memory (forall W Error) (WriteInst W Error (Popq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 8F /0
    (with1 (popq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 143 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Popw Op0) (popw: Op0))

; popw r16: Pop top of stack into r16; increment stack pointer.
(instance WriteInst.Popw.Gpr16 (forall W Error) (WriteInst W Error (Popw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 58 +rw
    (with1 (popw: (let op0)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 88 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

; popw m16: Pop top of stack into m16; increment stack pointer.
(instance WriteInst.Popw.Memory (forall W Error) (WriteInst W Error (Popw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 8F /0
    (with1 (popw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 143 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Por Op0 Op1) (por: Op0 Op1))

; por xmm xmm: Bitwise OR of xmm2/m128 and xmm1.
(instance WriteInst.Por.Xmm.Xmm (forall W Error) (WriteInst W Error (Por Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EB /r
    (with1 (por: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 235 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; por xmm m128: Bitwise OR of xmm2/m128 and xmm1.
(instance WriteInst.Por.Xmm.Memory (forall W Error) (WriteInst W Error (Por Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EB /r
    (with1 (por: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 235 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psadbw Op0 Op1) (psadbw: Op0 Op1))

; psadbw xmm xmm: Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
(instance WriteInst.Psadbw.Xmm.Xmm (forall W Error) (WriteInst W Error (Psadbw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F6 /r
    (with1 (psadbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psadbw xmm m128: Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.
(instance WriteInst.Psadbw.Xmm.Memory (forall W Error) (WriteInst W Error (Psadbw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F6 /r
    (with1 (psadbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pshufd Op0 Op1 Op2) (pshufd: Op0 Op1 Op2))

; pshufd xmm xmm imm8: Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
(instance WriteInst.Pshufd.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Pshufd Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 70 /r ib
    (with1 (pshufd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 112 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pshufd xmm m128 imm8: Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
(instance WriteInst.Pshufd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pshufd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 70 /r ib
    (with1 (pshufd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 112 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pshufhw Op0 Op1 Op2) (pshufhw: Op0 Op1 Op2))

; pshufhw xmm xmm imm8: Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
(instance WriteInst.Pshufhw.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Pshufhw Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 70 /r ib
    (with1 (pshufhw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 112 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pshufhw xmm m128 imm8: Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
(instance WriteInst.Pshufhw.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pshufhw Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 70 /r ib
    (with1 (pshufhw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 112 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pshuflw Op0 Op1 Op2) (pshuflw: Op0 Op1 Op2))

; pshuflw xmm xmm imm8: Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
(instance WriteInst.Pshuflw.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Pshuflw Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 70 /r ib
    (with1 (pshuflw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 112 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; pshuflw xmm m128 imm8: Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.
(instance WriteInst.Pshuflw.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Pshuflw Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 70 /r ib
    (with1 (pshuflw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 112 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Pslld Op0 Op1) (pslld: Op0 Op1))

; pslld xmm imm8: Shift doublewords in xmm1 left by imm8 while shifting in 0s.
(instance WriteInst.Pslld.Xmm.I8 (forall W Error) (WriteInst W Error (Pslld Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 72 /6 ib
    (with1 (pslld: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 114 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; pslld xmm xmm: Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.
(instance WriteInst.Pslld.Xmm.Xmm (forall W Error) (WriteInst W Error (Pslld Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F2 /r
    (with1 (pslld: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 242 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pslld xmm m128: Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.
(instance WriteInst.Pslld.Xmm.Memory (forall W Error) (WriteInst W Error (Pslld Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F2 /r
    (with1 (pslld: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 242 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pslldq Op0 Op1) (pslldq: Op0 Op1))

; pslldq xmm imm8: Shift xmm1 left by imm8 bytes while shifting in 0s.
(instance WriteInst.Pslldq.Xmm.I8 (forall W Error) (WriteInst W Error (Pslldq Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 73 /7 ib
    (with1 (pslldq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 115 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Psllq Op0 Op1) (psllq: Op0 Op1))

; psllq xmm imm8: Shift quadwords in xmm1 left by imm8 while shifting in 0s.
(instance WriteInst.Psllq.Xmm.I8 (forall W Error) (WriteInst W Error (Psllq Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 73 /6 ib
    (with1 (psllq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 115 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; psllq xmm xmm: Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.
(instance WriteInst.Psllq.Xmm.Xmm (forall W Error) (WriteInst W Error (Psllq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F3 /r
    (with1 (psllq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 243 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psllq xmm m128: Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.
(instance WriteInst.Psllq.Xmm.Memory (forall W Error) (WriteInst W Error (Psllq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F3 /r
    (with1 (psllq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 243 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psllw Op0 Op1) (psllw: Op0 Op1))

; psllw xmm imm8: Shift words in xmm1 left by imm8 while shifting in 0s.
(instance WriteInst.Psllw.Xmm.I8 (forall W Error) (WriteInst W Error (Psllw Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 71 /6 ib
    (with1 (psllw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 113 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; psllw xmm xmm: Shift words in xmm1 left by xmm2/m128 while shifting in 0s.
(instance WriteInst.Psllw.Xmm.Xmm (forall W Error) (WriteInst W Error (Psllw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F1 /r
    (with1 (psllw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 241 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psllw xmm m128: Shift words in xmm1 left by xmm2/m128 while shifting in 0s.
(instance WriteInst.Psllw.Xmm.Memory (forall W Error) (WriteInst W Error (Psllw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F1 /r
    (with1 (psllw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 241 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psrad Op0 Op1) (psrad: Op0 Op1))

; psrad xmm imm8: Shift doublewords in xmm1 right by imm8 while shifting in sign bits.
(instance WriteInst.Psrad.Xmm.I8 (forall W Error) (WriteInst W Error (Psrad Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 72 /4 ib
    (with1 (psrad: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 114 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; psrad xmm xmm: Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.
(instance WriteInst.Psrad.Xmm.Xmm (forall W Error) (WriteInst W Error (Psrad Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E2 /r
    (with1 (psrad: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 226 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psrad xmm m128: Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.
(instance WriteInst.Psrad.Xmm.Memory (forall W Error) (WriteInst W Error (Psrad Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E2 /r
    (with1 (psrad: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 226 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psraw Op0 Op1) (psraw: Op0 Op1))

; psraw xmm imm8: Shift words in xmm1 right by imm8 while shifting in sign bits
(instance WriteInst.Psraw.Xmm.I8 (forall W Error) (WriteInst W Error (Psraw Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 71 /4 ib
    (with1 (psraw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 113 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; psraw xmm xmm: Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.
(instance WriteInst.Psraw.Xmm.Xmm (forall W Error) (WriteInst W Error (Psraw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E1 /r
    (with1 (psraw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 225 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psraw xmm m128: Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.
(instance WriteInst.Psraw.Xmm.Memory (forall W Error) (WriteInst W Error (Psraw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E1 /r
    (with1 (psraw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 225 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psrld Op0 Op1) (psrld: Op0 Op1))

; psrld xmm imm8: Shift doublewords in xmm1 right by imm8 while shifting in 0s.
(instance WriteInst.Psrld.Xmm.I8 (forall W Error) (WriteInst W Error (Psrld Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 72 /2 ib
    (with1 (psrld: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 114 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; psrld xmm xmm: Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.
(instance WriteInst.Psrld.Xmm.Xmm (forall W Error) (WriteInst W Error (Psrld Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D2 /r
    (with1 (psrld: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psrld xmm m128: Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.
(instance WriteInst.Psrld.Xmm.Memory (forall W Error) (WriteInst W Error (Psrld Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D2 /r
    (with1 (psrld: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psrldq Op0 Op1) (psrldq: Op0 Op1))

; psrldq xmm imm8: Shift xmm1 right by imm8 while shifting in 0s.
(instance WriteInst.Psrldq.Xmm.I8 (forall W Error) (WriteInst W Error (Psrldq Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 73 /3 ib
    (with1 (psrldq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 115 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Psrlq Op0 Op1) (psrlq: Op0 Op1))

; psrlq xmm imm8: Shift quadwords in xmm1 right by imm8 while shifting in 0s.
(instance WriteInst.Psrlq.Xmm.I8 (forall W Error) (WriteInst W Error (Psrlq Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 73 /2 ib
    (with1 (psrlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 115 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; psrlq xmm xmm: Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
(instance WriteInst.Psrlq.Xmm.Xmm (forall W Error) (WriteInst W Error (Psrlq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D3 /r
    (with1 (psrlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psrlq xmm m128: Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
(instance WriteInst.Psrlq.Xmm.Memory (forall W Error) (WriteInst W Error (Psrlq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D3 /r
    (with1 (psrlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psrlw Op0 Op1) (psrlw: Op0 Op1))

; psrlw xmm imm8: Shift words in xmm1 right by imm8 while shifting in 0s.
(instance WriteInst.Psrlw.Xmm.I8 (forall W Error) (WriteInst W Error (Psrlw Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 71 /2 ib
    (with1 (psrlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 113 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; psrlw xmm xmm: Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
(instance WriteInst.Psrlw.Xmm.Xmm (forall W Error) (WriteInst W Error (Psrlw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D1 /r
    (with1 (psrlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psrlw xmm m128: Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.
(instance WriteInst.Psrlw.Xmm.Memory (forall W Error) (WriteInst W Error (Psrlw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D1 /r
    (with1 (psrlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psubb Op0 Op1) (psubb: Op0 Op1))

; psubb xmm xmm: Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.
(instance WriteInst.Psubb.Xmm.Xmm (forall W Error) (WriteInst W Error (Psubb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F8 /r
    (with1 (psubb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 248 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psubb xmm m128: Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.
(instance WriteInst.Psubb.Xmm.Memory (forall W Error) (WriteInst W Error (Psubb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F8 /r
    (with1 (psubb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 248 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psubd Op0 Op1) (psubd: Op0 Op1))

; psubd xmm xmm: Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.
(instance WriteInst.Psubd.Xmm.Xmm (forall W Error) (WriteInst W Error (Psubd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FA /r
    (with1 (psubd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 250 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psubd xmm m128: Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.
(instance WriteInst.Psubd.Xmm.Memory (forall W Error) (WriteInst W Error (Psubd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FA /r
    (with1 (psubd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 250 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psubq Op0 Op1) (psubq: Op0 Op1))

; psubq xmm xmm: Subtract packed quadword integers in xmm1 from xmm2 /m128.
(instance WriteInst.Psubq.Xmm.Xmm (forall W Error) (WriteInst W Error (Psubq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FB /r
    (with1 (psubq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 251 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psubq xmm m128: Subtract packed quadword integers in xmm1 from xmm2 /m128.
(instance WriteInst.Psubq.Xmm.Memory (forall W Error) (WriteInst W Error (Psubq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F FB /r
    (with1 (psubq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 251 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psubsb Op0 Op1) (psubsb: Op0 Op1))

; psubsb xmm xmm: Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.
(instance WriteInst.Psubsb.Xmm.Xmm (forall W Error) (WriteInst W Error (Psubsb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E8 /r
    (with1 (psubsb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 232 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psubsb xmm m128: Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.
(instance WriteInst.Psubsb.Xmm.Memory (forall W Error) (WriteInst W Error (Psubsb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E8 /r
    (with1 (psubsb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 232 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psubsw Op0 Op1) (psubsw: Op0 Op1))

; psubsw xmm xmm: Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.
(instance WriteInst.Psubsw.Xmm.Xmm (forall W Error) (WriteInst W Error (Psubsw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E9 /r
    (with1 (psubsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 233 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psubsw xmm m128: Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.
(instance WriteInst.Psubsw.Xmm.Memory (forall W Error) (WriteInst W Error (Psubsw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F E9 /r
    (with1 (psubsw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 233 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psubusb Op0 Op1) (psubusb: Op0 Op1))

; psubusb xmm xmm: Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.
(instance WriteInst.Psubusb.Xmm.Xmm (forall W Error) (WriteInst W Error (Psubusb Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D8 /r
    (with1 (psubusb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 216 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psubusb xmm m128: Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.
(instance WriteInst.Psubusb.Xmm.Memory (forall W Error) (WriteInst W Error (Psubusb Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D8 /r
    (with1 (psubusb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 216 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psubusw Op0 Op1) (psubusw: Op0 Op1))

; psubusw xmm xmm: Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.
(instance WriteInst.Psubusw.Xmm.Xmm (forall W Error) (WriteInst W Error (Psubusw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D9 /r
    (with1 (psubusw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 217 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psubusw xmm m128: Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.
(instance WriteInst.Psubusw.Xmm.Memory (forall W Error) (WriteInst W Error (Psubusw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F D9 /r
    (with1 (psubusw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 217 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Psubw Op0 Op1) (psubw: Op0 Op1))

; psubw xmm xmm: Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.
(instance WriteInst.Psubw.Xmm.Xmm (forall W Error) (WriteInst W Error (Psubw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F9 /r
    (with1 (psubw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 249 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; psubw xmm m128: Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.
(instance WriteInst.Psubw.Xmm.Memory (forall W Error) (WriteInst W Error (Psubw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F F9 /r
    (with1 (psubw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 249 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Ptest Op0 Op1) (ptest: Op0 Op1))

; ptest xmm xmm: Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.
(instance WriteInst.Ptest.Xmm.Xmm (forall W Error) (WriteInst W Error (Ptest Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 17 /r
    (with1 (ptest: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 23 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; ptest xmm m128: Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.
(instance WriteInst.Ptest.Xmm.Memory (forall W Error) (WriteInst W Error (Ptest Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 38 17 /r
    (with1 (ptest: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 56 w)!
        (write-u8! 23 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Punpckhbw Op0 Op1) (punpckhbw: Op0 Op1))

; punpckhbw xmm xmm: Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckhbw.Xmm.Xmm (forall W Error) (WriteInst W Error (Punpckhbw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 68 /r
    (with1 (punpckhbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 104 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; punpckhbw xmm m128: Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckhbw.Xmm.Memory (forall W Error) (WriteInst W Error (Punpckhbw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 68 /r
    (with1 (punpckhbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 104 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Punpckhdq Op0 Op1) (punpckhdq: Op0 Op1))

; punpckhdq xmm xmm: Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckhdq.Xmm.Xmm (forall W Error) (WriteInst W Error (Punpckhdq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6A /r
    (with1 (punpckhdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 106 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; punpckhdq xmm m128: Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckhdq.Xmm.Memory (forall W Error) (WriteInst W Error (Punpckhdq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6A /r
    (with1 (punpckhdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 106 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Punpckhqdq Op0 Op1) (punpckhqdq: Op0 Op1))

; punpckhqdq xmm xmm: Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckhqdq.Xmm.Xmm (forall W Error) (WriteInst W Error (Punpckhqdq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6D /r
    (with1 (punpckhqdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 109 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; punpckhqdq xmm m128: Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckhqdq.Xmm.Memory (forall W Error) (WriteInst W Error (Punpckhqdq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6D /r
    (with1 (punpckhqdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 109 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Punpckhwd Op0 Op1) (punpckhwd: Op0 Op1))

; punpckhwd xmm xmm: Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckhwd.Xmm.Xmm (forall W Error) (WriteInst W Error (Punpckhwd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 69 /r
    (with1 (punpckhwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 105 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; punpckhwd xmm m128: Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckhwd.Xmm.Memory (forall W Error) (WriteInst W Error (Punpckhwd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 69 /r
    (with1 (punpckhwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 105 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Punpcklbw Op0 Op1) (punpcklbw: Op0 Op1))

; punpcklbw xmm xmm: Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpcklbw.Xmm.Xmm (forall W Error) (WriteInst W Error (Punpcklbw Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 60 /r
    (with1 (punpcklbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 96 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; punpcklbw xmm m128: Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpcklbw.Xmm.Memory (forall W Error) (WriteInst W Error (Punpcklbw Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 60 /r
    (with1 (punpcklbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 96 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Punpckldq Op0 Op1) (punpckldq: Op0 Op1))

; punpckldq xmm xmm: Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckldq.Xmm.Xmm (forall W Error) (WriteInst W Error (Punpckldq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 62 /r
    (with1 (punpckldq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 98 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; punpckldq xmm m128: Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpckldq.Xmm.Memory (forall W Error) (WriteInst W Error (Punpckldq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 62 /r
    (with1 (punpckldq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 98 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Punpcklqdq Op0 Op1) (punpcklqdq: Op0 Op1))

; punpcklqdq xmm xmm: Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.
(instance WriteInst.Punpcklqdq.Xmm.Xmm (forall W Error) (WriteInst W Error (Punpcklqdq Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6C /r
    (with1 (punpcklqdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 108 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; punpcklqdq xmm m128: Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.
(instance WriteInst.Punpcklqdq.Xmm.Memory (forall W Error) (WriteInst W Error (Punpcklqdq Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 6C /r
    (with1 (punpcklqdq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 108 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Punpcklwd Op0 Op1) (punpcklwd: Op0 Op1))

; punpcklwd xmm xmm: Interleave low-order words from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpcklwd.Xmm.Xmm (forall W Error) (WriteInst W Error (Punpcklwd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 61 /r
    (with1 (punpcklwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 97 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; punpcklwd xmm m128: Interleave low-order words from xmm1 and xmm2/m128 into xmm1.
(instance WriteInst.Punpcklwd.Xmm.Memory (forall W Error) (WriteInst W Error (Punpcklwd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 61 /r
    (with1 (punpcklwd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 97 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Pushfq pushfq:)

; pushfq: Push RFLAGS.
(instance WriteInst.Pushfq (forall W Error) (WriteInst W Error Pushfq) (where (Write W Error))
  (function (write-inst! w inst)
    ; 9C
    (with1 pushfq: inst
      (let ()
        (write-u8! 156 w)!
        (ok unit)))))

(value-data Pushfw pushfw:)

; pushfw: Push lower 16 bits of EFLAGS.
(instance WriteInst.Pushfw (forall W Error) (WriteInst W Error Pushfw) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 9C
    (with1 pushfw: inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 156 w)!
        (ok unit)))))

(value-data (Pushq Op0) (pushq: Op0))

; pushq r64: Push r64.
(instance WriteInst.Pushq.Gpr64 (forall W Error) (WriteInst W Error (Pushq Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 50 +ro
    (with1 (pushq: (let op0)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 80 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

; pushq imm8: Push imm8 (sign-extended to 64-bits).
(instance WriteInst.Pushq.I8 (forall W Error) (WriteInst W Error (Pushq I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 6A ib
    (with1 (pushq: (let op0)) inst
      (let ()
        (write-u8! 106 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; pushq imm16: Push imm16 (sign-extended to 64-bits).
(instance WriteInst.Pushq.I16 (forall W Error) (WriteInst W Error (Pushq I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 68 iw
    (with1 (pushq: (let op0)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 104 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; pushq imm32: Push imm32 (sign-extended to 64-bits).
(instance WriteInst.Pushq.I32 (forall W Error) (WriteInst W Error (Pushq I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 68 id
    (with1 (pushq: (let op0)) inst
      (let ()
        (write-u8! 104 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

; pushq m64: Push r/m64.
(instance WriteInst.Pushq.Memory (forall W Error) (WriteInst W Error (Pushq Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; FF /6
    (with1 (pushq: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pushw Op0) (pushw: Op0))

; pushw r16: Push r16.
(instance WriteInst.Pushw.Gpr16 (forall W Error) (WriteInst W Error (Pushw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 50 +rw
    (with1 (pushw: (let op0)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 80 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

; pushw m16: Push r/m16.
(instance WriteInst.Pushw.Memory (forall W Error) (WriteInst W Error (Pushw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 FF /6
    (with1 (pushw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 255 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Pxor Op0 Op1) (pxor: Op0 Op1))

; pxor xmm xmm: Bitwise XOR of xmm2/m128 and xmm1.
(instance WriteInst.Pxor.Xmm.Xmm (forall W Error) (WriteInst W Error (Pxor Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EF /r
    (with1 (pxor: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 239 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; pxor xmm m128: Bitwise XOR of xmm2/m128 and xmm1.
(instance WriteInst.Pxor.Xmm.Memory (forall W Error) (WriteInst W Error (Pxor Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F EF /r
    (with1 (pxor: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 239 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rclb Op0 Op1) (rclb: Op0 Op1))

; rclb r8 imm8: Rotate 9 bits (CF, r/m8) left imm8 times.
(instance WriteInst.Rclb.Gpr8.I8 (forall W Error) (WriteInst W Error (Rclb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /2 ib
    (with1 (rclb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rclb m8 imm8: Rotate 9 bits (CF, r/m8) left imm8 times.
(instance WriteInst.Rclb.Memory.I8 (forall W Error) (WriteInst W Error (Rclb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /2 ib
    (with1 (rclb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rclb r8 _1: Rotate 9 bits (CF, r/m8) left once.
(instance WriteInst.Rclb.Gpr8.|1 (forall W Error) (WriteInst W Error (Rclb Gpr8 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /2
    (with1 (rclb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclb m8 _1: Rotate 9 bits (CF, r/m8) left once.
(instance WriteInst.Rclb.Memory.|1 (forall W Error) (WriteInst W Error (Rclb Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /2
    (with1 (rclb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclb r8 _Cl: Rotate 9 bits (CF, r/m8) left CL times.
(instance WriteInst.Rclb.Gpr8.|Cl (forall W Error) (WriteInst W Error (Rclb Gpr8 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /2
    (with1 (rclb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclb m8 _Cl: Rotate 9 bits (CF, r/m8) left CL times.
(instance WriteInst.Rclb.Memory.|Cl (forall W Error) (WriteInst W Error (Rclb Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /2
    (with1 (rclb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rcll Op0 Op1) (rcll: Op0 Op1))

; rcll r32 imm8: Rotate 33 bits (CF, r/m32) left imm8 times.
(instance WriteInst.Rcll.Gpr32.I8 (forall W Error) (WriteInst W Error (Rcll Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /2 ib
    (with1 (rcll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcll m32 imm8: Rotate 33 bits (CF, r/m32) left imm8 times.
(instance WriteInst.Rcll.Memory.I8 (forall W Error) (WriteInst W Error (Rcll Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /2 ib
    (with1 (rcll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcll r32 _1: Rotate 33 bits (CF, r/m32) left once.
(instance WriteInst.Rcll.Gpr32.|1 (forall W Error) (WriteInst W Error (Rcll Gpr32 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /2
    (with1 (rcll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcll m32 _1: Rotate 33 bits (CF, r/m32) left once.
(instance WriteInst.Rcll.Memory.|1 (forall W Error) (WriteInst W Error (Rcll Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /2
    (with1 (rcll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcll r32 _Cl: Rotate 33 bits (CF, r/m32) left CL times.
(instance WriteInst.Rcll.Gpr32.|Cl (forall W Error) (WriteInst W Error (Rcll Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /2
    (with1 (rcll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcll m32 _Cl: Rotate 33 bits (CF, r/m32) left CL times.
(instance WriteInst.Rcll.Memory.|Cl (forall W Error) (WriteInst W Error (Rcll Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /2
    (with1 (rcll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rclq Op0 Op1) (rclq: Op0 Op1))

; rclq r64 imm8: Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.
(instance WriteInst.Rclq.Gpr64.I8 (forall W Error) (WriteInst W Error (Rclq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /2 ib
    (with1 (rclq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rclq m64 imm8: Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.
(instance WriteInst.Rclq.Memory.I8 (forall W Error) (WriteInst W Error (Rclq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /2 ib
    (with1 (rclq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rclq r64 _1: Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.
(instance WriteInst.Rclq.Gpr64.|1 (forall W Error) (WriteInst W Error (Rclq Gpr64 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /2
    (with1 (rclq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclq m64 _1: Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.
(instance WriteInst.Rclq.Memory.|1 (forall W Error) (WriteInst W Error (Rclq Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /2
    (with1 (rclq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclq r64 _Cl: Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.
(instance WriteInst.Rclq.Gpr64.|Cl (forall W Error) (WriteInst W Error (Rclq Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /2
    (with1 (rclq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclq m64 _Cl: Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.
(instance WriteInst.Rclq.Memory.|Cl (forall W Error) (WriteInst W Error (Rclq Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /2
    (with1 (rclq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rclw Op0 Op1) (rclw: Op0 Op1))

; rclw r16 imm8: Rotate 17 bits (CF, r/m16) left imm8 times.
(instance WriteInst.Rclw.Gpr16.I8 (forall W Error) (WriteInst W Error (Rclw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /2 ib
    (with1 (rclw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rclw m16 imm8: Rotate 17 bits (CF, r/m16) left imm8 times.
(instance WriteInst.Rclw.Memory.I8 (forall W Error) (WriteInst W Error (Rclw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /2 ib
    (with1 (rclw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rclw r16 _1: Rotate 17 bits (CF, r/m16) left once.
(instance WriteInst.Rclw.Gpr16.|1 (forall W Error) (WriteInst W Error (Rclw Gpr16 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /2
    (with1 (rclw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclw m16 _1: Rotate 17 bits (CF, r/m16) left once.
(instance WriteInst.Rclw.Memory.|1 (forall W Error) (WriteInst W Error (Rclw Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /2
    (with1 (rclw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclw r16 _Cl: Rotate 17 bits (CF, r/m16) left CL times.
(instance WriteInst.Rclw.Gpr16.|Cl (forall W Error) (WriteInst W Error (Rclw Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /2
    (with1 (rclw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rclw m16 _Cl: Rotate 17 bits (CF, r/m16) left CL times.
(instance WriteInst.Rclw.Memory.|Cl (forall W Error) (WriteInst W Error (Rclw Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /2
    (with1 (rclw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 2) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rcpps Op0 Op1) (rcpps: Op0 Op1))

; rcpps xmm xmm: Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
(instance WriteInst.Rcpps.Xmm.Xmm (forall W Error) (WriteInst W Error (Rcpps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 53 /r
    (with1 (rcpps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 83 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcpps xmm m128: Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
(instance WriteInst.Rcpps.Xmm.Memory (forall W Error) (WriteInst W Error (Rcpps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 53 /r
    (with1 (rcpps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 83 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rcpss Op0 Op1) (rcpss: Op0 Op1))

; rcpss xmm xmm: Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.
(instance WriteInst.Rcpss.Xmm.Xmm (forall W Error) (WriteInst W Error (Rcpss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 53 /r
    (with1 (rcpss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 83 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcpss xmm m32: Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.
(instance WriteInst.Rcpss.Xmm.Memory (forall W Error) (WriteInst W Error (Rcpss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 53 /r
    (with1 (rcpss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 83 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rcrb Op0 Op1) (rcrb: Op0 Op1))

; rcrb r8 imm8: Rotate 9 bits (CF, r/m8) right imm8 times.
(instance WriteInst.Rcrb.Gpr8.I8 (forall W Error) (WriteInst W Error (Rcrb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /3 ib
    (with1 (rcrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcrb m8 imm8: Rotate 9 bits (CF, r/m8) right imm8 times.
(instance WriteInst.Rcrb.Memory.I8 (forall W Error) (WriteInst W Error (Rcrb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /3 ib
    (with1 (rcrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcrb r8 _1: Rotate 9 bits (CF, r/m8) right once.
(instance WriteInst.Rcrb.Gpr8.|1 (forall W Error) (WriteInst W Error (Rcrb Gpr8 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /3
    (with1 (rcrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrb m8 _1: Rotate 9 bits (CF, r/m8) right once.
(instance WriteInst.Rcrb.Memory.|1 (forall W Error) (WriteInst W Error (Rcrb Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /3
    (with1 (rcrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrb r8 _Cl: Rotate 9 bits (CF, r/m8) right CL times.
(instance WriteInst.Rcrb.Gpr8.|Cl (forall W Error) (WriteInst W Error (Rcrb Gpr8 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /3
    (with1 (rcrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrb m8 _Cl: Rotate 9 bits (CF, r/m8) right CL times.
(instance WriteInst.Rcrb.Memory.|Cl (forall W Error) (WriteInst W Error (Rcrb Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /3
    (with1 (rcrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rcrl Op0 Op1) (rcrl: Op0 Op1))

; rcrl r32 imm8: Rotate 33 bits (CF, r/m32) right imm8 times.
(instance WriteInst.Rcrl.Gpr32.I8 (forall W Error) (WriteInst W Error (Rcrl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /3 ib
    (with1 (rcrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcrl m32 imm8: Rotate 33 bits (CF, r/m32) right imm8 times.
(instance WriteInst.Rcrl.Memory.I8 (forall W Error) (WriteInst W Error (Rcrl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /3 ib
    (with1 (rcrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcrl r32 _1: Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.
(instance WriteInst.Rcrl.Gpr32.|1 (forall W Error) (WriteInst W Error (Rcrl Gpr32 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /3
    (with1 (rcrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrl m32 _1: Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.
(instance WriteInst.Rcrl.Memory.|1 (forall W Error) (WriteInst W Error (Rcrl Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /3
    (with1 (rcrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrl r32 _Cl: Rotate 33 bits (CF, r/m32) right CL times.
(instance WriteInst.Rcrl.Gpr32.|Cl (forall W Error) (WriteInst W Error (Rcrl Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /3
    (with1 (rcrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrl m32 _Cl: Rotate 33 bits (CF, r/m32) right CL times.
(instance WriteInst.Rcrl.Memory.|Cl (forall W Error) (WriteInst W Error (Rcrl Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /3
    (with1 (rcrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rcrq Op0 Op1) (rcrq: Op0 Op1))

; rcrq r64 imm8: Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.
(instance WriteInst.Rcrq.Gpr64.I8 (forall W Error) (WriteInst W Error (Rcrq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /3 ib
    (with1 (rcrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcrq m64 imm8: Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.
(instance WriteInst.Rcrq.Memory.I8 (forall W Error) (WriteInst W Error (Rcrq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /3 ib
    (with1 (rcrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcrq r64 _1: Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.
(instance WriteInst.Rcrq.Gpr64.|1 (forall W Error) (WriteInst W Error (Rcrq Gpr64 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /3
    (with1 (rcrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrq m64 _1: Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.
(instance WriteInst.Rcrq.Memory.|1 (forall W Error) (WriteInst W Error (Rcrq Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /3
    (with1 (rcrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrq r64 _Cl: Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.
(instance WriteInst.Rcrq.Gpr64.|Cl (forall W Error) (WriteInst W Error (Rcrq Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /3
    (with1 (rcrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrq m64 _Cl: Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.
(instance WriteInst.Rcrq.Memory.|Cl (forall W Error) (WriteInst W Error (Rcrq Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /3
    (with1 (rcrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rcrw Op0 Op1) (rcrw: Op0 Op1))

; rcrw r16 imm8: Rotate 17 bits (CF, r/m16) right imm8 times.
(instance WriteInst.Rcrw.Gpr16.I8 (forall W Error) (WriteInst W Error (Rcrw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /3 ib
    (with1 (rcrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcrw m16 imm8: Rotate 17 bits (CF, r/m16) right imm8 times.
(instance WriteInst.Rcrw.Memory.I8 (forall W Error) (WriteInst W Error (Rcrw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /3 ib
    (with1 (rcrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rcrw r16 _1: Rotate 17 bits (CF, r/m16) right once.
(instance WriteInst.Rcrw.Gpr16.|1 (forall W Error) (WriteInst W Error (Rcrw Gpr16 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /3
    (with1 (rcrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrw m16 _1: Rotate 17 bits (CF, r/m16) right once.
(instance WriteInst.Rcrw.Memory.|1 (forall W Error) (WriteInst W Error (Rcrw Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /3
    (with1 (rcrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrw r16 _Cl: Rotate 17 bits (CF, r/m16) right CL times.
(instance WriteInst.Rcrw.Gpr16.|Cl (forall W Error) (WriteInst W Error (Rcrw Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /3
    (with1 (rcrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rcrw m16 _Cl: Rotate 17 bits (CF, r/m16) right CL times.
(instance WriteInst.Rcrw.Memory.|Cl (forall W Error) (WriteInst W Error (Rcrw Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /3
    (with1 (rcrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Retq retq:)

; retq: Near return to calling procedure.
(instance WriteInst.Retq (forall W Error) (WriteInst W Error Retq) (where (Write W Error))
  (function (write-inst! w inst)
    ; C3
    (with1 retq: inst
      (let ()
        (write-u8! 195 w)!
        (ok unit)))))

(value-data (Retq1 Op0) (retq1: Op0))

; retq imm16: Near return to calling procedure and pop imm16 bytes from stack.
(instance WriteInst.Retq1.I16 (forall W Error) (WriteInst W Error (Retq1 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C2 iw
    (with1 (retq1: (let op0)) inst
      (let ()
        (write-u8! 194 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op0) w)!
        (ok unit)))))

(value-data (Rolb Op0 Op1) (rolb: Op0 Op1))

; rolb r8 imm8: Rotate 8 bits r/m8 left imm8 times.
(instance WriteInst.Rolb.Gpr8.I8 (forall W Error) (WriteInst W Error (Rolb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /0 ib
    (with1 (rolb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rolb m8 imm8: Rotate 8 bits r/m8 left imm8 times.
(instance WriteInst.Rolb.Memory.I8 (forall W Error) (WriteInst W Error (Rolb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /0 ib
    (with1 (rolb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rolb r8 _1: Rotate 8 bits r/m8 left once.
(instance WriteInst.Rolb.Gpr8.|1 (forall W Error) (WriteInst W Error (Rolb Gpr8 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /0
    (with1 (rolb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolb m8 _1: Rotate 8 bits r/m8 left once.
(instance WriteInst.Rolb.Memory.|1 (forall W Error) (WriteInst W Error (Rolb Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /0
    (with1 (rolb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolb r8 _Cl: Rotate 8 bits r/m8 left CL times.
(instance WriteInst.Rolb.Gpr8.|Cl (forall W Error) (WriteInst W Error (Rolb Gpr8 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /0
    (with1 (rolb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolb m8 _Cl: Rotate 8 bits r/m8 left CL times.
(instance WriteInst.Rolb.Memory.|Cl (forall W Error) (WriteInst W Error (Rolb Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /0
    (with1 (rolb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Roll Op0 Op1) (roll: Op0 Op1))

; roll r32 imm8: Rotate 32 bits r/m32 left imm8 times.
(instance WriteInst.Roll.Gpr32.I8 (forall W Error) (WriteInst W Error (Roll Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /0 ib
    (with1 (roll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; roll m32 imm8: Rotate 32 bits r/m32 left imm8 times.
(instance WriteInst.Roll.Memory.I8 (forall W Error) (WriteInst W Error (Roll Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /0 ib
    (with1 (roll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; roll r32 _1: Rotate 32 bits r/m32 left once.
(instance WriteInst.Roll.Gpr32.|1 (forall W Error) (WriteInst W Error (Roll Gpr32 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /0
    (with1 (roll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; roll m32 _1: Rotate 32 bits r/m32 left once.
(instance WriteInst.Roll.Memory.|1 (forall W Error) (WriteInst W Error (Roll Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /0
    (with1 (roll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; roll r32 _Cl: Rotate 32 bits r/m32 left CL times.
(instance WriteInst.Roll.Gpr32.|Cl (forall W Error) (WriteInst W Error (Roll Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /0
    (with1 (roll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; roll m32 _Cl: Rotate 32 bits r/m32 left CL times.
(instance WriteInst.Roll.Memory.|Cl (forall W Error) (WriteInst W Error (Roll Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /0
    (with1 (roll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rolq Op0 Op1) (rolq: Op0 Op1))

; rolq r64 imm8: Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.
(instance WriteInst.Rolq.Gpr64.I8 (forall W Error) (WriteInst W Error (Rolq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /0 ib
    (with1 (rolq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rolq m64 imm8: Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.
(instance WriteInst.Rolq.Memory.I8 (forall W Error) (WriteInst W Error (Rolq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /0 ib
    (with1 (rolq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rolq r64 _1: Rotate 64 bits r/m64 left once. Uses a 6 bit count.
(instance WriteInst.Rolq.Gpr64.|1 (forall W Error) (WriteInst W Error (Rolq Gpr64 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /0
    (with1 (rolq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolq m64 _1: Rotate 64 bits r/m64 left once. Uses a 6 bit count.
(instance WriteInst.Rolq.Memory.|1 (forall W Error) (WriteInst W Error (Rolq Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /0
    (with1 (rolq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolq r64 _Cl: Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.
(instance WriteInst.Rolq.Gpr64.|Cl (forall W Error) (WriteInst W Error (Rolq Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /0
    (with1 (rolq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolq m64 _Cl: Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.
(instance WriteInst.Rolq.Memory.|Cl (forall W Error) (WriteInst W Error (Rolq Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /0
    (with1 (rolq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rolw Op0 Op1) (rolw: Op0 Op1))

; rolw r16 imm8: Rotate 16 bits r/m16 left imm8 times.
(instance WriteInst.Rolw.Gpr16.I8 (forall W Error) (WriteInst W Error (Rolw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /0 ib
    (with1 (rolw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rolw m16 imm8: Rotate 16 bits r/m16 left imm8 times.
(instance WriteInst.Rolw.Memory.I8 (forall W Error) (WriteInst W Error (Rolw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /0 ib
    (with1 (rolw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rolw r16 _1: Rotate 16 bits r/m16 left once.
(instance WriteInst.Rolw.Gpr16.|1 (forall W Error) (WriteInst W Error (Rolw Gpr16 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /0
    (with1 (rolw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolw m16 _1: Rotate 16 bits r/m16 left once.
(instance WriteInst.Rolw.Memory.|1 (forall W Error) (WriteInst W Error (Rolw Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /0
    (with1 (rolw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolw r16 _Cl: Rotate 16 bits r/m16 left CL times.
(instance WriteInst.Rolw.Gpr16.|Cl (forall W Error) (WriteInst W Error (Rolw Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /0
    (with1 (rolw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rolw m16 _Cl: Rotate 16 bits r/m16 left CL times.
(instance WriteInst.Rolw.Memory.|Cl (forall W Error) (WriteInst W Error (Rolw Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /0
    (with1 (rolw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rorb Op0 Op1) (rorb: Op0 Op1))

; rorb r8 imm8: Rotate 8 bits r/m16 right imm8 times.
(instance WriteInst.Rorb.Gpr8.I8 (forall W Error) (WriteInst W Error (Rorb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /1 ib
    (with1 (rorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rorb m8 imm8: Rotate 8 bits r/m16 right imm8 times.
(instance WriteInst.Rorb.Memory.I8 (forall W Error) (WriteInst W Error (Rorb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /1 ib
    (with1 (rorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rorb r8 _1: Rotate 8 bits r/m8 right once.
(instance WriteInst.Rorb.Gpr8.|1 (forall W Error) (WriteInst W Error (Rorb Gpr8 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /1
    (with1 (rorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorb m8 _1: Rotate 8 bits r/m8 right once.
(instance WriteInst.Rorb.Memory.|1 (forall W Error) (WriteInst W Error (Rorb Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /1
    (with1 (rorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorb r8 _Cl: Rotate 8 bits r/m8 right CL times.
(instance WriteInst.Rorb.Gpr8.|Cl (forall W Error) (WriteInst W Error (Rorb Gpr8 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /1
    (with1 (rorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorb m8 _Cl: Rotate 8 bits r/m8 right CL times.
(instance WriteInst.Rorb.Memory.|Cl (forall W Error) (WriteInst W Error (Rorb Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /1
    (with1 (rorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rorl Op0 Op1) (rorl: Op0 Op1))

; rorl r32 imm8: Rotate 32 bits r/m32 right imm8 times.
(instance WriteInst.Rorl.Gpr32.I8 (forall W Error) (WriteInst W Error (Rorl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /1 ib
    (with1 (rorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rorl m32 imm8: Rotate 32 bits r/m32 right imm8 times.
(instance WriteInst.Rorl.Memory.I8 (forall W Error) (WriteInst W Error (Rorl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /1 ib
    (with1 (rorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rorl r32 _1: Rotate 32 bits r/m32 right once.
(instance WriteInst.Rorl.Gpr32.|1 (forall W Error) (WriteInst W Error (Rorl Gpr32 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /1
    (with1 (rorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorl m32 _1: Rotate 32 bits r/m32 right once.
(instance WriteInst.Rorl.Memory.|1 (forall W Error) (WriteInst W Error (Rorl Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /1
    (with1 (rorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorl r32 _Cl: Rotate 32 bits r/m32 right CL times.
(instance WriteInst.Rorl.Gpr32.|Cl (forall W Error) (WriteInst W Error (Rorl Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /1
    (with1 (rorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorl m32 _Cl: Rotate 32 bits r/m32 right CL times.
(instance WriteInst.Rorl.Memory.|Cl (forall W Error) (WriteInst W Error (Rorl Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /1
    (with1 (rorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rorq Op0 Op1) (rorq: Op0 Op1))

; rorq r64 imm8: Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.
(instance WriteInst.Rorq.Gpr64.I8 (forall W Error) (WriteInst W Error (Rorq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /1 ib
    (with1 (rorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rorq m64 imm8: Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.
(instance WriteInst.Rorq.Memory.I8 (forall W Error) (WriteInst W Error (Rorq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /1 ib
    (with1 (rorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rorq r64 _1: Rotate 64 bits r/m64 right once. Uses a 6 bit count.
(instance WriteInst.Rorq.Gpr64.|1 (forall W Error) (WriteInst W Error (Rorq Gpr64 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /1
    (with1 (rorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorq m64 _1: Rotate 64 bits r/m64 right once. Uses a 6 bit count.
(instance WriteInst.Rorq.Memory.|1 (forall W Error) (WriteInst W Error (Rorq Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /1
    (with1 (rorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorq r64 _Cl: Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.
(instance WriteInst.Rorq.Gpr64.|Cl (forall W Error) (WriteInst W Error (Rorq Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /1
    (with1 (rorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorq m64 _Cl: Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.
(instance WriteInst.Rorq.Memory.|Cl (forall W Error) (WriteInst W Error (Rorq Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /1
    (with1 (rorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rorw Op0 Op1) (rorw: Op0 Op1))

; rorw r16 imm8: Rotate 16 bits r/m16 right imm8 times.
(instance WriteInst.Rorw.Gpr16.I8 (forall W Error) (WriteInst W Error (Rorw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /1 ib
    (with1 (rorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rorw m16 imm8: Rotate 16 bits r/m16 right imm8 times.
(instance WriteInst.Rorw.Memory.I8 (forall W Error) (WriteInst W Error (Rorw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /1 ib
    (with1 (rorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; rorw r16 _1: Rotate 16 bits r/m16 right once.
(instance WriteInst.Rorw.Gpr16.|1 (forall W Error) (WriteInst W Error (Rorw Gpr16 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /1
    (with1 (rorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorw m16 _1: Rotate 16 bits r/m16 right once.
(instance WriteInst.Rorw.Memory.|1 (forall W Error) (WriteInst W Error (Rorw Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /1
    (with1 (rorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorw r16 _Cl: Rotate 16 bits r/m16 right CL times.
(instance WriteInst.Rorw.Gpr16.|Cl (forall W Error) (WriteInst W Error (Rorw Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /1
    (with1 (rorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rorw m16 _Cl: Rotate 16 bits r/m16 right CL times.
(instance WriteInst.Rorw.Memory.|Cl (forall W Error) (WriteInst W Error (Rorw Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /1
    (with1 (rorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Roundpd Op0 Op1 Op2) (roundpd: Op0 Op1 Op2))

; roundpd xmm xmm imm8: Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
(instance WriteInst.Roundpd.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Roundpd Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 09 /r ib
    (with1 (roundpd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 9 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; roundpd xmm m128 imm8: Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
(instance WriteInst.Roundpd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Roundpd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 09 /r ib
    (with1 (roundpd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 9 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Roundps Op0 Op1 Op2) (roundps: Op0 Op1 Op2))

; roundps xmm xmm imm8: Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
(instance WriteInst.Roundps.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Roundps Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 08 /r ib
    (with1 (roundps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 8 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; roundps xmm m128 imm8: Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.
(instance WriteInst.Roundps.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Roundps Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 08 /r ib
    (with1 (roundps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 8 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Roundsd Op0 Op1 Op2) (roundsd: Op0 Op1 Op2))

; roundsd xmm xmm imm8: Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.
(instance WriteInst.Roundsd.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Roundsd Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0B /r ib
    (with1 (roundsd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 11 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; roundsd xmm m64 imm8: Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.
(instance WriteInst.Roundsd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Roundsd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0B /r ib
    (with1 (roundsd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 11 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Roundss Op0 Op1 Op2) (roundss: Op0 Op1 Op2))

; roundss xmm xmm imm8: Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.
(instance WriteInst.Roundss.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Roundss Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0A /r ib
    (with1 (roundss: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 10 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; roundss xmm m32 imm8: Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.
(instance WriteInst.Roundss.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Roundss Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 3A 0A /r ib
    (with1 (roundss: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 58 w)!
        (write-u8! 10 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Rsqrtps Op0 Op1) (rsqrtps: Op0 Op1))

; rsqrtps xmm xmm: Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
(instance WriteInst.Rsqrtps.Xmm.Xmm (forall W Error) (WriteInst W Error (Rsqrtps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 52 /r
    (with1 (rsqrtps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 82 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rsqrtps xmm m128: Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.
(instance WriteInst.Rsqrtps.Xmm.Memory (forall W Error) (WriteInst W Error (Rsqrtps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 52 /r
    (with1 (rsqrtps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 82 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Rsqrtss Op0 Op1) (rsqrtss: Op0 Op1))

; rsqrtss xmm xmm: Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.
(instance WriteInst.Rsqrtss.Xmm.Xmm (forall W Error) (WriteInst W Error (Rsqrtss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 52 /r
    (with1 (rsqrtss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 82 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; rsqrtss xmm m32: Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.
(instance WriteInst.Rsqrtss.Xmm.Memory (forall W Error) (WriteInst W Error (Rsqrtss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 52 /r
    (with1 (rsqrtss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 82 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Salb Op0 Op1) (salb: Op0 Op1))

; salb r8 imm8: Multiply r/m8 by 2, imm8 times.
(instance WriteInst.Salb.Gpr8.I8 (forall W Error) (WriteInst W Error (Salb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /4 ib
    (with1 (salb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; salb m8 imm8: Multiply r/m8 by 2, imm8 times.
(instance WriteInst.Salb.Memory.I8 (forall W Error) (WriteInst W Error (Salb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /4 ib
    (with1 (salb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; salb r8 _1: Multiply r/m8 by 2, once.
(instance WriteInst.Salb.Gpr8.|1 (forall W Error) (WriteInst W Error (Salb Gpr8 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /4
    (with1 (salb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salb m8 _1: Multiply r/m8 by 2, once.
(instance WriteInst.Salb.Memory.|1 (forall W Error) (WriteInst W Error (Salb Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /4
    (with1 (salb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salb r8 _Cl: Multiply r/m8 by 2, CL times.
(instance WriteInst.Salb.Gpr8.|Cl (forall W Error) (WriteInst W Error (Salb Gpr8 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /4
    (with1 (salb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salb m8 _Cl: Multiply r/m8 by 2, CL times.
(instance WriteInst.Salb.Memory.|Cl (forall W Error) (WriteInst W Error (Salb Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /4
    (with1 (salb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sall Op0 Op1) (sall: Op0 Op1))

; sall r32 imm8: Multiply r/m32 by 2, imm8 times.
(instance WriteInst.Sall.Gpr32.I8 (forall W Error) (WriteInst W Error (Sall Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /4 ib
    (with1 (sall: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sall m32 imm8: Multiply r/m32 by 2, imm8 times.
(instance WriteInst.Sall.Memory.I8 (forall W Error) (WriteInst W Error (Sall Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /4 ib
    (with1 (sall: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sall r32 _1: Multiply r/m32 by 2, once.
(instance WriteInst.Sall.Gpr32.|1 (forall W Error) (WriteInst W Error (Sall Gpr32 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /4
    (with1 (sall: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sall m32 _1: Multiply r/m32 by 2, once.
(instance WriteInst.Sall.Memory.|1 (forall W Error) (WriteInst W Error (Sall Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /4
    (with1 (sall: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sall r32 _Cl: Multiply r/m32 by 2, CL times.
(instance WriteInst.Sall.Gpr32.|Cl (forall W Error) (WriteInst W Error (Sall Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /4
    (with1 (sall: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sall m32 _Cl: Multiply r/m32 by 2, CL times.
(instance WriteInst.Sall.Memory.|Cl (forall W Error) (WriteInst W Error (Sall Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /4
    (with1 (sall: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Salq Op0 Op1) (salq: Op0 Op1))

; salq r64 imm8: Multiply r/m64 by 2, imm8 times.
(instance WriteInst.Salq.Gpr64.I8 (forall W Error) (WriteInst W Error (Salq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /4 ib
    (with1 (salq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; salq m64 imm8: Multiply r/m64 by 2, imm8 times.
(instance WriteInst.Salq.Memory.I8 (forall W Error) (WriteInst W Error (Salq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /4 ib
    (with1 (salq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; salq r64 _1: Multiply r/m64 by 2, once.
(instance WriteInst.Salq.Gpr64.|1 (forall W Error) (WriteInst W Error (Salq Gpr64 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /4
    (with1 (salq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salq m64 _1: Multiply r/m64 by 2, once.
(instance WriteInst.Salq.Memory.|1 (forall W Error) (WriteInst W Error (Salq Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /4
    (with1 (salq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salq r64 _Cl: Multiply r/m64 by 2, CL times.
(instance WriteInst.Salq.Gpr64.|Cl (forall W Error) (WriteInst W Error (Salq Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /4
    (with1 (salq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salq m64 _Cl: Multiply r/m64 by 2, CL times.
(instance WriteInst.Salq.Memory.|Cl (forall W Error) (WriteInst W Error (Salq Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /4
    (with1 (salq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Salw Op0 Op1) (salw: Op0 Op1))

; salw r16 imm8: Multiply r/m16 by 2, imm8 times.
(instance WriteInst.Salw.Gpr16.I8 (forall W Error) (WriteInst W Error (Salw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /4 ib
    (with1 (salw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; salw m16 imm8: Multiply r/m16 by 2, imm8 times.
(instance WriteInst.Salw.Memory.I8 (forall W Error) (WriteInst W Error (Salw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /4 ib
    (with1 (salw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; salw r16 _1: Multiply r/m16 by 2, once.
(instance WriteInst.Salw.Gpr16.|1 (forall W Error) (WriteInst W Error (Salw Gpr16 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /4
    (with1 (salw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salw m16 _1: Multiply r/m16 by 2, once.
(instance WriteInst.Salw.Memory.|1 (forall W Error) (WriteInst W Error (Salw Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /4
    (with1 (salw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salw r16 _Cl: Multiply r/m16 by 2, CL times.
(instance WriteInst.Salw.Gpr16.|Cl (forall W Error) (WriteInst W Error (Salw Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /4
    (with1 (salw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; salw m16 _Cl: Multiply r/m16 by 2, CL times.
(instance WriteInst.Salw.Memory.|Cl (forall W Error) (WriteInst W Error (Salw Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /4
    (with1 (salw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sarb Op0 Op1) (sarb: Op0 Op1))

; sarb r8 imm8: Signed divide r/m8 by 2, imm8 time.
(instance WriteInst.Sarb.Gpr8.I8 (forall W Error) (WriteInst W Error (Sarb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /7 ib
    (with1 (sarb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sarb m8 imm8: Signed divide r/m8 by 2, imm8 time.
(instance WriteInst.Sarb.Memory.I8 (forall W Error) (WriteInst W Error (Sarb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /7 ib
    (with1 (sarb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sarb r8 _1: Signed divide r/m8 by 2, once.
(instance WriteInst.Sarb.Gpr8.|1 (forall W Error) (WriteInst W Error (Sarb Gpr8 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /7
    (with1 (sarb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarb m8 _1: Signed divide r/m8 by 2, once.
(instance WriteInst.Sarb.Memory.|1 (forall W Error) (WriteInst W Error (Sarb Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /7
    (with1 (sarb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarb r8 _Cl: Signed divide r/m8 by 2, CL times.
(instance WriteInst.Sarb.Gpr8.|Cl (forall W Error) (WriteInst W Error (Sarb Gpr8 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /7
    (with1 (sarb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarb m8 _Cl: Signed divide r/m8 by 2, CL times.
(instance WriteInst.Sarb.Memory.|Cl (forall W Error) (WriteInst W Error (Sarb Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /7
    (with1 (sarb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sarl Op0 Op1) (sarl: Op0 Op1))

; sarl r32 imm8: Signed divide r/m32 by 2, imm8 times.
(instance WriteInst.Sarl.Gpr32.I8 (forall W Error) (WriteInst W Error (Sarl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /7 ib
    (with1 (sarl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sarl m32 imm8: Signed divide r/m32 by 2, imm8 times.
(instance WriteInst.Sarl.Memory.I8 (forall W Error) (WriteInst W Error (Sarl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /7 ib
    (with1 (sarl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sarl r32 _1: Signed divide r/m32 by 2, once.
(instance WriteInst.Sarl.Gpr32.|1 (forall W Error) (WriteInst W Error (Sarl Gpr32 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /7
    (with1 (sarl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarl m32 _1: Signed divide r/m32 by 2, once.
(instance WriteInst.Sarl.Memory.|1 (forall W Error) (WriteInst W Error (Sarl Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /7
    (with1 (sarl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarl r32 _Cl: Signed divide r/m32 by 2, CL times.
(instance WriteInst.Sarl.Gpr32.|Cl (forall W Error) (WriteInst W Error (Sarl Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /7
    (with1 (sarl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarl m32 _Cl: Signed divide r/m32 by 2, CL times.
(instance WriteInst.Sarl.Memory.|Cl (forall W Error) (WriteInst W Error (Sarl Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /7
    (with1 (sarl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sarq Op0 Op1) (sarq: Op0 Op1))

; sarq r64 imm8: Signed divide r/m32 by 2, imm8 times.
(instance WriteInst.Sarq.Gpr64.I8 (forall W Error) (WriteInst W Error (Sarq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /7 ib
    (with1 (sarq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sarq m64 imm8: Signed divide r/m32 by 2, imm8 times.
(instance WriteInst.Sarq.Memory.I8 (forall W Error) (WriteInst W Error (Sarq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /7 ib
    (with1 (sarq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sarq r64 _1: Signed divide r/m32 by 2, once.
(instance WriteInst.Sarq.Gpr64.|1 (forall W Error) (WriteInst W Error (Sarq Gpr64 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /7
    (with1 (sarq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarq m64 _1: Signed divide r/m32 by 2, once.
(instance WriteInst.Sarq.Memory.|1 (forall W Error) (WriteInst W Error (Sarq Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /7
    (with1 (sarq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarq r64 _Cl: Signed divide r/m32 by 2, CL times.
(instance WriteInst.Sarq.Gpr64.|Cl (forall W Error) (WriteInst W Error (Sarq Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /7
    (with1 (sarq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarq m64 _Cl: Signed divide r/m32 by 2, CL times.
(instance WriteInst.Sarq.Memory.|Cl (forall W Error) (WriteInst W Error (Sarq Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /7
    (with1 (sarq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sarw Op0 Op1) (sarw: Op0 Op1))

; sarw r16 imm8: Signed divide r/m16 by 2, imm8 times.
(instance WriteInst.Sarw.Gpr16.I8 (forall W Error) (WriteInst W Error (Sarw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /7 ib
    (with1 (sarw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sarw m16 imm8: Signed divide r/m16 by 2, imm8 times.
(instance WriteInst.Sarw.Memory.I8 (forall W Error) (WriteInst W Error (Sarw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /7 ib
    (with1 (sarw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sarw r16 _1: Signed divide r/m16 by 2, once.
(instance WriteInst.Sarw.Gpr16.|1 (forall W Error) (WriteInst W Error (Sarw Gpr16 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /7
    (with1 (sarw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarw m16 _1: Signed divide r/m16 by 2, once.
(instance WriteInst.Sarw.Memory.|1 (forall W Error) (WriteInst W Error (Sarw Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /7
    (with1 (sarw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarw r16 _Cl: Signed divide r/m16 by 2, CL times.
(instance WriteInst.Sarw.Gpr16.|Cl (forall W Error) (WriteInst W Error (Sarw Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /7
    (with1 (sarw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sarw m16 _Cl: Signed divide r/m16 by 2, CL times.
(instance WriteInst.Sarw.Memory.|Cl (forall W Error) (WriteInst W Error (Sarw Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /7
    (with1 (sarw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 7) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sbbb Op0 Op1) (sbbb: Op0 Op1))

; sbbb r8 r8: Subtract with borrow r/m8 from r8.
(instance WriteInst.Sbbb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Sbbb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 1A /r
    (with1 (sbbb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 26 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbb r8 m8: Subtract with borrow r/m8 from r8.
(instance WriteInst.Sbbb.Gpr8.Memory (forall W Error) (WriteInst W Error (Sbbb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 1A /r
    (with1 (sbbb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 26 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbb m8 r8: Subtract with borrow r8 from r/m8.
(instance WriteInst.Sbbb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Sbbb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 18 /r
    (with1 (sbbb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 24 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbb r8 imm8: Subtract with borrow imm8 from r/m8.
(instance WriteInst.Sbbb.Gpr8.I8 (forall W Error) (WriteInst W Error (Sbbb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /3 ib
    (with1 (sbbb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbb m8 imm8: Subtract with borrow imm8 from r/m8.
(instance WriteInst.Sbbb.Memory.I8 (forall W Error) (WriteInst W Error (Sbbb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /3 ib
    (with1 (sbbb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbb _Al imm8: Subtract with borrow imm8 from AL.
(instance WriteInst.Sbbb.|Al.I8 (forall W Error) (WriteInst W Error (Sbbb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 1C ib
    (with1 (sbbb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 28 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Sbbl Op0 Op1) (sbbl: Op0 Op1))

; sbbl r32 r32: Subtract with borrow r/m32 from r32.
(instance WriteInst.Sbbl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Sbbl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 1B /r
    (with1 (sbbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 27 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbl r32 m32: Subtract with borrow r/m32 from r32.
(instance WriteInst.Sbbl.Gpr32.Memory (forall W Error) (WriteInst W Error (Sbbl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 1B /r
    (with1 (sbbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 27 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbl m32 r32: Subtract with borrow r32 from r/m32.
(instance WriteInst.Sbbl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Sbbl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 19 /r
    (with1 (sbbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 25 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbl r32 imm8: Subtract with borrow sign-extended imm8 from r/m32.
(instance WriteInst.Sbbl.Gpr32.I8 (forall W Error) (WriteInst W Error (Sbbl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /3 ib
    (with1 (sbbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbl m32 imm8: Subtract with borrow sign-extended imm8 from r/m32.
(instance WriteInst.Sbbl.Memory.I8 (forall W Error) (WriteInst W Error (Sbbl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /3 ib
    (with1 (sbbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbl r32 imm32: Subtract with borrow imm32 from r/m32.
(instance WriteInst.Sbbl.Gpr32.I32 (forall W Error) (WriteInst W Error (Sbbl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /3 id
    (with1 (sbbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbl m32 imm32: Subtract with borrow imm32 from r/m32.
(instance WriteInst.Sbbl.Memory.I32 (forall W Error) (WriteInst W Error (Sbbl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /3 id
    (with1 (sbbl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbl _Eax imm32: Subtract with borrow imm32 from EAX.
(instance WriteInst.Sbbl.|Eax.I32 (forall W Error) (WriteInst W Error (Sbbl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 1D id
    (with1 (sbbl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 29 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Sbbq Op0 Op1) (sbbq: Op0 Op1))

; sbbq r64 r64: Subtract with borrow r/m64 from r64.
(instance WriteInst.Sbbq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Sbbq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 1B /r
    (with1 (sbbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 27 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbq r64 m64: Subtract with borrow r/m64 from r64.
(instance WriteInst.Sbbq.Gpr64.Memory (forall W Error) (WriteInst W Error (Sbbq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 1B /r
    (with1 (sbbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 27 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbq m64 r64: Subtract with borrow r64 from r/m64.
(instance WriteInst.Sbbq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Sbbq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 19 /r
    (with1 (sbbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 25 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbq r64 imm8: Subtract with borrow sign-extended imm8 from r/m64.
(instance WriteInst.Sbbq.Gpr64.I8 (forall W Error) (WriteInst W Error (Sbbq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /3 ib
    (with1 (sbbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbq m64 imm8: Subtract with borrow sign-extended imm8 from r/m64.
(instance WriteInst.Sbbq.Memory.I8 (forall W Error) (WriteInst W Error (Sbbq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /3 ib
    (with1 (sbbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbq r64 imm32: Subtract with borrow sign-extended imm32 to 64-bits from r/m64.
(instance WriteInst.Sbbq.Gpr64.I32 (forall W Error) (WriteInst W Error (Sbbq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /3 id
    (with1 (sbbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbq m64 imm32: Subtract with borrow sign-extended imm32 to 64-bits from r/m64.
(instance WriteInst.Sbbq.Memory.I32 (forall W Error) (WriteInst W Error (Sbbq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /3 id
    (with1 (sbbq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbq _Rax imm32: Subtract with borrow sign-extended imm.32 to 64-bits from RAX.
(instance WriteInst.Sbbq.|Rax.I32 (forall W Error) (WriteInst W Error (Sbbq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 1D id
    (with1 (sbbq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 29 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Sbbw Op0 Op1) (sbbw: Op0 Op1))

; sbbw r16 r16: Subtract with borrow r/m16 from r16.
(instance WriteInst.Sbbw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Sbbw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 1B /r
    (with1 (sbbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 27 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbw r16 m16: Subtract with borrow r/m16 from r16.
(instance WriteInst.Sbbw.Gpr16.Memory (forall W Error) (WriteInst W Error (Sbbw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 1B /r
    (with1 (sbbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 27 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbw m16 r16: Subtract with borrow r16 from r/m16.
(instance WriteInst.Sbbw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Sbbw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 19 /r
    (with1 (sbbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 25 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sbbw r16 imm8: Subtract with borrow sign-extended imm8 from r/m16.
(instance WriteInst.Sbbw.Gpr16.I8 (forall W Error) (WriteInst W Error (Sbbw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /3 ib
    (with1 (sbbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbw m16 imm8: Subtract with borrow sign-extended imm8 from r/m16.
(instance WriteInst.Sbbw.Memory.I8 (forall W Error) (WriteInst W Error (Sbbw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /3 ib
    (with1 (sbbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbw r16 imm16: Subtract with borrow imm16 from r/m16.
(instance WriteInst.Sbbw.Gpr16.I16 (forall W Error) (WriteInst W Error (Sbbw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /3 iw
    (with1 (sbbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbw m16 imm16: Subtract with borrow imm16 from r/m16.
(instance WriteInst.Sbbw.Memory.I16 (forall W Error) (WriteInst W Error (Sbbw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /3 iw
    (with1 (sbbw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; sbbw _Ax imm16: Subtract with borrow imm16 from AX.
(instance WriteInst.Sbbw.|Ax.I16 (forall W Error) (WriteInst W Error (Sbbw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 1D iw
    (with1 (sbbw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 29 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Seta Op0) (seta: Op0))

; seta r8: Set byte if above (CF=0 and ZF=0).
(instance WriteInst.Seta.Gpr8 (forall W Error) (WriteInst W Error (Seta Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 97 /0
    (with1 (seta: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 151 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; seta m8: Set byte if above (CF=0 and ZF=0).
(instance WriteInst.Seta.Memory (forall W Error) (WriteInst W Error (Seta Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 97 /0
    (with1 (seta: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 151 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setae Op0) (setae: Op0))

; setae r8: Set byte if above or equal (CF=0).
(instance WriteInst.Setae.Gpr8 (forall W Error) (WriteInst W Error (Setae Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 93 /0
    (with1 (setae: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 147 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setae m8: Set byte if above or equal (CF=0).
(instance WriteInst.Setae.Memory (forall W Error) (WriteInst W Error (Setae Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 93 /0
    (with1 (setae: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 147 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setb Op0) (setb: Op0))

; setb r8: Set byte if below (CF=1).
(instance WriteInst.Setb.Gpr8 (forall W Error) (WriteInst W Error (Setb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 92 /0
    (with1 (setb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 146 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setb m8: Set byte if below (CF=1).
(instance WriteInst.Setb.Memory (forall W Error) (WriteInst W Error (Setb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 92 /0
    (with1 (setb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 146 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setbe Op0) (setbe: Op0))

; setbe r8: Set byte if below or equal (CF=1 or ZF=1).
(instance WriteInst.Setbe.Gpr8 (forall W Error) (WriteInst W Error (Setbe Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 96 /0
    (with1 (setbe: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 150 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setbe m8: Set byte if below or equal (CF=1 or ZF=1).
(instance WriteInst.Setbe.Memory (forall W Error) (WriteInst W Error (Setbe Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 96 /0
    (with1 (setbe: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 150 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setc Op0) (setc: Op0))

; setc r8: Set byte if carry (CF=1).
(instance WriteInst.Setc.Gpr8 (forall W Error) (WriteInst W Error (Setc Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 92 /0
    (with1 (setc: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 146 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setc m8: Set byte if carry (CF=1).
(instance WriteInst.Setc.Memory (forall W Error) (WriteInst W Error (Setc Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 92 /0
    (with1 (setc: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 146 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sete Op0) (sete: Op0))

; sete r8: Set byte if equal (ZF=1).
(instance WriteInst.Sete.Gpr8 (forall W Error) (WriteInst W Error (Sete Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 94 /0
    (with1 (sete: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 148 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sete m8: Set byte if equal (ZF=1).
(instance WriteInst.Sete.Memory (forall W Error) (WriteInst W Error (Sete Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 94 /0
    (with1 (sete: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 148 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setg Op0) (setg: Op0))

; setg r8: Set byte if greater (ZF=0 and SF=OF).
(instance WriteInst.Setg.Gpr8 (forall W Error) (WriteInst W Error (Setg Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9F /0
    (with1 (setg: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 159 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setg m8: Set byte if greater (ZF=0 and SF=OF).
(instance WriteInst.Setg.Memory (forall W Error) (WriteInst W Error (Setg Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9F /0
    (with1 (setg: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 159 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setge Op0) (setge: Op0))

; setge r8: Set byte if greater or equal (SF=OF).
(instance WriteInst.Setge.Gpr8 (forall W Error) (WriteInst W Error (Setge Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9D /0
    (with1 (setge: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 157 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setge m8: Set byte if greater or equal (SF=OF).
(instance WriteInst.Setge.Memory (forall W Error) (WriteInst W Error (Setge Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9D /0
    (with1 (setge: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 157 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setl Op0) (setl: Op0))

; setl r8: Set byte if less (SF!= OF).
(instance WriteInst.Setl.Gpr8 (forall W Error) (WriteInst W Error (Setl Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9C /0
    (with1 (setl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 156 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setl m8: Set byte if less (SF!= OF).
(instance WriteInst.Setl.Memory (forall W Error) (WriteInst W Error (Setl Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9C /0
    (with1 (setl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 156 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setle Op0) (setle: Op0))

; setle r8: Set byte if less or equal (ZF=1 or SF!= OF).
(instance WriteInst.Setle.Gpr8 (forall W Error) (WriteInst W Error (Setle Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9E /0
    (with1 (setle: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 158 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setle m8: Set byte if less or equal (ZF=1 or SF!= OF).
(instance WriteInst.Setle.Memory (forall W Error) (WriteInst W Error (Setle Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9E /0
    (with1 (setle: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 158 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setna Op0) (setna: Op0))

; setna r8: Set byte if not above (CF=1 or ZF=1).
(instance WriteInst.Setna.Gpr8 (forall W Error) (WriteInst W Error (Setna Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 96 /0
    (with1 (setna: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 150 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setna m8: Set byte if not above (CF=1 or ZF=1).
(instance WriteInst.Setna.Memory (forall W Error) (WriteInst W Error (Setna Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 96 /0
    (with1 (setna: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 150 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnae Op0) (setnae: Op0))

; setnae r8: Set byte if not above or equal (CF=1).
(instance WriteInst.Setnae.Gpr8 (forall W Error) (WriteInst W Error (Setnae Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 92 /0
    (with1 (setnae: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 146 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnae m8: Set byte if not above or equal (CF=1).
(instance WriteInst.Setnae.Memory (forall W Error) (WriteInst W Error (Setnae Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 92 /0
    (with1 (setnae: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 146 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnb Op0) (setnb: Op0))

; setnb r8: Set byte if not below (CF=0).
(instance WriteInst.Setnb.Gpr8 (forall W Error) (WriteInst W Error (Setnb Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 93 /0
    (with1 (setnb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 147 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnb m8: Set byte if not below (CF=0).
(instance WriteInst.Setnb.Memory (forall W Error) (WriteInst W Error (Setnb Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 93 /0
    (with1 (setnb: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 147 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnbe Op0) (setnbe: Op0))

; setnbe r8: Set byte if not below or equal (CF=0 and ZF=0).
(instance WriteInst.Setnbe.Gpr8 (forall W Error) (WriteInst W Error (Setnbe Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 97 /0
    (with1 (setnbe: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 151 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnbe m8: Set byte if not below or equal (CF=0 and ZF=0).
(instance WriteInst.Setnbe.Memory (forall W Error) (WriteInst W Error (Setnbe Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 97 /0
    (with1 (setnbe: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 151 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnc Op0) (setnc: Op0))

; setnc r8: Set byte if not carry (CF=0).
(instance WriteInst.Setnc.Gpr8 (forall W Error) (WriteInst W Error (Setnc Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 93 /0
    (with1 (setnc: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 147 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnc m8: Set byte if not carry (CF=0).
(instance WriteInst.Setnc.Memory (forall W Error) (WriteInst W Error (Setnc Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 93 /0
    (with1 (setnc: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 147 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setne Op0) (setne: Op0))

; setne r8: Set byte if not equal (ZF=0).
(instance WriteInst.Setne.Gpr8 (forall W Error) (WriteInst W Error (Setne Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 95 /0
    (with1 (setne: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 149 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setne m8: Set byte if not equal (ZF=0).
(instance WriteInst.Setne.Memory (forall W Error) (WriteInst W Error (Setne Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 95 /0
    (with1 (setne: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 149 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setng Op0) (setng: Op0))

; setng r8: Set byte if not greater (ZF=1 or SF!= OF)
(instance WriteInst.Setng.Gpr8 (forall W Error) (WriteInst W Error (Setng Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9E /0
    (with1 (setng: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 158 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setng m8: Set byte if not greater (ZF=1 or SF!= OF)
(instance WriteInst.Setng.Memory (forall W Error) (WriteInst W Error (Setng Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9E /0
    (with1 (setng: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 158 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnge Op0) (setnge: Op0))

; setnge r8: Set byte if not greater or equal (SF!= OF).
(instance WriteInst.Setnge.Gpr8 (forall W Error) (WriteInst W Error (Setnge Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9C /0
    (with1 (setnge: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 156 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnge m8: Set byte if not greater or equal (SF!= OF).
(instance WriteInst.Setnge.Memory (forall W Error) (WriteInst W Error (Setnge Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9C /0
    (with1 (setnge: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 156 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnl Op0) (setnl: Op0))

; setnl r8: Set byte if not less (SF=OF).
(instance WriteInst.Setnl.Gpr8 (forall W Error) (WriteInst W Error (Setnl Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9D /0
    (with1 (setnl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 157 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnl m8: Set byte if not less (SF=OF).
(instance WriteInst.Setnl.Memory (forall W Error) (WriteInst W Error (Setnl Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9D /0
    (with1 (setnl: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 157 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnle Op0) (setnle: Op0))

; setnle r8: Set byte if not less or equal (ZF=0 and SF=OF).
(instance WriteInst.Setnle.Gpr8 (forall W Error) (WriteInst W Error (Setnle Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9F /0
    (with1 (setnle: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 159 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnle m8: Set byte if not less or equal (ZF=0 and SF=OF).
(instance WriteInst.Setnle.Memory (forall W Error) (WriteInst W Error (Setnle Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9F /0
    (with1 (setnle: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 159 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setno Op0) (setno: Op0))

; setno r8: Set byte if not overflow (OF=0).
(instance WriteInst.Setno.Gpr8 (forall W Error) (WriteInst W Error (Setno Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 91 /0
    (with1 (setno: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 145 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setno m8: Set byte if not overflow (OF=0).
(instance WriteInst.Setno.Memory (forall W Error) (WriteInst W Error (Setno Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 91 /0
    (with1 (setno: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 145 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnp Op0) (setnp: Op0))

; setnp r8: Set byte if not parity (PF=0).
(instance WriteInst.Setnp.Gpr8 (forall W Error) (WriteInst W Error (Setnp Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9B /0
    (with1 (setnp: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 155 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnp m8: Set byte if not parity (PF=0).
(instance WriteInst.Setnp.Memory (forall W Error) (WriteInst W Error (Setnp Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9B /0
    (with1 (setnp: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 155 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setns Op0) (setns: Op0))

; setns r8: Set byte if not sign (SF=0).
(instance WriteInst.Setns.Gpr8 (forall W Error) (WriteInst W Error (Setns Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 99 /0
    (with1 (setns: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 153 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setns m8: Set byte if not sign (SF=0).
(instance WriteInst.Setns.Memory (forall W Error) (WriteInst W Error (Setns Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 99 /0
    (with1 (setns: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 153 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setnz Op0) (setnz: Op0))

; setnz r8: Set byte if not zero (ZF=0).
(instance WriteInst.Setnz.Gpr8 (forall W Error) (WriteInst W Error (Setnz Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 95 /0
    (with1 (setnz: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 149 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setnz m8: Set byte if not zero (ZF=0).
(instance WriteInst.Setnz.Memory (forall W Error) (WriteInst W Error (Setnz Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 95 /0
    (with1 (setnz: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 149 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Seto Op0) (seto: Op0))

; seto r8: Set byte if overflow (OF=1)
(instance WriteInst.Seto.Gpr8 (forall W Error) (WriteInst W Error (Seto Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 90 /0
    (with1 (seto: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 144 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; seto m8: Set byte if overflow (OF=1)
(instance WriteInst.Seto.Memory (forall W Error) (WriteInst W Error (Seto Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 90 /0
    (with1 (seto: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 144 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setp Op0) (setp: Op0))

; setp r8: Set byte if parity (PF=1).
(instance WriteInst.Setp.Gpr8 (forall W Error) (WriteInst W Error (Setp Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9A /0
    (with1 (setp: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 154 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setp m8: Set byte if parity (PF=1).
(instance WriteInst.Setp.Memory (forall W Error) (WriteInst W Error (Setp Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9A /0
    (with1 (setp: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 154 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setpe Op0) (setpe: Op0))

; setpe r8: Set byte if parity even (PF=1).
(instance WriteInst.Setpe.Gpr8 (forall W Error) (WriteInst W Error (Setpe Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9A /0
    (with1 (setpe: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 154 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setpe m8: Set byte if parity even (PF=1).
(instance WriteInst.Setpe.Memory (forall W Error) (WriteInst W Error (Setpe Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9A /0
    (with1 (setpe: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 154 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setpo Op0) (setpo: Op0))

; setpo r8: Set byte if parity odd (PF=0).
(instance WriteInst.Setpo.Gpr8 (forall W Error) (WriteInst W Error (Setpo Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9B /0
    (with1 (setpo: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 155 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setpo m8: Set byte if parity odd (PF=0).
(instance WriteInst.Setpo.Memory (forall W Error) (WriteInst W Error (Setpo Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 9B /0
    (with1 (setpo: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 155 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sets Op0) (sets: Op0))

; sets r8: Set byte if sign (SF=1).
(instance WriteInst.Sets.Gpr8 (forall W Error) (WriteInst W Error (Sets Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 98 /0
    (with1 (sets: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 152 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sets m8: Set byte if sign (SF=1).
(instance WriteInst.Sets.Memory (forall W Error) (WriteInst W Error (Sets Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 98 /0
    (with1 (sets: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 152 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Setz Op0) (setz: Op0))

; setz r8: Set byte if zero (ZF=1).
(instance WriteInst.Setz.Gpr8 (forall W Error) (WriteInst W Error (Setz Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 94 /0
    (with1 (setz: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 148 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; setz m8: Set byte if zero (ZF=1).
(instance WriteInst.Setz.Memory (forall W Error) (WriteInst W Error (Setz Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 94 /0
    (with1 (setz: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 148 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Sfence sfence:)

; sfence: Serializes store operations.
(instance WriteInst.Sfence (forall W Error) (WriteInst W Error Sfence) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AE F8
    (with1 sfence: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 174 w)!
        (write-u8! 248 w)!
        (ok unit)))))

(value-data (Sgdt Op0) (sgdt: Op0))

; sgdt m: Store GDTR to m.
(instance WriteInst.Sgdt.Memory (forall W Error) (WriteInst W Error (Sgdt Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 01 /0
    (with1 (sgdt: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 1 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shlb Op0 Op1) (shlb: Op0 Op1))

; shlb r8 imm8: Multiply r/m8 by 2, imm8 times.
(instance WriteInst.Shlb.Gpr8.I8 (forall W Error) (WriteInst W Error (Shlb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /4 ib
    (with1 (shlb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shlb m8 imm8: Multiply r/m8 by 2, imm8 times.
(instance WriteInst.Shlb.Memory.I8 (forall W Error) (WriteInst W Error (Shlb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /4 ib
    (with1 (shlb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shlb r8 _1: Multiply r/m8 by 2, once.
(instance WriteInst.Shlb.Gpr8.|1 (forall W Error) (WriteInst W Error (Shlb Gpr8 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /4
    (with1 (shlb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlb m8 _1: Multiply r/m8 by 2, once.
(instance WriteInst.Shlb.Memory.|1 (forall W Error) (WriteInst W Error (Shlb Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /4
    (with1 (shlb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlb r8 _Cl: Multiply r/m8 by 2, CL times.
(instance WriteInst.Shlb.Gpr8.|Cl (forall W Error) (WriteInst W Error (Shlb Gpr8 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /4
    (with1 (shlb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlb m8 _Cl: Multiply r/m8 by 2, CL times.
(instance WriteInst.Shlb.Memory.|Cl (forall W Error) (WriteInst W Error (Shlb Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /4
    (with1 (shlb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shldl Op0 Op1 Op2) (shldl: Op0 Op1 Op2))

; shldl r32 r32 imm8: Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.
(instance WriteInst.Shldl.Gpr32.Gpr32.I8 (forall W Error) (WriteInst W Error (Shldl Gpr32 Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F A4 /r ib
    (with1 (shldl: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 164 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shldl m32 r32 imm8: Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.
(instance WriteInst.Shldl.Memory.Gpr32.I8 (forall W Error) (WriteInst W Error (Shldl Memory Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F A4 /r ib
    (with1 (shldl: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 164 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shldl r32 r32 _Cl: Shift r/m32 to left CL places while shifting bits from r32 in from the right.
(instance WriteInst.Shldl.Gpr32.Gpr32.|Cl (forall W Error) (WriteInst W Error (Shldl Gpr32 Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F A5 /r
    (with1 (shldl: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 165 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shldl m32 r32 _Cl: Shift r/m32 to left CL places while shifting bits from r32 in from the right.
(instance WriteInst.Shldl.Memory.Gpr32.|Cl (forall W Error) (WriteInst W Error (Shldl Memory Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F A5 /r
    (with1 (shldl: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 165 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shldq Op0 Op1 Op2) (shldq: Op0 Op1 Op2))

; shldq r64 r64 imm8: Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.
(instance WriteInst.Shldq.Gpr64.Gpr64.I8 (forall W Error) (WriteInst W Error (Shldq Gpr64 Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F A4 /r ib
    (with1 (shldq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 164 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shldq m64 r64 imm8: Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.
(instance WriteInst.Shldq.Memory.Gpr64.I8 (forall W Error) (WriteInst W Error (Shldq Memory Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F A4 /r ib
    (with1 (shldq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 164 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shldq r64 r64 _Cl: Shift r/m64 to left CL places while shifting bits from r64 in from the right.
(instance WriteInst.Shldq.Gpr64.Gpr64.|Cl (forall W Error) (WriteInst W Error (Shldq Gpr64 Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F A5 /r
    (with1 (shldq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 165 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shldq m64 r64 _Cl: Shift r/m64 to left CL places while shifting bits from r64 in from the right.
(instance WriteInst.Shldq.Memory.Gpr64.|Cl (forall W Error) (WriteInst W Error (Shldq Memory Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F A5 /r
    (with1 (shldq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 165 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shldw Op0 Op1 Op2) (shldw: Op0 Op1 Op2))

; shldw r16 r16 imm8: Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.
(instance WriteInst.Shldw.Gpr16.Gpr16.I8 (forall W Error) (WriteInst W Error (Shldw Gpr16 Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F A4 /r ib
    (with1 (shldw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 164 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shldw m16 r16 imm8: Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.
(instance WriteInst.Shldw.Memory.Gpr16.I8 (forall W Error) (WriteInst W Error (Shldw Memory Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F A4 /r ib
    (with1 (shldw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 164 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shldw r16 r16 _Cl: Shift r/m16 to left CL places while shifting bits from r16 in from the right.
(instance WriteInst.Shldw.Gpr16.Gpr16.|Cl (forall W Error) (WriteInst W Error (Shldw Gpr16 Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F A5 /r
    (with1 (shldw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 165 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shldw m16 r16 _Cl: Shift r/m16 to left CL places while shifting bits from r16 in from the right.
(instance WriteInst.Shldw.Memory.Gpr16.|Cl (forall W Error) (WriteInst W Error (Shldw Memory Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F A5 /r
    (with1 (shldw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 165 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shll Op0 Op1) (shll: Op0 Op1))

; shll r32 imm8: Multiply r/m32 by 2, imm8 times.
(instance WriteInst.Shll.Gpr32.I8 (forall W Error) (WriteInst W Error (Shll Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /4 ib
    (with1 (shll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shll m32 imm8: Multiply r/m32 by 2, imm8 times.
(instance WriteInst.Shll.Memory.I8 (forall W Error) (WriteInst W Error (Shll Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /4 ib
    (with1 (shll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shll r32 _1: Multiply r/m32 by 2, once.
(instance WriteInst.Shll.Gpr32.|1 (forall W Error) (WriteInst W Error (Shll Gpr32 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /4
    (with1 (shll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shll m32 _1: Multiply r/m32 by 2, once.
(instance WriteInst.Shll.Memory.|1 (forall W Error) (WriteInst W Error (Shll Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /4
    (with1 (shll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shll r32 _Cl: Multiply r/m32 by 2, CL times.
(instance WriteInst.Shll.Gpr32.|Cl (forall W Error) (WriteInst W Error (Shll Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /4
    (with1 (shll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shll m32 _Cl: Multiply r/m32 by 2, CL times.
(instance WriteInst.Shll.Memory.|Cl (forall W Error) (WriteInst W Error (Shll Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /4
    (with1 (shll: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shlq Op0 Op1) (shlq: Op0 Op1))

; shlq r64 imm8: Multiply r/m32 by 2, imm8 times.
(instance WriteInst.Shlq.Gpr64.I8 (forall W Error) (WriteInst W Error (Shlq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /4 ib
    (with1 (shlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shlq m64 imm8: Multiply r/m32 by 2, imm8 times.
(instance WriteInst.Shlq.Memory.I8 (forall W Error) (WriteInst W Error (Shlq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /4 ib
    (with1 (shlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shlq r64 _1: Multiply r/m64 by 2, once.
(instance WriteInst.Shlq.Gpr64.|1 (forall W Error) (WriteInst W Error (Shlq Gpr64 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /4
    (with1 (shlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlq m64 _1: Multiply r/m64 by 2, once.
(instance WriteInst.Shlq.Memory.|1 (forall W Error) (WriteInst W Error (Shlq Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /4
    (with1 (shlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlq r64 _Cl: Multiply r/m32 by 2, CL times.
(instance WriteInst.Shlq.Gpr64.|Cl (forall W Error) (WriteInst W Error (Shlq Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /4
    (with1 (shlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlq m64 _Cl: Multiply r/m32 by 2, CL times.
(instance WriteInst.Shlq.Memory.|Cl (forall W Error) (WriteInst W Error (Shlq Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /4
    (with1 (shlq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shlw Op0 Op1) (shlw: Op0 Op1))

; shlw r16 imm8: Multiply r/m16 by 2, imm8 times.
(instance WriteInst.Shlw.Gpr16.I8 (forall W Error) (WriteInst W Error (Shlw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /4 ib
    (with1 (shlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shlw m16 imm8: Multiply r/m16 by 2, imm8 times.
(instance WriteInst.Shlw.Memory.I8 (forall W Error) (WriteInst W Error (Shlw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /4 ib
    (with1 (shlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shlw r16 _1: Multiply r/m16 by 2, once.
(instance WriteInst.Shlw.Gpr16.|1 (forall W Error) (WriteInst W Error (Shlw Gpr16 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /4
    (with1 (shlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlw m16 _1: Multiply r/m16 by 2, once.
(instance WriteInst.Shlw.Memory.|1 (forall W Error) (WriteInst W Error (Shlw Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /4
    (with1 (shlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlw r16 _Cl: Multiply r/m16 by 2, CL times.
(instance WriteInst.Shlw.Gpr16.|Cl (forall W Error) (WriteInst W Error (Shlw Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /4
    (with1 (shlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shlw m16 _Cl: Multiply r/m16 by 2, CL times.
(instance WriteInst.Shlw.Memory.|Cl (forall W Error) (WriteInst W Error (Shlw Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /4
    (with1 (shlw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shrb Op0 Op1) (shrb: Op0 Op1))

; shrb r8 imm8: Unsigned divide r/m8 by 2, imm8 times.
(instance WriteInst.Shrb.Gpr8.I8 (forall W Error) (WriteInst W Error (Shrb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /5 ib
    (with1 (shrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shrb m8 imm8: Unsigned divide r/m8 by 2, imm8 times.
(instance WriteInst.Shrb.Memory.I8 (forall W Error) (WriteInst W Error (Shrb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C0 /5 ib
    (with1 (shrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shrb r8 _1: Unsigned divide r/m8 by 2, once.
(instance WriteInst.Shrb.Gpr8.|1 (forall W Error) (WriteInst W Error (Shrb Gpr8 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /5
    (with1 (shrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrb m8 _1: Unsigned divide r/m8 by 2, once.
(instance WriteInst.Shrb.Memory.|1 (forall W Error) (WriteInst W Error (Shrb Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D0 /5
    (with1 (shrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 208 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrb r8 _Cl: Unsigned divide r/m8 by 2, CL times.
(instance WriteInst.Shrb.Gpr8.|Cl (forall W Error) (WriteInst W Error (Shrb Gpr8 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /5
    (with1 (shrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrb m8 _Cl: Unsigned divide r/m8 by 2, CL times.
(instance WriteInst.Shrb.Memory.|Cl (forall W Error) (WriteInst W Error (Shrb Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D2 /5
    (with1 (shrb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 210 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shrdl Op0 Op1 Op2) (shrdl: Op0 Op1 Op2))

; shrdl r32 r32 imm8: Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.
(instance WriteInst.Shrdl.Gpr32.Gpr32.I8 (forall W Error) (WriteInst W Error (Shrdl Gpr32 Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AC /r ib
    (with1 (shrdl: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 172 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shrdl m32 r32 imm8: Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.
(instance WriteInst.Shrdl.Memory.Gpr32.I8 (forall W Error) (WriteInst W Error (Shrdl Memory Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AC /r ib
    (with1 (shrdl: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 172 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shrdl r32 r32 _Cl: Shift r/m32 to right CL places while shifting bits from r32 in from the left.
(instance WriteInst.Shrdl.Gpr32.Gpr32.|Cl (forall W Error) (WriteInst W Error (Shrdl Gpr32 Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AD /r
    (with1 (shrdl: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 173 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrdl m32 r32 _Cl: Shift r/m32 to right CL places while shifting bits from r32 in from the left.
(instance WriteInst.Shrdl.Memory.Gpr32.|Cl (forall W Error) (WriteInst W Error (Shrdl Memory Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AD /r
    (with1 (shrdl: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 173 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shrdq Op0 Op1 Op2) (shrdq: Op0 Op1 Op2))

; shrdq r64 r64 imm8: Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.
(instance WriteInst.Shrdq.Gpr64.Gpr64.I8 (forall W Error) (WriteInst W Error (Shrdq Gpr64 Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F AC /r ib
    (with1 (shrdq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 172 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shrdq m64 r64 imm8: Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.
(instance WriteInst.Shrdq.Memory.Gpr64.I8 (forall W Error) (WriteInst W Error (Shrdq Memory Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F AC /r ib
    (with1 (shrdq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 172 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shrdq r64 r64 _Cl: Shift r/m64 to right CL places while shifting bits from r64 in from the left.
(instance WriteInst.Shrdq.Gpr64.Gpr64.|Cl (forall W Error) (WriteInst W Error (Shrdq Gpr64 Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F AD /r
    (with1 (shrdq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 173 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrdq m64 r64 _Cl: Shift r/m64 to right CL places while shifting bits from r64 in from the left.
(instance WriteInst.Shrdq.Memory.Gpr64.|Cl (forall W Error) (WriteInst W Error (Shrdq Memory Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F AD /r
    (with1 (shrdq: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 173 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shrdw Op0 Op1 Op2) (shrdw: Op0 Op1 Op2))

; shrdw r16 r16 imm8: Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.
(instance WriteInst.Shrdw.Gpr16.Gpr16.I8 (forall W Error) (WriteInst W Error (Shrdw Gpr16 Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F AC /r ib
    (with1 (shrdw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 172 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shrdw m16 r16 imm8: Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.
(instance WriteInst.Shrdw.Memory.Gpr16.I8 (forall W Error) (WriteInst W Error (Shrdw Memory Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F AC /r ib
    (with1 (shrdw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 172 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shrdw r16 r16 _Cl: Shift r/m16 to right CL places while shifting bits from r16 in from the left.
(instance WriteInst.Shrdw.Gpr16.Gpr16.|Cl (forall W Error) (WriteInst W Error (Shrdw Gpr16 Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F AD /r
    (with1 (shrdw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 173 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrdw m16 r16 _Cl: Shift r/m16 to right CL places while shifting bits from r16 in from the left.
(instance WriteInst.Shrdw.Memory.Gpr16.|Cl (forall W Error) (WriteInst W Error (Shrdw Memory Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F AD /r
    (with1 (shrdw: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 173 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shrl Op0 Op1) (shrl: Op0 Op1))

; shrl r32 imm8: Unsigned divide r/m32 by 2, imm8 times.
(instance WriteInst.Shrl.Gpr32.I8 (forall W Error) (WriteInst W Error (Shrl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /5 ib
    (with1 (shrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shrl m32 imm8: Unsigned divide r/m32 by 2, imm8 times.
(instance WriteInst.Shrl.Memory.I8 (forall W Error) (WriteInst W Error (Shrl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; C1 /5 ib
    (with1 (shrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shrl r32 _1: Unsigned divide r/m32 by 2, once.
(instance WriteInst.Shrl.Gpr32.|1 (forall W Error) (WriteInst W Error (Shrl Gpr32 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /5
    (with1 (shrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrl m32 _1: Unsigned divide r/m32 by 2, once.
(instance WriteInst.Shrl.Memory.|1 (forall W Error) (WriteInst W Error (Shrl Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D1 /5
    (with1 (shrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrl r32 _Cl: Unsigned divide r/m32 by 2, CL times.
(instance WriteInst.Shrl.Gpr32.|Cl (forall W Error) (WriteInst W Error (Shrl Gpr32 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /5
    (with1 (shrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrl m32 _Cl: Unsigned divide r/m32 by 2, CL times.
(instance WriteInst.Shrl.Memory.|Cl (forall W Error) (WriteInst W Error (Shrl Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; D3 /5
    (with1 (shrl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shrq Op0 Op1) (shrq: Op0 Op1))

; shrq r64 imm8: Unsigned divide r/m32 by 2, imm8 times.
(instance WriteInst.Shrq.Gpr64.I8 (forall W Error) (WriteInst W Error (Shrq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /5 ib
    (with1 (shrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shrq m64 imm8: Unsigned divide r/m32 by 2, imm8 times.
(instance WriteInst.Shrq.Memory.I8 (forall W Error) (WriteInst W Error (Shrq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ C1 /5 ib
    (with1 (shrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shrq r64 _1: Unsigned divide r/m32 by 2, once.
(instance WriteInst.Shrq.Gpr64.|1 (forall W Error) (WriteInst W Error (Shrq Gpr64 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /5
    (with1 (shrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrq m64 _1: Unsigned divide r/m32 by 2, once.
(instance WriteInst.Shrq.Memory.|1 (forall W Error) (WriteInst W Error (Shrq Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D1 /5
    (with1 (shrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrq r64 _Cl: Unsigned divide r/m32 by 2, CL times.
(instance WriteInst.Shrq.Gpr64.|Cl (forall W Error) (WriteInst W Error (Shrq Gpr64 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /5
    (with1 (shrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrq m64 _Cl: Unsigned divide r/m32 by 2, CL times.
(instance WriteInst.Shrq.Memory.|Cl (forall W Error) (WriteInst W Error (Shrq Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ D3 /5
    (with1 (shrq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shrw Op0 Op1) (shrw: Op0 Op1))

; shrw r16 imm8: Unsigned divide r/m16 by 2, imm8 times.
(instance WriteInst.Shrw.Gpr16.I8 (forall W Error) (WriteInst W Error (Shrw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /5 ib
    (with1 (shrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shrw m16 imm8: Unsigned divide r/m16 by 2, imm8 times.
(instance WriteInst.Shrw.Memory.I8 (forall W Error) (WriteInst W Error (Shrw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 C1 /5 ib
    (with1 (shrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; shrw r16 _1: Unsigned divide r/m16 by 2, once.
(instance WriteInst.Shrw.Gpr16.|1 (forall W Error) (WriteInst W Error (Shrw Gpr16 |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /5
    (with1 (shrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrw m16 _1: Unsigned divide r/m16 by 2, once.
(instance WriteInst.Shrw.Memory.|1 (forall W Error) (WriteInst W Error (Shrw Memory |1)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D1 /5
    (with1 (shrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 209 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrw r16 _Cl: Unsigned divide r/m16 by 2, CL times
(instance WriteInst.Shrw.Gpr16.|Cl (forall W Error) (WriteInst W Error (Shrw Gpr16 |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /5
    (with1 (shrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; shrw m16 _Cl: Unsigned divide r/m16 by 2, CL times
(instance WriteInst.Shrw.Memory.|Cl (forall W Error) (WriteInst W Error (Shrw Memory |Cl)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 D3 /5
    (with1 (shrw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 211 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Shufpd Op0 Op1 Op2) (shufpd: Op0 Op1 Op2))

; shufpd xmm xmm imm8: Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.
(instance WriteInst.Shufpd.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Shufpd Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C6 /r ib
    (with1 (shufpd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 198 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shufpd xmm m128 imm8: Shuffle packed double-precision floating- point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.
(instance WriteInst.Shufpd.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Shufpd Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C6 /r ib
    (with1 (shufpd: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 198 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Shufps Op0 Op1 Op2) (shufps: Op0 Op1 Op2))

; shufps xmm xmm imm8: Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.
(instance WriteInst.Shufps.Xmm.Xmm.I8 (forall W Error) (WriteInst W Error (Shufps Xmm Xmm I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C6 /r ib
    (with1 (shufps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 198 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

; shufps xmm m128 imm8: Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.
(instance WriteInst.Shufps.Xmm.Memory.I8 (forall W Error) (WriteInst W Error (Shufps Xmm Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C6 /r ib
    (with1 (shufps: (let op0) (let op1) (let op2)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 198 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op2) w)!
        (ok unit)))))

(value-data (Sidt Op0) (sidt: Op0))

; sidt m: Store IDTR to m.
(instance WriteInst.Sidt.Memory (forall W Error) (WriteInst W Error (Sidt Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 01 /1
    (with1 (sidt: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 1 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sqrtpd Op0 Op1) (sqrtpd: Op0 Op1))

; sqrtpd xmm xmm: Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.
(instance WriteInst.Sqrtpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Sqrtpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 51 /r
    (with1 (sqrtpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 81 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sqrtpd xmm m128: Computes square roots of the packed double- precision floating-point values in xmm2/m128 and stores the results in xmm1.
(instance WriteInst.Sqrtpd.Xmm.Memory (forall W Error) (WriteInst W Error (Sqrtpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 51 /r
    (with1 (sqrtpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 81 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sqrtps Op0 Op1) (sqrtps: Op0 Op1))

; sqrtps xmm xmm: Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.
(instance WriteInst.Sqrtps.Xmm.Xmm (forall W Error) (WriteInst W Error (Sqrtps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 51 /r
    (with1 (sqrtps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 81 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sqrtps xmm m128: Computes square roots of the packed single- precision floating-point values in xmm2/m128 and stores the results in xmm1.
(instance WriteInst.Sqrtps.Xmm.Memory (forall W Error) (WriteInst W Error (Sqrtps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 51 /r
    (with1 (sqrtps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 81 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sqrtsd Op0 Op1) (sqrtsd: Op0 Op1))

; sqrtsd xmm xmm: Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.
(instance WriteInst.Sqrtsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Sqrtsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 51 /r
    (with1 (sqrtsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 81 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sqrtsd xmm m64: Computes square root of the low double- precision floating-point value in xmm2/m64 and stores the results in xmm1.
(instance WriteInst.Sqrtsd.Xmm.Memory (forall W Error) (WriteInst W Error (Sqrtsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 51 /r
    (with1 (sqrtsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 81 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Sqrtss Op0 Op1) (sqrtss: Op0 Op1))

; sqrtss xmm xmm: Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.
(instance WriteInst.Sqrtss.Xmm.Xmm (forall W Error) (WriteInst W Error (Sqrtss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 51 /r
    (with1 (sqrtss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 81 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; sqrtss xmm m32: Computes square root of the low single- precision floating-point value in xmm2/m32 and stores the results in xmm1.
(instance WriteInst.Sqrtss.Xmm.Memory (forall W Error) (WriteInst W Error (Sqrtss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 51 /r
    (with1 (sqrtss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 81 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Stc stc:)

; stc: Set CF flag.
(instance WriteInst.Stc (forall W Error) (WriteInst W Error Stc) (where (Write W Error))
  (function (write-inst! w inst)
    ; F9
    (with1 stc: inst
      (let ()
        (write-u8! 249 w)!
        (ok unit)))))

(value-data Std std:)

; std: Set DF flag.
(instance WriteInst.Std (forall W Error) (WriteInst W Error Std) (where (Write W Error))
  (function (write-inst! w inst)
    ; FD
    (with1 std: inst
      (let ()
        (write-u8! 253 w)!
        (ok unit)))))

(value-data Sti sti:)

; sti: Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction.
(instance WriteInst.Sti (forall W Error) (WriteInst W Error Sti) (where (Write W Error))
  (function (write-inst! w inst)
    ; FB
    (with1 sti: inst
      (let ()
        (write-u8! 251 w)!
        (ok unit)))))

(value-data (Stmxcsr Op0) (stmxcsr: Op0))

; stmxcsr m32: Store contents of MXCSR register to m32.
(instance WriteInst.Stmxcsr.Memory (forall W Error) (WriteInst W Error (Stmxcsr Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F AE /3
    (with1 (stmxcsr: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 3) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 174 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Str Op0) (str: Op0))

; str r16: Stores segment selector from TR in r/m16.
(instance WriteInst.Str.Gpr16 (forall W Error) (WriteInst W Error (Str Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 00 /1
    (with1 (str: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 0 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; str m16: Stores segment selector from TR in r/m16.
(instance WriteInst.Str.Memory (forall W Error) (WriteInst W Error (Str Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 00 /1
    (with1 (str: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 1) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 0 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Subb Op0 Op1) (subb: Op0 Op1))

; subb r8 r8: Subtract r/m8 from r8.
(instance WriteInst.Subb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Subb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 2A /r
    (with1 (subb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subb r8 m8: Subtract r/m8 from r8.
(instance WriteInst.Subb.Gpr8.Memory (forall W Error) (WriteInst W Error (Subb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 2A /r
    (with1 (subb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 42 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subb m8 r8: Subtract r8 from r/m8.
(instance WriteInst.Subb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Subb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 28 /r
    (with1 (subb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 40 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subb r8 imm8: Subtract imm8 from r/m8.
(instance WriteInst.Subb.Gpr8.I8 (forall W Error) (WriteInst W Error (Subb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /5 ib
    (with1 (subb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subb m8 imm8: Subtract imm8 from r/m8.
(instance WriteInst.Subb.Memory.I8 (forall W Error) (WriteInst W Error (Subb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /5 ib
    (with1 (subb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subb _Al imm8: Subtract imm8 from AL.
(instance WriteInst.Subb.|Al.I8 (forall W Error) (WriteInst W Error (Subb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 2C ib
    (with1 (subb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 44 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Subl Op0 Op1) (subl: Op0 Op1))

; subl r32 r32: Subtract r/m32 from r32.
(instance WriteInst.Subl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Subl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 2B /r
    (with1 (subl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subl r32 m32: Subtract r/m32 from r32.
(instance WriteInst.Subl.Gpr32.Memory (forall W Error) (WriteInst W Error (Subl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 2B /r
    (with1 (subl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subl m32 r32: Subtract r32 from r/m32.
(instance WriteInst.Subl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Subl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 29 /r
    (with1 (subl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 41 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subl r32 imm8: Subtract sign-extended imm8 from r/m32.
(instance WriteInst.Subl.Gpr32.I8 (forall W Error) (WriteInst W Error (Subl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /5 ib
    (with1 (subl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subl m32 imm8: Subtract sign-extended imm8 from r/m32.
(instance WriteInst.Subl.Memory.I8 (forall W Error) (WriteInst W Error (Subl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /5 ib
    (with1 (subl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subl r32 imm32: Subtract imm32 from r/m32.
(instance WriteInst.Subl.Gpr32.I32 (forall W Error) (WriteInst W Error (Subl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /5 id
    (with1 (subl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subl m32 imm32: Subtract imm32 from r/m32.
(instance WriteInst.Subl.Memory.I32 (forall W Error) (WriteInst W Error (Subl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /5 id
    (with1 (subl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subl _Eax imm32: Subtract imm32 from EAX.
(instance WriteInst.Subl.|Eax.I32 (forall W Error) (WriteInst W Error (Subl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 2D id
    (with1 (subl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 45 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Subpd Op0 Op1) (subpd: Op0 Op1))

; subpd xmm xmm: Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.
(instance WriteInst.Subpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Subpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5C /r
    (with1 (subpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 92 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subpd xmm m128: Subtract packed double-precision floating- point values in xmm2/m128 from xmm1.
(instance WriteInst.Subpd.Xmm.Memory (forall W Error) (WriteInst W Error (Subpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 5C /r
    (with1 (subpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 92 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Subps Op0 Op1) (subps: Op0 Op1))

; subps xmm xmm: Subtract packed single-precision floating-point values in xmm2/mem from xmm1.
(instance WriteInst.Subps.Xmm.Xmm (forall W Error) (WriteInst W Error (Subps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5C /r
    (with1 (subps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 92 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subps xmm m128: Subtract packed single-precision floating-point values in xmm2/mem from xmm1.
(instance WriteInst.Subps.Xmm.Memory (forall W Error) (WriteInst W Error (Subps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 5C /r
    (with1 (subps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 92 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Subq Op0 Op1) (subq: Op0 Op1))

; subq r64 r64: Subtract r/m64 from r64.
(instance WriteInst.Subq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Subq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 2B /r
    (with1 (subq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subq r64 m64: Subtract r/m64 from r64.
(instance WriteInst.Subq.Gpr64.Memory (forall W Error) (WriteInst W Error (Subq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 2B /r
    (with1 (subq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subq m64 r64: Subtract r64 from r/m64.
(instance WriteInst.Subq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Subq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 29 /r
    (with1 (subq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 41 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subq r64 imm8: Subtract sign-extended imm8 from r/m64.
(instance WriteInst.Subq.Gpr64.I8 (forall W Error) (WriteInst W Error (Subq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /5 ib
    (with1 (subq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subq m64 imm8: Subtract sign-extended imm8 from r/m64.
(instance WriteInst.Subq.Memory.I8 (forall W Error) (WriteInst W Error (Subq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /5 ib
    (with1 (subq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subq r64 imm32: Subtract imm32 sign-extended to 64-bits from r/m64.
(instance WriteInst.Subq.Gpr64.I32 (forall W Error) (WriteInst W Error (Subq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /5 id
    (with1 (subq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subq m64 imm32: Subtract imm32 sign-extended to 64-bits from r/m64.
(instance WriteInst.Subq.Memory.I32 (forall W Error) (WriteInst W Error (Subq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /5 id
    (with1 (subq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subq _Rax imm32: Subtract imm32 sign-extended to 64-bits from RAX.
(instance WriteInst.Subq.|Rax.I32 (forall W Error) (WriteInst W Error (Subq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 2D id
    (with1 (subq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 45 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Subsd Op0 Op1) (subsd: Op0 Op1))

; subsd xmm xmm: Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.
(instance WriteInst.Subsd.Xmm.Xmm (forall W Error) (WriteInst W Error (Subsd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5C /r
    (with1 (subsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 92 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subsd xmm m64: Subtracts the low double-precision floating- point values in xmm2/mem64 from xmm1.
(instance WriteInst.Subsd.Xmm.Memory (forall W Error) (WriteInst W Error (Subsd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F2 0F 5C /r
    (with1 (subsd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 242 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 92 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Subss Op0 Op1) (subss: Op0 Op1))

; subss xmm xmm: Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.
(instance WriteInst.Subss.Xmm.Xmm (forall W Error) (WriteInst W Error (Subss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5C /r
    (with1 (subss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 92 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subss xmm m32: Subtract the lower single-precision floating- point values in xmm2/m32 from xmm1.
(instance WriteInst.Subss.Xmm.Memory (forall W Error) (WriteInst W Error (Subss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F3 0F 5C /r
    (with1 (subss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 243 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 92 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Subw Op0 Op1) (subw: Op0 Op1))

; subw r16 r16: Subtract r/m16 from r16.
(instance WriteInst.Subw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Subw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 2B /r
    (with1 (subw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subw r16 m16: Subtract r/m16 from r16.
(instance WriteInst.Subw.Gpr16.Memory (forall W Error) (WriteInst W Error (Subw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 2B /r
    (with1 (subw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 43 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subw m16 r16: Subtract r16 from r/m16.
(instance WriteInst.Subw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Subw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 29 /r
    (with1 (subw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 41 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; subw r16 imm8: Subtract sign-extended imm8 from r/m16.
(instance WriteInst.Subw.Gpr16.I8 (forall W Error) (WriteInst W Error (Subw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /5 ib
    (with1 (subw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subw m16 imm8: Subtract sign-extended imm8 from r/m16.
(instance WriteInst.Subw.Memory.I8 (forall W Error) (WriteInst W Error (Subw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /5 ib
    (with1 (subw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subw r16 imm16: Subtract imm16 from r/m16.
(instance WriteInst.Subw.Gpr16.I16 (forall W Error) (WriteInst W Error (Subw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /5 iw
    (with1 (subw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subw m16 imm16: Subtract imm16 from r/m16.
(instance WriteInst.Subw.Memory.I16 (forall W Error) (WriteInst W Error (Subw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /5 iw
    (with1 (subw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; subw _Ax imm16: Subtract imm16 from AX.
(instance WriteInst.Subw.|Ax.I16 (forall W Error) (WriteInst W Error (Subw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 2D iw
    (with1 (subw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 45 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data Swapgs swapgs:)

; swapgs: Exchanges the current GS base register value with the value contained in MSR address C0000102H.
(instance WriteInst.Swapgs (forall W Error) (WriteInst W Error Swapgs) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 01 F8
    (with1 swapgs: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 1 w)!
        (write-u8! 248 w)!
        (ok unit)))))

(value-data (Testb Op0 Op1) (testb: Op0 Op1))

; testb r8 r8: AND r8 with r/m8; set SF, ZF, PF according to result.
(instance WriteInst.Testb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Testb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 84 /r
    (with1 (testb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 132 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; testb m8 r8: AND r8 with r/m8; set SF, ZF, PF according to result.
(instance WriteInst.Testb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Testb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 84 /r
    (with1 (testb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 132 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; testb r8 imm8: AND imm8 with r/m8; set SF, ZF, PF according to result.
(instance WriteInst.Testb.Gpr8.I8 (forall W Error) (WriteInst W Error (Testb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /0 ib
    (with1 (testb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; testb m8 imm8: AND imm8 with r/m8; set SF, ZF, PF according to result.
(instance WriteInst.Testb.Memory.I8 (forall W Error) (WriteInst W Error (Testb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F6 /0 ib
    (with1 (testb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 246 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; testb _Al imm8: AND imm8 with AL; set SF, ZF, PF according to result.
(instance WriteInst.Testb.|Al.I8 (forall W Error) (WriteInst W Error (Testb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; A8 ib
    (with1 (testb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 168 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Testl Op0 Op1) (testl: Op0 Op1))

; testl r32 r32: AND r32 with r/m32; set SF, ZF, PF according to result.
(instance WriteInst.Testl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Testl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 85 /r
    (with1 (testl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 133 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; testl m32 r32: AND r32 with r/m32; set SF, ZF, PF according to result.
(instance WriteInst.Testl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Testl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 85 /r
    (with1 (testl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 133 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; testl r32 imm32: AND imm32 with r/m32; set SF, ZF, PF according to result.
(instance WriteInst.Testl.Gpr32.I32 (forall W Error) (WriteInst W Error (Testl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /0 id
    (with1 (testl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; testl m32 imm32: AND imm32 with r/m32; set SF, ZF, PF according to result.
(instance WriteInst.Testl.Memory.I32 (forall W Error) (WriteInst W Error (Testl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; F7 /0 id
    (with1 (testl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; testl _Eax imm32: AND imm32 with EAX; set SF, ZF, PF according to result.
(instance WriteInst.Testl.|Eax.I32 (forall W Error) (WriteInst W Error (Testl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; A9 id
    (with1 (testl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 169 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Testq Op0 Op1) (testq: Op0 Op1))

; testq r64 r64: AND r64 with r/m64; set SF, ZF, PF according to result.
(instance WriteInst.Testq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Testq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 85 /r
    (with1 (testq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 133 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; testq m64 r64: AND r64 with r/m64; set SF, ZF, PF according to result.
(instance WriteInst.Testq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Testq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 85 /r
    (with1 (testq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 133 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; testq r64 imm32: AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.
(instance WriteInst.Testq.Gpr64.I32 (forall W Error) (WriteInst W Error (Testq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /0 id
    (with1 (testq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; testq m64 imm32: AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result.
(instance WriteInst.Testq.Memory.I32 (forall W Error) (WriteInst W Error (Testq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ F7 /0 id
    (with1 (testq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; testq _Rax imm32: AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result.
(instance WriteInst.Testq.|Rax.I32 (forall W Error) (WriteInst W Error (Testq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ A9 id
    (with1 (testq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 169 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Testw Op0 Op1) (testw: Op0 Op1))

; testw r16 r16: AND r16 with r/m16; set SF, ZF, PF according to result.
(instance WriteInst.Testw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Testw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 85 /r
    (with1 (testw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 133 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; testw m16 r16: AND r16 with r/m16; set SF, ZF, PF according to result.
(instance WriteInst.Testw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Testw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 85 /r
    (with1 (testw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 133 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; testw r16 imm16: AND imm16 with r/m16; set SF, ZF, PF according to result.
(instance WriteInst.Testw.Gpr16.I16 (forall W Error) (WriteInst W Error (Testw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /0 iw
    (with1 (testw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; testw m16 imm16: AND imm16 with r/m16; set SF, ZF, PF according to result.
(instance WriteInst.Testw.Memory.I16 (forall W Error) (WriteInst W Error (Testw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 F7 /0 iw
    (with1 (testw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 0) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 247 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; testw _Ax imm16: AND imm16 with AX; set SF, ZF, PF according to result.
(instance WriteInst.Testw.|Ax.I16 (forall W Error) (WriteInst W Error (Testw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 A9 iw
    (with1 (testw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 169 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Ucomisd Op0 Op1) (ucomisd: Op0 Op1))

; ucomisd xmm xmm: Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.
(instance WriteInst.Ucomisd.Xmm.Xmm (forall W Error) (WriteInst W Error (Ucomisd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 2E /r
    (with1 (ucomisd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 46 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; ucomisd xmm m64: Compares (unordered) the low double- precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.
(instance WriteInst.Ucomisd.Xmm.Memory (forall W Error) (WriteInst W Error (Ucomisd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 2E /r
    (with1 (ucomisd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 46 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Ucomiss Op0 Op1) (ucomiss: Op0 Op1))

; ucomiss xmm xmm: Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.
(instance WriteInst.Ucomiss.Xmm.Xmm (forall W Error) (WriteInst W Error (Ucomiss Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 2E /r
    (with1 (ucomiss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 46 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; ucomiss xmm m32: Compare lower single-precision floating-point value in xmm1 register with lower single- precision floating-point value in xmm2/mem and set the status flags accordingly.
(instance WriteInst.Ucomiss.Xmm.Memory (forall W Error) (WriteInst W Error (Ucomiss Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 2E /r
    (with1 (ucomiss: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 46 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Ud2 ud2:)

; ud2: Raise invalid opcode exception.
(instance WriteInst.Ud2 (forall W Error) (WriteInst W Error Ud2) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 0B
    (with1 ud2: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 11 w)!
        (ok unit)))))

(value-data (Unpckhpd Op0 Op1) (unpckhpd: Op0 Op1))

; unpckhpd xmm xmm: Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.
(instance WriteInst.Unpckhpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Unpckhpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 15 /r
    (with1 (unpckhpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 21 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; unpckhpd xmm m128: Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.
(instance WriteInst.Unpckhpd.Xmm.Memory (forall W Error) (WriteInst W Error (Unpckhpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 15 /r
    (with1 (unpckhpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 21 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Unpckhps Op0 Op1) (unpckhps: Op0 Op1))

; unpckhps xmm xmm: Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.
(instance WriteInst.Unpckhps.Xmm.Xmm (forall W Error) (WriteInst W Error (Unpckhps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 15 /r
    (with1 (unpckhps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 21 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; unpckhps xmm m128: Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.
(instance WriteInst.Unpckhps.Xmm.Memory (forall W Error) (WriteInst W Error (Unpckhps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 15 /r
    (with1 (unpckhps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 21 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Unpcklpd Op0 Op1) (unpcklpd: Op0 Op1))

; unpcklpd xmm xmm: Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.
(instance WriteInst.Unpcklpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Unpcklpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 14 /r
    (with1 (unpcklpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 20 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; unpcklpd xmm m128: Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.
(instance WriteInst.Unpcklpd.Xmm.Memory (forall W Error) (WriteInst W Error (Unpcklpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 14 /r
    (with1 (unpcklpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 20 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Unpcklps Op0 Op1) (unpcklps: Op0 Op1))

; unpcklps xmm xmm: Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.
(instance WriteInst.Unpcklps.Xmm.Xmm (forall W Error) (WriteInst W Error (Unpcklps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 14 /r
    (with1 (unpcklps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 20 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; unpcklps xmm m128: Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.
(instance WriteInst.Unpcklps.Xmm.Memory (forall W Error) (WriteInst W Error (Unpcklps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 14 /r
    (with1 (unpcklps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 20 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Verr Op0) (verr: Op0))

; verr r16: Set ZF=1 if segment specified with r/m16 can be read.
(instance WriteInst.Verr.Gpr16 (forall W Error) (WriteInst W Error (Verr Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 00 /4
    (with1 (verr: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 0 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; verr m16: Set ZF=1 if segment specified with r/m16 can be read.
(instance WriteInst.Verr.Memory (forall W Error) (WriteInst W Error (Verr Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 00 /4
    (with1 (verr: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 4) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 0 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Verw Op0) (verw: Op0))

; verw r16: Set ZF=1 if segment specified with r/m16 can be written.
(instance WriteInst.Verw.Gpr16 (forall W Error) (WriteInst W Error (Verw Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 00 /5
    (with1 (verw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 0 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; verw m16: Set ZF=1 if segment specified with r/m16 can be written.
(instance WriteInst.Verw.Memory (forall W Error) (WriteInst W Error (Verw Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 00 /5
    (with1 (verw: (let op0)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 5) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 0 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data Wbinvd wbinvd:)

; wbinvd: Write back and flush Internal caches; initiate writing-back and flushing of external caches.
(instance WriteInst.Wbinvd (forall W Error) (WriteInst W Error Wbinvd) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 09
    (with1 wbinvd: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 9 w)!
        (ok unit)))))

(value-data Wrmsr wrmsr:)

; wrmsr: Write the value in EDX:EAX to MSR specified by ECX.
(instance WriteInst.Wrmsr (forall W Error) (WriteInst W Error Wrmsr) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 30
    (with1 wrmsr: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 48 w)!
        (ok unit)))))

(value-data (Xaddb Op0 Op1) (xaddb: Op0 Op1))

; xaddb r8 r8: Exchange r8 and r/m8; load sum into r/m8.
(instance WriteInst.Xaddb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Xaddb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C0 /r
    (with1 (xaddb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xaddb m8 r8: Exchange r8 and r/m8; load sum into r/m8.
(instance WriteInst.Xaddb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Xaddb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C0 /r
    (with1 (xaddb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 192 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Xaddl Op0 Op1) (xaddl: Op0 Op1))

; xaddl r32 r32: Exchange r32 and r/m32; load sum into r/m32.
(instance WriteInst.Xaddl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Xaddl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C1 /r
    (with1 (xaddl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xaddl m32 r32: Exchange r32 and r/m32; load sum into r/m32.
(instance WriteInst.Xaddl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Xaddl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F C1 /r
    (with1 (xaddl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Xaddq Op0 Op1) (xaddq: Op0 Op1))

; xaddq r64 r64: Exchange r64 and r/m64; load sum into r/m64.
(instance WriteInst.Xaddq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Xaddq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F C1 /r
    (with1 (xaddq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xaddq m64 r64: Exchange r64 and r/m64; load sum into r/m64.
(instance WriteInst.Xaddq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Xaddq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 0F C1 /r
    (with1 (xaddq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Xaddw Op0 Op1) (xaddw: Op0 Op1))

; xaddw r16 r16: Exchange r16 and r/m16; load sum into r/m16.
(instance WriteInst.Xaddw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Xaddw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C1 /r
    (with1 (xaddw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xaddw m16 r16: Exchange r16 and r/m16; load sum into r/m16.
(instance WriteInst.Xaddw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Xaddw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F C1 /r
    (with1 (xaddw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 193 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Xchgb Op0 Op1) (xchgb: Op0 Op1))

; xchgb r8 r8: Exchange byte from r/m8 with r8 (byte register).
(instance WriteInst.Xchgb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Xchgb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 86 /r
    (with1 (xchgb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 134 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgb r8 m8: Exchange byte from r/m8 with r8 (byte register).
(instance WriteInst.Xchgb.Gpr8.Memory (forall W Error) (WriteInst W Error (Xchgb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 86 /r
    (with1 (xchgb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 134 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgb m8 r8: Exchange r8 (byte register) with byte from r/m8.
(instance WriteInst.Xchgb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Xchgb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 86 /r
    (with1 (xchgb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 134 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Xchgl Op0 Op1) (xchgl: Op0 Op1))

; xchgl r32 r32: Exchange doubleword from r/m32 with r32.
(instance WriteInst.Xchgl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Xchgl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 87 /r
    (with1 (xchgl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgl r32 m32: Exchange doubleword from r/m32 with r32.
(instance WriteInst.Xchgl.Gpr32.Memory (forall W Error) (WriteInst W Error (Xchgl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 87 /r
    (with1 (xchgl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgl r32 _Eax: Exchange EAX with r32.
(instance WriteInst.Xchgl.Gpr32.|Eax (forall W Error) (WriteInst W Error (Xchgl Gpr32 |Eax)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 90 +rd
    (with1 (xchgl: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 144 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

; xchgl m32 r32: Exchange r32 with doubleword from r/m32.
(instance WriteInst.Xchgl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Xchgl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 87 /r
    (with1 (xchgl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgl _Eax r32: Exchange r32 with EAX.
(instance WriteInst.Xchgl.|Eax.Gpr32 (forall W Error) (WriteInst W Error (Xchgl |Eax Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 90 +rd
    (with1 (xchgl: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op1)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 144 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

(value-data (Xchgq Op0 Op1) (xchgq: Op0 Op1))

; xchgq r64 r64: Exchange quadword from r/m64 with r64.
(instance WriteInst.Xchgq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Xchgq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 87 /r
    (with1 (xchgq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgq r64 m64: Exchange quadword from r/m64 with r64.
(instance WriteInst.Xchgq.Gpr64.Memory (forall W Error) (WriteInst W Error (Xchgq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 87 /r
    (with1 (xchgq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgq r64 _Rax: Exchange RAX with r64.
(instance WriteInst.Xchgq.Gpr64.|Rax (forall W Error) (WriteInst W Error (Xchgq Gpr64 |Rax)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 90 +ro
    (with1 (xchgq: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #t) (write-u8! b w)!)
        (write-u8! (+ 144 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

; xchgq m64 r64: Exchange r64 with quadword from r/m64.
(instance WriteInst.Xchgq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Xchgq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 87 /r
    (with1 (xchgq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgq _Rax r64: Exchange r64 with RAX.
(instance WriteInst.Xchgq.|Rax.Gpr64 (forall W Error) (WriteInst W Error (Xchgq |Rax Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 90 +ro
    (with1 (xchgq: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op1)])
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #t) (write-u8! b w)!)
        (write-u8! (+ 144 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

(value-data (Xchgw Op0 Op1) (xchgw: Op0 Op1))

; xchgw r16 r16: Exchange word from r/m16 with r16.
(instance WriteInst.Xchgw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Xchgw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 87 /r
    (with1 (xchgw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgw r16 m16: Exchange word from r/m16 with r16.
(instance WriteInst.Xchgw.Gpr16.Memory (forall W Error) (WriteInst W Error (Xchgw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 87 /r
    (with1 (xchgw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgw r16 _Ax: Exchange AX with r16.
(instance WriteInst.Xchgw.Gpr16.|Ax (forall W Error) (WriteInst W Error (Xchgw Gpr16 |Ax)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 90 +rw
    (with1 (xchgw: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 144 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

; xchgw m16 r16: Exchange r16 with word from r/m16.
(instance WriteInst.Xchgw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Xchgw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 87 /r
    (with1 (xchgw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 135 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xchgw _Ax r16: Exchange r16 with AX.
(instance WriteInst.Xchgw.|Ax.Gpr16 (forall W Error) (WriteInst W Error (Xchgw |Ax Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 90 +rw
    (with1 (xchgw: (let op0) (let op1)) inst
      (let ([rio (reg-in-opcode/new op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (reg-in-opcode/rex-byte? rio #f) (write-u8! b w)!)
        (write-u8! (+ 144 (reg-in-opcode/byte-added-to-opcode rio)) w)!
        (ok unit)))))

(value-data (Xorb Op0 Op1) (xorb: Op0 Op1))

; xorb r8 r8: r8 XOR r/m8.
(instance WriteInst.Xorb.Gpr8.Gpr8 (forall W Error) (WriteInst W Error (Xorb Gpr8 Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 32 /r
    (with1 (xorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 50 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorb r8 m8: r8 XOR r/m8.
(instance WriteInst.Xorb.Gpr8.Memory (forall W Error) (WriteInst W Error (Xorb Gpr8 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 32 /r
    (with1 (xorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 50 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorb m8 r8: r/m8 XOR r8.
(instance WriteInst.Xorb.Memory.Gpr8 (forall W Error) (WriteInst W Error (Xorb Memory Gpr8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 30 /r
    (with1 (xorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 48 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorb r8 imm8: r/m8 XOR imm8.
(instance WriteInst.Xorb.Gpr8.I8 (forall W Error) (WriteInst W Error (Xorb Gpr8 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /6 ib
    (with1 (xorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorb m8 imm8: r/m8 XOR imm8.
(instance WriteInst.Xorb.Memory.I8 (forall W Error) (WriteInst W Error (Xorb Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 80 /6 ib
    (with1 (xorb: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 128 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorb _Al imm8: AL XOR imm8.
(instance WriteInst.Xorb.|Al.I8 (forall W Error) (WriteInst W Error (Xorb |Al I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 34 ib
    (with1 (xorb: (let op0) (let op1)) inst
      (let ()
        (write-u8! 52 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Xorl Op0 Op1) (xorl: Op0 Op1))

; xorl r32 r32: r32 XOR r/m32.
(instance WriteInst.Xorl.Gpr32.Gpr32 (forall W Error) (WriteInst W Error (Xorl Gpr32 Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 33 /r
    (with1 (xorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 51 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorl r32 m32: r32 XOR r/m32.
(instance WriteInst.Xorl.Gpr32.Memory (forall W Error) (WriteInst W Error (Xorl Gpr32 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 33 /r
    (with1 (xorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 51 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorl m32 r32: r/m32 XOR r32.
(instance WriteInst.Xorl.Memory.Gpr32 (forall W Error) (WriteInst W Error (Xorl Memory Gpr32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 31 /r
    (with1 (xorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 49 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorl r32 imm8: r/m32 XOR imm8 (sign-extended).
(instance WriteInst.Xorl.Gpr32.I8 (forall W Error) (WriteInst W Error (Xorl Gpr32 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /6 ib
    (with1 (xorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorl m32 imm8: r/m32 XOR imm8 (sign-extended).
(instance WriteInst.Xorl.Memory.I8 (forall W Error) (WriteInst W Error (Xorl Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 83 /6 ib
    (with1 (xorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorl r32 imm32: r/m32 XOR imm32.
(instance WriteInst.Xorl.Gpr32.I32 (forall W Error) (WriteInst W Error (Xorl Gpr32 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /6 id
    (with1 (xorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorl m32 imm32: r/m32 XOR imm32.
(instance WriteInst.Xorl.Memory.I32 (forall W Error) (WriteInst W Error (Xorl Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 81 /6 id
    (with1 (xorl: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorl _Eax imm32: EAX XOR imm32.
(instance WriteInst.Xorl.|Eax.I32 (forall W Error) (WriteInst W Error (Xorl |Eax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 35 id
    (with1 (xorl: (let op0) (let op1)) inst
      (let ()
        (write-u8! 53 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Xorpd Op0 Op1) (xorpd: Op0 Op1))

; xorpd xmm xmm: Bitwise exclusive-OR of xmm2/m128 and xmm1.
(instance WriteInst.Xorpd.Xmm.Xmm (forall W Error) (WriteInst W Error (Xorpd Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 57 /r
    (with1 (xorpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 87 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorpd xmm m128: Bitwise exclusive-OR of xmm2/m128 and xmm1.
(instance WriteInst.Xorpd.Xmm.Memory (forall W Error) (WriteInst W Error (Xorpd Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 0F 57 /r
    (with1 (xorpd: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 87 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Xorps Op0 Op1) (xorps: Op0 Op1))

; xorps xmm xmm: Bitwise exclusive-OR of xmm2/m128 and xmm1.
(instance WriteInst.Xorps.Xmm.Xmm (forall W Error) (WriteInst W Error (Xorps Xmm Xmm)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 57 /r
    (with1 (xorps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 87 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorps xmm m128: Bitwise exclusive-OR of xmm2/m128 and xmm1.
(instance WriteInst.Xorps.Xmm.Memory (forall W Error) (WriteInst W Error (Xorps Xmm Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 57 /r
    (with1 (xorps: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 15 w)!
        (write-u8! 87 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

(value-data (Xorq Op0 Op1) (xorq: Op0 Op1))

; xorq r64 r64: r64 XOR r/m64.
(instance WriteInst.Xorq.Gpr64.Gpr64 (forall W Error) (WriteInst W Error (Xorq Gpr64 Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 33 /r
    (with1 (xorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 51 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorq r64 m64: r64 XOR r/m64.
(instance WriteInst.Xorq.Gpr64.Memory (forall W Error) (WriteInst W Error (Xorq Gpr64 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 33 /r
    (with1 (xorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 51 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorq m64 r64: r/m64 XOR r64.
(instance WriteInst.Xorq.Memory.Gpr64 (forall W Error) (WriteInst W Error (Xorq Memory Gpr64)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 31 /r
    (with1 (xorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 49 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorq r64 imm8: r/m64 XOR imm8 (sign-extended).
(instance WriteInst.Xorq.Gpr64.I8 (forall W Error) (WriteInst W Error (Xorq Gpr64 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /6 ib
    (with1 (xorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorq m64 imm8: r/m64 XOR imm8 (sign-extended).
(instance WriteInst.Xorq.Memory.I8 (forall W Error) (WriteInst W Error (Xorq Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 83 /6 ib
    (with1 (xorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorq r64 imm32: r/m64 XOR imm32 (sign-extended).
(instance WriteInst.Xorq.Gpr64.I32 (forall W Error) (WriteInst W Error (Xorq Gpr64 I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /6 id
    (with1 (xorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorq m64 imm32: r/m64 XOR imm32 (sign-extended).
(instance WriteInst.Xorq.Memory.I32 (forall W Error) (WriteInst W Error (Xorq Memory I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 81 /6 id
    (with1 (xorq: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #t) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorq _Rax imm32: RAX XOR imm32 (sign-extended).
(instance WriteInst.Xorq.|Rax.I32 (forall W Error) (WriteInst W Error (Xorq |Rax I32)) (where (Write W Error))
  (function (write-inst! w inst)
    ; REX.W+ 35 id
    (with1 (xorq: (let op0) (let op1)) inst
      (let ()
        (when-match1 (some (let b)) (rex-prefix/byte? default #t #f #f #f) (write-u8! b w)!)
        (write-u8! 53 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data (Xorw Op0 Op1) (xorw: Op0 Op1))

; xorw r16 r16: r16 XOR r/m16.
(instance WriteInst.Xorw.Gpr16.Gpr16 (forall W Error) (WriteInst W Error (Xorw Gpr16 Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 33 /r
    (with1 (xorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 51 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorw r16 m16: r16 XOR r/m16.
(instance WriteInst.Xorw.Gpr16.Memory (forall W Error) (WriteInst W Error (Xorw Gpr16 Memory)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 33 /r
    (with1 (xorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op0 op1)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 51 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorw m16 r16: r/m16 XOR r16.
(instance WriteInst.Xorw.Memory.Gpr16 (forall W Error) (WriteInst W Error (Xorw Memory Gpr16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 31 /r
    (with1 (xorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new op1 op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 49 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (ok unit)))))

; xorw r16 imm8: r/m16 XOR imm8 (sign-extended).
(instance WriteInst.Xorw.Gpr16.I8 (forall W Error) (WriteInst W Error (Xorw Gpr16 I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /6 ib
    (with1 (xorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorw m16 imm8: r/m16 XOR imm8 (sign-extended).
(instance WriteInst.Xorw.Memory.I8 (forall W Error) (WriteInst W Error (Xorw Memory I8)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 83 /6 ib
    (with1 (xorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 131 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorw r16 imm16: r/m16 XOR imm16.
(instance WriteInst.Xorw.Gpr16.I16 (forall W Error) (WriteInst W Error (Xorw Gpr16 I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /6 iw
    (with1 (xorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorw m16 imm16: r/m16 XOR imm16.
(instance WriteInst.Xorw.Memory.I16 (forall W Error) (WriteInst W Error (Xorw Memory I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 81 /6 iw
    (with1 (xorw: (let op0) (let op1)) inst
      (let ([modrm (mod-rm/new (part-of-opcode: 6) op0)])
        (write-u8! 102 w)!
        (when-match1 (some (let b)) (mod-rm/rex-byte? modrm #f) (write-u8! b w)!)
        (write-u8! 129 w)!
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

; xorw _Ax imm16: AX XOR imm16.
(instance WriteInst.Xorw.|Ax.I16 (forall W Error) (WriteInst W Error (Xorw |Ax I16)) (where (Write W Error))
  (function (write-inst! w inst)
    ; 66 35 iw
    (with1 (xorw: (let op0) (let op1)) inst
      (let ()
        (write-u8! 102 w)!
        (write-u8! 53 w)!
        (write-bytes! (array/unsafe-temporary-bytearray op1) w)!
        (ok unit)))))

(value-data Xsetbv xsetbv:)

; xsetbv: Write the value in EDX:EAX to the XCR specified by ECX.
(instance WriteInst.Xsetbv (forall W Error) (WriteInst W Error Xsetbv) (where (Write W Error))
  (function (write-inst! w inst)
    ; 0F 01 D1
    (with1 xsetbv: inst
      (let ()
        (write-u8! 15 w)!
        (write-u8! 1 w)!
        (write-u8! 209 w)!
        (ok unit)))))
