{%- macro ops(inst) -%}
{%- for (i, _) in inst.operands().iter().enumerate() %} op{{ i }}{% endfor -%}
{%- endmacro -%}

{%- macro deops(inst) -%}
{%- for (i, _) in inst.operands().iter().enumerate() %} (let op{{ i }}){% endfor -%}
{%- endmacro -%}

{%- macro Ops(inst) -%}
{%- for (i, _) in inst.operands().iter().enumerate() %} Op{{ i }}{% endfor -%}
{%- endmacro -%}

{%- macro inst_params(sep, inst) -%}
{%- for o in inst.operands().iter() %}{{ sep }}{{ o|llrloperand }}{% endfor -%}
{%- endmacro -%}

{%- macro vcon(mnemonic, inst) -%}
{%- if !inst.operands().is_empty() -%}({%- endif -%}
{{ mnemonic }}:{%- call ops(inst) -%}
{%- if !inst.operands().is_empty() -%}){%- endif -%}
{%- endmacro -%}

{%- macro vdecon(mnemonic, inst) -%}
{%- if !inst.operands().is_empty() -%}({%- endif -%}
{{ mnemonic }}:{%- call deops(inst) -%}
{%- if !inst.operands().is_empty() -%}){%- endif -%}
{%- endmacro -%}

{%- macro vconsig(mnemonic, inst) -%}
{%- if !inst.operands().is_empty() -%}({%- endif -%}
{{ mnemonic }}:{%- call Ops(inst) -%}
{%- if !inst.operands().is_empty() -%}){%- endif -%}
{%- endmacro -%}

{%- macro tycon(mnemonic, inst) -%}
{%- if !inst.operands().is_empty() -%}({%- endif -%}
{{ mnemonic|capitalize }}{%- call Ops(inst) -%}
{%- if !inst.operands().is_empty() -%}){%- endif -%}
{%- endmacro -%}

{%- macro inst_name(mnemonic, inst) -%}
WriteInst.{{ mnemonic|capitalize }}{% call inst_params(".", inst) %}
{%- endmacro -%}

{%- macro inst_con(mnemonic, inst) -%}
{%- if !inst.operands().is_empty() -%}({%- endif -%}
{{ mnemonic|capitalize }}{%- call inst_params(" ", inst) -%}
{%- if !inst.operands().is_empty() -%}){%- endif -%}
{%- endmacro -%}

; This file is generated by xtencg. !!!DO NOT EDIT THIS FILE!!!

(import "~/asm/encoding" _)
(import "~/asm/operand" _)
(export WriteInst WriteInst._ write-inst!)

{% for (mnemonic, insts) in inst_set -%}
{%- let inst = insts.first().unwrap() -%}
(export {{ mnemonic }}! {{ mnemonic|capitalize }} {{ mnemonic }}:)
{% endfor %}

{% for (mnemonic, insts) in inst_set -%}
{%- let inst = insts.first().unwrap() -%}
(function ({{ mnemonic }}! w{% call ops(inst) %}) (write-inst! w {% call vcon(mnemonic, inst) %}))
{% endfor %}

(class (WriteInst W Error Inst)
  (function (write-inst! w inst) {(-> W Inst (Result unit Error))}))

{%- for (mnemonic, insts) in inst_set %}
{%- let inst = insts.first().unwrap() %}

(value-data {% call tycon(mnemonic, inst) %} {% call vconsig(mnemonic, inst) %})

{%- for inst in insts.iter() %}
{%- let enc = inst.encoding() %}

; {{ inst }}: {{ inst.description() }}
(instance {% call inst_name(mnemonic, inst) %} (forall W Error) (WriteInst W Error {% call inst_con(mnemonic, inst) %}) (where (Write W Error))
  (function (write-inst! w inst)
    ; {{ enc }}
    (with1 {% call vdecon(mnemonic, inst) %} inst
      (let (

{%- match inst.modrm() -%}
{%- when Some with ((reg, rm)) -%}
        [modrm (mod-rm/new
{%- match reg -%}
{%- when Reg::PartOfOpcode with (opcode) %} (part-of-opcode: {{ opcode }})
{%- when Reg::Operand with (operand) %} op{{ operand }}
{%- when Reg::Default %} default
{%- endmatch -%}
{%- match rm -%}
{%- when Rm::Operand with (operand) %} op{{ operand }}
{%- when Rm::Default %} default
{%- endmatch -%}
        )]
{%- when None -%}
{%- endmatch -%}

{%- match inst.reg_in_opcode() -%}
{%- when Some with (r) -%}
        [rio (reg-in-opcode/new op{{ r.operand }})]
{%- when None -%}
{%- endmatch -%}
      )

{%- for o in enc.prefixes() %}
        (write-u8! {{ o }} w)!
{%- endfor %}

{%- match inst.rex_source() %}
{%- when Some with (rex_source) %}
        (when-match1 (some (let b))
{%- match rex_source -%}
{%- when RexSource::ModRM with { w } %} (mod-rm/rex-byte? modrm {{ w|llrlbool }})
{%- when RexSource::RegInOpcode with { w } %} (reg-in-opcode/rex-byte? rio {{ w|llrlbool }})
{%- when RexSource::Standalone with { w } %} (rex-prefix/byte? default {{ w|llrlbool }} #f #f #f)
{%- endmatch %} (write-u8! b w)!)
{%- else %}
{%- endmatch %}

{%- for (i, o) in enc.opcode().enumerate() %}
{%- if i == enc.opcode().len() - 1 && enc.reg_in_opcode().is_some() %}
        (write-u8! (+ {{ o }} (reg-in-opcode/byte-added-to-opcode rio)) w)!
{%- else %}
        (write-u8! {{ o }} w)!
{%- endif %}
{%- endfor %}

{%- if enc.code_offset().is_some() %}
        (write-bytes! (array/unsafe-temporary-bytearray op{{ inst.operand_map().code_offset.unwrap() }}) w)!
{%- endif %}

{%- if enc.modrm().is_some() %}
        (write-u8! (mod-rm/byte modrm) w)!
        (when-match1 (some (let b)) (mod-rm/sib-byte? modrm) (write-u8! b w)!)
        (write-bytes! (mod-rm/disp-bytes modrm) w)!
{%- endif %}

{%- if enc.immediate().is_some() %}
        (write-bytes! (array/unsafe-temporary-bytearray op{{ inst.operand_map().immediate.unwrap() }}) w)!
{%- endif %}
        (ok unit)))))

{%- endfor %}
{%- endfor %}
