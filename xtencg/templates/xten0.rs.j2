{%- macro generic_type_params(inst) -%}
{%- if !inst.operands().is_empty() -%}
<
{%- for (i, _) in inst.operands().iter().enumerate() -%}
{%- if i != 0 -%}, {% endif -%}Op{{ i }}
{%- endfor -%}
>
{%- endif -%}
{%- endmacro -%}

{%- macro impl_type_params(inst) -%}
{%- if !inst.operands().is_empty() -%}
<
{%- for (i, o) in inst.operands().iter().enumerate() -%}
{%- if i != 0 -%}, {% endif -%}{{ o|rsoperand }}
{%- endfor -%}
>
{%- endif -%}
{%- endmacro -%}

// This file is generated by xtencg. !!!DO NOT EDIT THIS FILE!!!

use super::encoding::*;
use super::operand::*;
use std::io;

pub trait WriteInstExt: io::Write {
{%- for (mnemonic, insts) in inst_set %}
{%- let inst = insts.first().unwrap() %}
    fn {{ mnemonic }}{% call generic_type_params(inst) %}(&mut self
{%- for (i, _) in inst.operands().iter().enumerate() -%}
, op{{ i }}: Op{{ i }}
{%- endfor -%}
    ) -> io::Result<()>
{%- if inst.operands().is_empty() %} {% else %}
    where
        {{ mnemonic|capitalize }}{% call generic_type_params(inst) %}: WriteInst<Self>,
    {% endif -%}
    {
        {{ mnemonic|capitalize }}(
{%- for (i, _) in inst.operands().iter().enumerate() -%}
{%- if i != 0 -%}, {% endif -%}op{{ i }}
{%- endfor -%}
        ).write_inst(self)
    }
{% endfor -%}
}

impl<W: io::Write + ?Sized> WriteInstExt for W {}

pub trait WriteInst<W: ?Sized> {
    fn write_inst(&self, w: &mut W) -> io::Result<()>;
}

{%- for (mnemonic, insts) in inst_set %}
{%- let inst = insts.first().unwrap() %}

pub struct {{ mnemonic|capitalize }}{% call generic_type_params(inst) %}(
{%- for (i, _) in inst.operands().iter().enumerate() -%}
{%- if i != 0 -%}, {% endif -%}pub Op{{ i }}
{%- endfor -%}
);

{%- for inst in insts.iter() %}
{%- let enc = inst.encoding() %}

/// {{ inst }}: {{ inst.description() }}
impl<W: io::Write + ?Sized> WriteInst<W> for {{ mnemonic|capitalize }}{% call impl_type_params(inst) %} {
    fn write_inst(&self, w: &mut W) -> io::Result<()> {
        // {{ enc }}

{%- match inst.modrm() %}
{%- when Some with ((reg, rm)) %}
        let modrm = ModRM::new(
{%- match reg -%}
{%- when Reg::PartOfOpcode with (opcode) -%} PartOfOpcode({{ opcode }})
{%- when Reg::Operand with (operand) -%} self.{{ operand }}
{%- when Reg::Default -%} Reg::default()
{%- endmatch %}, {% match rm -%}
{%- when Rm::Operand with (operand) -%} self.{{ operand }}
{%- when Rm::Default -%} Rm::default()
{%- endmatch -%}
        );
{%- when None %}
{%- endmatch %}

{%- match inst.reg_in_opcode() %}
{%- when Some with (r) %}
        let rio = RegInOpcode::from(self.{{ r.operand }});
{%- when None %}
{%- endmatch %}

{%- for o in enc.prefixes() %}
        put(w, {{ "0x{:02X}"|format(o) }})?;
{%- endfor %}

{%- match inst.rex_source() %}
{%- when Some with (rex_source) %}
        puts(w,
{%- match rex_source -%}
{%- when RexSource::ModRM with { w } %} modrm.rex_byte({{ w }})
{%- when RexSource::RegInOpcode with { w } %} rio.rex_byte({{ w }})
{%- when RexSource::Standalone with { w } %} rex_byte(false, {{ w }}, false, false, false)
{%- endmatch -%}
        )?;
{%- else %}
{%- endmatch %}

{%- for (i, o) in enc.opcode().enumerate() %}
        put(w, {{ "0x{:02X}"|format(o) }}
{%- if i == enc.opcode().len() - 1 && enc.reg_in_opcode().is_some() %} + rio.byte_added_to_opcode{%- endif -%}
        )?;
{%- endfor %}

{%- if enc.code_offset().is_some() %}
        puts(w, self.{{ inst.operand_map().code_offset.unwrap() }}.to_le_bytes())?;
{%- endif %}

{%- if enc.modrm().is_some() %}
        put(w, modrm.byte())?;
        puts(w, modrm.sib_byte())?;
        puts(w, modrm.disp_bytes().into_iter().flatten())?;
{%- endif %}

{%- if enc.immediate().is_some() %}
        puts(w, self.{{ inst.operand_map().immediate.unwrap() }}.to_le_bytes())?;
{%- endif %}
        Ok(())
    }
}
{%- endfor %}
{%- endfor %}

fn put(w: &mut (impl io::Write + ?Sized), b: u8) -> io::Result<()> {
    w.write_all(&[b])
}

fn puts(w: &mut (impl io::Write + ?Sized), bs: impl IntoIterator<Item = u8>) -> io::Result<()> {
    for b in bs {
        w.write_all(&[b])?;
    }
    Ok(())
}
